[{"id":"\/packages\/5.x\/Sql\/getting-started.html#1-1-1-1","title":"1.1.1.1. Instantiation","content":"You can instantiate ExtendedPdo so that it uses lazy connection, or you can use DecoratedPdo to decorate an existing PDO instance."},{"id":"\/packages\/5.x\/Sql\/getting-started.html#1-1-1-1-1","title":"1.1.1.1.1. Lazy Connection Instance","content":"Instantiation is the same as with the native PDO class: pass a data source name, username, password, and driver options. There is one additional parameter that allows you to pass attributes to be set after the connection is made.use Aura\\Sql\\ExtendedPdo; $pdo = new ExtendedPdo( 'mysql:host=localhost;dbname=test', 'username', 'password', [], \/\/ driver attributes\/options as key-value pairs [] \/\/ queries to execute after connection ); Whereas the native PDO connects on instantiation, ExtendedPdo does not connect immediately. Instead, it connects only when you call a method that actually needs the connection to the database; e.g., on query().If you want to force a connection, call the connect() method.\/\/ does not connect to the database $pdo = new ExtendedPdo( 'mysql:host=localhost;dbname=test', 'username', 'password' ); \/\/ automatically connects $pdo-&gt;exec('SELECT * FROM test'); \/\/ explicitly forces a connection $pdo-&gt;connect(); If you want to explicitly force a disconnect, call the disconnect() method.\/\/ explicitly forces disconnection $pdo-&gt;disconnect(); Doing so will close the connection by unsetting the internal PDO instance. However, calling an ExtendedPdo method that implicitly establishes a connection, such as query() or one of the fetch*() methods, will automatically re-connect to the database."},{"id":"\/packages\/5.x\/Sql\/getting-started.html#1-1-1-1-2","title":"1.1.1.1.2. Decorator Instance","content":"The DecoratedPdo class can be used to decorate an existing PDO connection with the ExtendedPdo methods. To do so, instantiate DecoratedPdo by passing an existing PDO connection:use Aura\\Sql\\DecoratedPdo; $pdo = new PDO(...); $decoratedPdo = new DecoratedPdo($pdo); The decorated PDO instance now provides all the ExtendedPdo functionality (aside from lazy connection, which is not possible since the PDO instance by definition has already connected).Decoration of this kind can be useful when you have access to an existing PDO connection managed elsewhere in your application. N.b.: The disconnect() method will not work on decorated PDO connections, since DecoratedPdo did not create the connection itself. You will need to manage the decorated PDO instance yourself in that case. "},{"id":"\/packages\/5.x\/Sql\/getting-started.html#1-1-1-2","title":"1.1.1.2. Array Quoting","content":"The native PDO quote() method will not quote arrays. This makes it difficult to bind an array to something like an IN (...) condition in SQL. However, ExtendedPdo recognizes arrays and converts them into comma- separated quoted strings.\/\/ the array to be quoted $array = array('foo', 'bar', 'baz'); \/\/ the native PDO way: \/\/ \"Warning: PDO::quote() expects parameter 1 to be string, array given\" $pdo = new PDO(...); $cond = 'IN (' . $pdo-&gt;quote($array) . ')'; \/\/ the ExtendedPdo way: \/\/ \"IN ('foo', 'bar', 'baz')\" $pdo = new ExtendedPdo(...); $cond = 'IN (' . $pdo-&gt;quote($array) . ')'; "},{"id":"\/packages\/5.x\/Sql\/getting-started.html#1-1-1-3","title":"1.1.1.3. The perform() Method","content":"The ExtendedPdo::perform() method will prepare a query with bound values in a single step. Also, because the native PDO does not deal with bound array values, perform() modifies the query string to expand the array-bound placeholder into multiple placeholders.\/\/ the array to be quoted $array = array('foo', 'bar', 'baz'); \/\/ the statement to prepare $stm = 'SELECT * FROM test WHERE foo IN (:foo)' \/\/ the native PDO way does not work (PHP Notice: Array to string conversion) $pdo = new ExtendedPdo(...); $sth = $pdo-&gt;prepare($stm); $sth-&gt;bindValue('foo', $array); \/\/ the ExtendedPdo way allows a single call to prepare and execute the query. \/\/ it quotes the array and expands the array placeholder directly in the \/\/ query string. $pdo = new ExtendedPdo(...); $bind_values = array('foo' =&gt; $array); $sth = $pdo-&gt;perform($stm, $bind_values); echo $sth-&gt;queryString; \/\/ the query string has been modified by ExtendedPdo to become \/\/ \"SELECT * FROM test WHERE foo IN (:foo_1, :foo_2, :foo_3)\" Finally, note that array quoting works only via the perform() method, not on returned PDOStatement instances."},{"id":"\/packages\/5.x\/Sql\/fetch.html#1-1-2","title":"1.1.2. The fetch*() Methods","content":"ExtendedPdo comes with fetch*() methods to help reduce boilerplate code. Instead of issuing prepare(), a series of bindValue() calls, execute(), and then fetch*() on a PDOStatement, you can bind values and fetch results in one call on ExtendedPdo directly. (The fetch*() methods use perform() internally, so quoting-and-replacement of array placeholders is supported.)$stm = 'SELECT * FROM test WHERE foo = :foo AND bar = :bar'; $bind = array('foo' =&gt; 'baz', 'bar' =&gt; 'dib'); \/\/ the native PDO way to \"fetch all\" where the result is a sequential array \/\/ of rows, and the row arrays are keyed on the column names $pdo = new PDO(...); $sth = $pdo-&gt;prepare($stm); $sth-&gt;execute($bind); $result = $sth-&gt;fetchAll(PDO::FETCH_ASSOC); \/\/ the ExtendedPdo way to do the same kind of \"fetch all\" $pdo = new ExtendedPdo(...); $result = $pdo-&gt;fetchAll($stm, $bind); \/\/ fetchAssoc() returns an associative array of all rows where the key is the \/\/ first column, and the row arrays are keyed on the column names $result = $pdo-&gt;fetchAssoc($stm, $bind); \/\/ fetchGroup() is like fetchAssoc() except that the values aren't wrapped in \/\/ arrays. Instead, single column values are returned as a single dimensional \/\/ array and multiple columns are returned as an array of arrays \/\/ Set style to PDO::FETCH_NAMED when values are an array \/\/ (i.e. there are more than two columns in the select) $result = $pdo-&gt;fetchGroup($stm, $bind, $style = PDO::FETCH_COLUMN) \/\/ fetchObject() returns the first row as an object of your choosing; the \/\/ columns are mapped to object properties. an optional 4th parameter array \/\/ provides constructor arguments when instantiating the object. $result = $pdo-&gt;fetchObject($stm, $bind, 'ClassName', array('ctor_arg_1')); \/\/ fetchObjects() returns an array of objects of your choosing; the \/\/ columns are mapped to object properties. an optional 4th parameter array \/\/ provides constructor arguments when instantiating the object. $result = $pdo-&gt;fetchObjects($stm, $bind, 'ClassName', array('ctor_arg_1')); \/\/ fetchOne() returns the first row as an associative array where the keys \/\/ are the column names $result = $pdo-&gt;fetchOne($stm, $bind); \/\/ fetchPairs() returns an associative array where each key is the first \/\/ column and each value is the second column $result = $pdo-&gt;fetchPairs($stm, $bind); \/\/ fetchValue() returns the value of the first row in the first column $result = $pdo-&gt;fetchValue($stm, $bind); \/\/ fetchAffected() returns the number of affected rows $stm = \"UPDATE test SET incr = incr + 1 WHERE foo = :foo AND bar = :bar\"; $row_count = $pdo-&gt;fetchAffected($stm, $bind); "},{"id":"\/packages\/5.x\/Sql\/yield.html#1-1-3","title":"1.1.3. The yield*() Methods","content":"ExtendedPdo comes with yield*() methods to help reduce memory usage. Whereas many fetch*() methods collect all the query result rows before returning them all at once, the equivalent yield*() methods generate one result row at a time. For example:$stm = 'SELECT * FROM test WHERE foo = :foo AND bar = :bar'; $bind = array('foo' =&gt; 'baz', 'bar' =&gt; 'dib'); \/\/ like fetchAll(), each row is an associative array foreach ($pdo-&gt;yieldAll($stm, $bind) as $row) { \/\/ ... } \/\/ like fetchAssoc(), each key is the first column, \/\/ and the row is an associative array foreach ($pdo-&gt;yieldAssoc($stm, $bind) as $key =&gt; $row) { \/\/ ... } \/\/ like fetchCol(), each result is a value from the first column foreach ($pdo-&gt;yieldCol($stm, $bind) as $val) { \/\/ ... } \/\/ like fetchObjects(), each result is an object; pass an optional \/\/ class name and optional array of constructor arguments. $class = 'ClassName'; $args = ['arg0', 'arg1', 'arg2']; foreach ($pdo-&gt;yieldObjects($stm, $bind, $class, $args) as $object) { \/\/ ... } \/\/ like fetchPairs(), each result is a key-value pair from the \/\/ first and second columns foreach ($pdo-&gt;yieldPairs($stm, $bind) as $key =&gt; $val) { \/\/ ... } "},{"id":"\/packages\/5.x\/Sql\/profiling-logging.html#1-1-4","title":"1.1.4. Profiling and Logging","content":"It is often useful to see what queries have been executed, where they were issued from in the codebase, and how long they took to complete. As such, ExtendedPdo comes with a profiler that logs to any PSR-3 implementation. The profiler defaults to a naive memory-based logger for debugging purposes."},{"id":"\/packages\/5.x\/Sql\/profiling-logging.html#1-1-4-1","title":"1.1.4.1. Using The Profiler","content":"You can activate and deactivate the profiler using the Profiler::setActive() method. (Messages are not logged when the profiler is not active.)You can then examine the log messages using the underlying log system; in the below example, we use the default MemoryLogger implementation.&lt;?php \/\/ activate the profiler $pdo-&gt;getProfiler()-&gt;setActive(true); \/\/ ... \/\/ query(), fetch(), beginTransaction()\/commit()\/rollback() etc. \/\/ ... \/\/ now retrieve the array messages from the default memory logger: $messages = $pdo-&gt;getProfiler()-&gt;getLogger()-&gt;getMessages(); print_r($messages); "},{"id":"\/packages\/5.x\/Sql\/profiling-logging.html#1-1-4-2","title":"1.1.4.2. Other Logger Implementations","content":"You can set your own profiler and PSR-3 logger implementation using the ExtendedPdo::setProfiler() method.use Aura\\Sql\\Profiler\\Profiler; $myLogger = new Psr3LoggerImplementation(); $pdo-&gt;setProfiler(new Profiler($myLogger)); "},{"id":"\/packages\/5.x\/Sql\/profiling-logging.html#1-1-4-3","title":"1.1.4.3. Profiler Log Messages","content":"Profiler log messages, by default, will match this format:{function} ({duration} seconds): {statement} {backtrace} You can customize the message format using the Profiler::setLogFormat() method, like so:$pdo-&gt;getProfiler()-&gt;setLogFormat(\"{duration}: {function} {statement}\") The context keys are: {function}: The method that was called on ExtendedPdo that created the profile entry. {start}: The microtime when the profile began. {finish}: The microtime when the profile ended. {duration}: The profile duration, in seconds. {statement}: The query string that was issued, if any. (Methods like connect() and rollBack() do not send query strings.) {values}: The values bound to the statement, if any. {backtrace}: An exception stack trace indicating where the query was issued from in the codebase. "},{"id":"\/packages\/5.x\/Sql\/profiling-logging.html#1-1-4-4","title":"1.1.4.4. Profiler Log Level","content":"By default, all messages are logged at the DEBUG level. You can change the logging level with the Profiler::setLogLevel() method:use Psr\\Log\\LogLevel; $pdo-&gt;getProfiler()-&gt;setLogLevel(LogLevel::INFO); Likewise, you can get the current log level with Profiler::getLogLevel()."},{"id":"\/packages\/5.x\/Sql\/connection-locator.html#1-1-5","title":"1.1.5. Connection Locator","content":"Frequently, high-traffic PHP applications use multiple database servers, generally one for writes, and one or more for reads. The ConnectionLocator allows you to define multiple ExtendedPdo objects for lazy-loaded read and write connections. It will create the connections only when they are when called. The creation logic is wrapped in a callable."},{"id":"\/packages\/5.x\/Sql\/connection-locator.html#1-1-5-1","title":"1.1.5.1. Runtime Configuration","content":"First, create the ConnectionLocator:use Aura\\Sql\\ExtendedPdo; use Aura\\Sql\\ConnectionLocator; $connections = new ConnectionLocator(); Now add a default connection; this will be used when a read or write connection is not defined. (This is also useful for setting up connection location in advance of actually having multiple database servers.)$connections-&gt;setDefault(function () { return new ExtendedPdo( 'mysql:host=default.db.localhost;dbname=database', 'username', 'password' ); }); Next, add as many named read and write connections as you like:\/\/ the write (master) server $connections-&gt;setWrite('master', function () { return new ExtendedPdo( 'mysql:host=master.db.localhost;dbname=database', 'username', 'password' ); }); \/\/ read (slave) #1 $connections-&gt;setRead('slave1', function () { return new ExtendedPdo( 'mysql:host=slave1.db.localhost;dbname=database', 'username', 'password' ); }); \/\/ read (slave) #2 $connections-&gt;setRead('slave2', function () { return new ExtendedPdo( 'mysql:host=slave2.db.localhost;dbname=database', 'username', 'password' ); }); \/\/ read (slave) #3 $connections-&gt;setRead('slave3', function () { return new ExtendedPdo( 'mysql:host=slave3.db.localhost;dbname=database', 'username', 'password' ); }); Finally, retrieve a connection from the locator when you need it. This will create the connection (if needed) and then return it. getDefault() will return the default connection. getRead() will return a named read connection; if no name is specified, it will return a random read connection. If no read connections are defined, it will return the default connection. getWrite() will return a named write connection; if no name is specified, it will return a random write connection. If no write connections are defined, it will return the default connection. $read = $connections-&gt;getRead(); $results = $read-&gt;fetchAll('SELECT * FROM table_name LIMIT 10'); "},{"id":"\/packages\/5.x\/Sql\/connection-locator.html#1-1-5-2","title":"1.1.5.2. Construction-Time Configuration","content":"The ConnectionLocator can be configured with all its connections at construction time; this is useful with dependency injection mechanisms.use Aura\\Sql\\ConnectionLocator; use Aura\\Sql\\ExtendedPdo; \/\/ default connection $default = function () { return new ExtendedPdo( 'mysql:host=default.db.localhost;dbname=database', 'username', 'password' ); }; \/\/ read connections $read = array( 'slave1' =&gt; function () { return new ExtendedPdo( 'mysql:host=slave1.db.localhost;dbname=database', 'username', 'password' ); }, 'slave2' =&gt; function () { return new ExtendedPdo( 'mysql:host=slave2.db.localhost;dbname=database', 'username', 'password' ); }, 'slave3' =&gt; function () { return new ExtendedPdo( 'mysql:host=slave3.db.localhost;dbname=database', 'username', 'password' ); }, ); \/\/ write connection $write = array( 'master' =&gt; function () { return new ExtendedPdo( 'mysql:host=master.db.localhost;dbname=database', 'username', 'password' ); }, ); \/\/ configure locator at construction time $connections = new ConnectionLocator($default, $read, $write); "},{"id":"\/packages\/5.x\/Sql\/upgrade.html#1-1-6","title":"1.1.6. 3.x Upgrade Notes","content":"The vast majority of changes and breaks from the 2.x version are \"under the hood,\" so to speak. The main functionality methods (query(), exec(), perform(), fetch*(), yield*(), etc.) are unchanged and work just the same as in 2.x.The remaining changes and breaks can be categorized as: the rebuilder and parsers; profiling and logging; instantiation; and miscellaneous. "},{"id":"\/packages\/5.x\/Sql\/upgrade.html#1-1-6-1","title":"1.1.6.1. Rebuilder and Parsers","content":"The 2.x Rebuilder has been redone entirely, and now provides separate parsers for the separate database drivers (mysql, pgsql, sqlite, and sqlsrv). This originated from #104, along with #107 and #111, all of which are now resolved. It took a great deal of time and effort to complete, with several approaches attempted."},{"id":"\/packages\/5.x\/Sql\/upgrade.html#1-1-6-1-1","title":"1.1.6.1.1. Array Placeholders","content":"Given this code ...$stm = \"SELECT * FROM test WHERE foo IN (:foo)\"; $sth = $pdo-&gt;perform($stm, [ 'foo' =&gt; ['bar', 'baz', 'dib']; ]); echo $sth-&gt;queryString; ... 2.x would quote and replace the array values directly into the query:SELECT * FROM test WHERE foo IN ('bar', 'baz', 'dib') Now, under 3.x, the placeholder is expanded to match the number of array keys, so that there are multiple placeholders:SELECT * FROM test WHERE foo IN (:foo_0, :foo_1, :foo_2) The array values passed to the query will also be bound individually. (If you profile the query, you will see :foo_0 (et al.) in the bindings.)"},{"id":"\/packages\/5.x\/Sql\/upgrade.html#1-1-6-1-2","title":"1.1.6.1.2. Sequential Placeholders","content":"Given this code ...$stm = 'SELECT * FROM test WHERE foo = ? AND bar = ?'; $sth = $pdo-&gt;perform($stm, [ 'foo_value', 'bar_value', ]); echo $sth-&gt;queryString; ... the 2.x rebuilder would leave ? placeholders alone:SELECT * FROM test WHERE foo = ? AND bar = ? Now, under 3.x, sequential placeholders are converted to named placeholders; the name corresponds to the sequential position:SELECT * FROM test WHERE foo = :__1 AND bar = :__2 The sequential values passed to the query will be bound to the named replacements.This helps to correct errors associated with binding sequential and named placeholders together, and in identifiying bound values in longer query strings."},{"id":"\/packages\/5.x\/Sql\/upgrade.html#1-1-6-1-3","title":"1.1.6.1.3. Repetition of Named Placeholders","content":"With 3.x, you can use the same placeholder multiple times. Given this code ...$stm = 'SELECT * FROM test WHERE foo = :val OR bar = :val'; $sth = $pdo-&gt;perform($stm, [ 'val' =&gt; 'whatever', ]); echo $sth-&gt;queryString; ... the 3.x parser modifies repeated placeholders by suffixing them each time they reappear, and binds the needed values automatically:SELECT * FROM test WHERE foo = :val OR bar = :val__1 "},{"id":"\/packages\/5.x\/Sql\/upgrade.html#1-1-6-1-4","title":"1.1.6.1.4. Custom Parsers","content":"You can inject your own parsers as well via ExtendedPdo::setParser(). See the src\/Parser\/ directory for examples of the existing parsers."},{"id":"\/packages\/5.x\/Sql\/upgrade.html#1-1-6-2","title":"1.1.6.2. Profiling and Logging","content":"The 2.x version used a custom profiler system, retaining profiles as array constructs and returning them as such. You needed to inject it yourself.use Aura\\Sql\\Profiler; $pdo-&gt;setProfiler(new Profiler()); \/\/ ... \/\/ query(), fetch(), beginTransaction()\/commit()\/rollback() etc. \/\/ ... \/\/ retrieve the profile information as a series of arrays $profiles = $pdo-&gt;getProfiler()-&gt;getProfiles(); Under 3.x, the profiler interface itself remains custom, but it is now backed with the PSR-3 logger interface. This means you can use any PSR-3 implementation to capture profiler information. This means that the profiler emits strings, rather than arrays, for the logger to capture.A profiler is now automatically set on the ExtendedPdo instance, and uses an in-memory logger by default for debugging purposes.\/\/ no need to set a profiler, but you do need to activate it: $pdo-&gt;getProfiler()-&gt;setActive(); \/\/ ... \/\/ query(), fetch(), beginTransaction()\/commit()\/rollback() etc. \/\/ ... \/\/ retrieve the profiler logs from the default MemoryLogger $messages = $pdo-&gt;getProfiler()-&gt;getLogger()-&gt;getMessages(); You can set the log message format and log level through the profiler, to capture just the information you want.You can set your own profiler and backing logger with the setProfiler() method.use Aura\\Sql\\Profiler\\Profiler; $myLogger = new Psr3LoggerImplementation(); $pdo-&gt;setProfiler(new Profiler($myLogger)); Finally, under 2.x, ExtendedPdo would profile every function call. Unless you examined very carefully, a call to prepare() followed by perform() looked like 2 executions of the same query. To make it easier to examine logs, the 3.x version does not profile every function call (e.g., prepare() and prepareWithValues() are no longer logged)."},{"id":"\/packages\/5.x\/Sql\/upgrade.html#1-1-6-3","title":"1.1.6.3. Instantiation","content":"Under 2.x you would do this:$pdo = new ExtendedPdo( 'pgsql:host=localhost;dbname=test', 'username', 'password', array(), \/\/ driver options as key-value pairs array() \/\/ attributes as key-value pairs ); It appears the last argument ended up being extraneous. The 3.x ExtendedPdo changes the last argument to this:$pdo = new ExtendedPdo( 'pgsql:host=localhost;dbname=test', 'username', 'password', [], \/\/ driver options as key-value pairs [] \/\/ queries to execute after connection ); This lets you execute queries at connection time; e.g., to make connection configuration changes that cannot be made as driver options\/attributes. For example:$pdo = new ExtendedPdo( 'pgsql:host=localhost;dbname=test', 'username', 'password', [ PDO::ATTR_CASE =&gt; PDO::CASE_NATURAL, ], [ \"SET NAMES 'utf8'\", ] ) "},{"id":"\/packages\/5.x\/Sql\/upgrade.html#1-1-6-4","title":"1.1.6.4. Miscellaneous","content":" PHP 5.6 is now the minimum required PHP version, though using the latest PHP version is recommended. 3.x (as with previous versions) starts PDO in ERRMODE_EXCEPTION when no error mode is explicitly specified.. However, the sqlsrv driver balks at this, so it is started in ERRMODE_WARNING instead. The ExtendedPdo::yield*() methods now use the yield keyword instead of returning Iterator instances. 1.x had a quoteName() method to quote identifier names. This was removed in 2.x, when that (and related functionality) were split off to SqlQuery. The functionality is added back in 3.x as quoteName() and quoteSingleName() as a convenience, though it is less robust than in SqlQuery. Some drivers cause PDO to make additional methods available (e.g., sqlite and pgsql). The 3.x ExtendedPdo now proxies all unknown method calls to the underlying PDO instance to make those methods available, if they exist. When dumping an ExtendedPdo object, the username and password are omitted. This should help keep unexpected output of stack traces from revealing credentials. "},{"id":"\/packages\/4.x\/Di\/getting-started.html#2-1-1-1","title":"2.1.1.1. Overview","content":"The Aura.Di package provides a serializable dependency injection container with the following features: constructor and setter injection inheritance of constructor parameter and setter method values from parent classes inheritance of setter method values from interfaces and traits lazy-loaded instances, services, includes\/requires, and values instance factories optional auto-resolution of typehinted constructor parameter values Fully describing the nature and benefits of dependency injection, while desirable, is beyond the scope of this document. For more information about \"inversion of control\" and \"dependency injection\" please consult http:\/\/martinfowler.com\/articles\/injection.html by Martin Fowler.Finally, please note that this package is intended for use as a dependency injection system, not as a service locator system. If you use it as a service locator, that's bad, and you should feel bad."},{"id":"\/packages\/4.x\/Di\/getting-started.html#2-1-1-1-1","title":"2.1.1.1.1. Intended Usage","content":"The intent behind Aura.Di is for it be used like so: Instantiate a container. Do all configuration for all classes and services. Lock the container so it cannot be modified further. Retrieve objects from the locked container. Note that calling get() or newInstance() will automatically lock the container, preventing further configuration changes. This is true even inside configuration code, so use the lazy*() methods instead while configuring the container."},{"id":"\/packages\/4.x\/Di\/getting-started.html#2-1-1-2","title":"2.1.1.2. Container Instantiation","content":"We instantiate a Container like so:use Aura\\Di\\ContainerBuilder; $builder = new ContainerBuilder(); $di = $builder-&gt;newInstance(); "},{"id":"\/packages\/4.x\/Di\/getting-started.html#2-1-1-3","title":"2.1.1.3. Creating Object Instances","content":"The most straightforward way is to create an object through the Container is via the newInstance() method:$object = $di-&gt;newInstance('Vendor\\Package\\ClassName');  N.b.: The Container locks itself once a new instance is produced; this ensures that the Container configuration cannot be modified once objects have been created. However, this is a relatively naive way to create objects with the Container. It is better to specify the various constructor parameters, setter methods, and so on, and let the Container inject those values for us only when the object is used as a dependency for something else."},{"id":"\/packages\/4.x\/Di\/constructor.html#2-1-2","title":"2.1.2. Constructor Injection","content":"When we use the Container to instantiate a new object, we often need to inject (i.e., set) constructor parameter values in various ways.We can define default values for constructor parameters using the $di-&gt;params array on the Container before locking it.Let's look at a class that takes some constructor parameters:namespace Vendor\\Package; class Example { protected $foo; protected $bar; public function __construct($foo, $bar) { $this-&gt;foo = $foo; $this-&gt;bar = $bar; } } If we were to try to create an object using $di-&gt;newInstance('Vendor\\Package\\Example'), the instantiation would fail. The $foo and $bar params are required, and the Container does not know what to use for that value.To remedy this, we tell the Container what values to use for each Vendor\\Package\\Example constructor parameter by name using the $di-&gt;params array:$di-&gt;params['Vendor\\Package\\Example']['foo'] = 'foo_value'; $di-&gt;params['Vendor\\Package\\Example']['bar'] = 'bar_value'; We can also specify by position:$di-&gt;params['Vendor\\Package\\Example'][0] = 'foo_value'; $di-&gt;params['Vendor\\Package\\Example'][1] = 'bar_value'; Once all the params are set, we create an object with $di-&gt;newInstance('Vendor\\Package\\Example'), the instantiation will work correctly. Each time we create an instance through the Container, it will apply the $di-&gt;params values for the matching class. N.b.: If you try to access $params after calling newInstance() (or after locking the Container using the lock() method) the Container will throw an exception. This is to prevent modifying the params after objects have been created. Thus, be sure to set up all params for all objects before creating an object. "},{"id":"\/packages\/4.x\/Di\/setter.html#2-1-3","title":"2.1.3. Setter Injection","content":"The Container supports setter injection in addition to constructor injection. (These can be combined as needed.)After the Container constructs a new instance of an object, we can specify that certain methods should be called with certain values immediately after instantiation by using the $di-&gt;setter array before locking it.Say we have class like the following:namespace Vendor\\Package; class Example { protected $foo; public function setFoo($foo) { $this-&gt;foo = $foo; } } We can specify that, by default, the setFoo() method should be called with a specific value after construction like so:$di-&gt;setters['Vendor\\Package\\Example']['setFoo'] = 'foo_value'; Note also that this works only with explicitly-defined setter methods. Setter methods that exist only via magic __call() will not be honored. Use mutations if you want to call magic methods. N.b.: If you try to access $setters after calling newInstance() (or after locking the Container using the lock() method) the Container will throw an exception. This is to prevent modifying the params after objects have been created. Thus, be sure to set up all params for all objects before creating an object. "},{"id":"\/packages\/4.x\/Di\/mutations.html#2-1-4","title":"2.1.4. Mutate object after instantion","content":"The Container supports objects to be mutated after it is constructed. This is especially useful when you have separate container configs that both need to define the object that will be constructed. Use cases could be adding routes to a router from multiple configs or adding commands to a console application object.After the Container constructs a new instance of an object, you can specify which other objects will mutate the original object before locking the container.Say we have classes like the following:namespace Vendor\\Package; use Aura\\Di\\Injection\\MutationInterface; class Example { protected $foo; public function setFoo($foo) { $this-&gt;foo = $foo; } } class ExampleMutation implements MutationInterface { public function __invoke(object $object): object { $object-&gt;setFoo('mutated'); return $object; } } We can specify that it should be mutated after construction. We can instantiate the mutation directly or lazy.$di-&gt;mutations['Vendor\\Package\\Example'][] = new ExampleMutation(); \/\/ direct $di-&gt;mutations['Vendor\\Package\\Example'][] = $di-&gt;lazyNew(ExampleMutation::class); \/\/ lazy Just like with any other class, you inject params to the mutation class.class ExampleMutation implements MutationInterface { private $argX, $argxY; public function __construct ($argX, $argY) { $this-&gt;argX = $argX; $this-&gt;argY = $argy; } public function __invoke(object $object): object { $object-&gt;setFoo($this-&gt;argX); $object-&gt;setBaz($this-&gt;argY); return $object; } } $di-&gt;params[ExampleMutation::class]['argX'] = $di-&gt;lazyGet('service'); $di-&gt;params[ExampleMutation::class]['argY'] = $di; $di-&gt;mutations['Vendor\\Package\\Example'][] = $di-&gt;lazyNew(ExampleMutation::class); When the mutation calls methods on an immutable object, you can return the new object.class RegisterRoutesMutation implements MutationInterface { public function __invoke(object $object): object { $object = $object-&gt;withRoute(new Vendor\\Router\\Route('\/contact', 'abc')); $object = $object-&gt;withRoute(new Vendor\\Router\\Route('\/hello_world', 'xyz')); return $object; } }  N.b.: If you try to access $di-&gt;mutations after calling newInstance() (or after locking the Container using the lock() method) the Container will throw an exception. This is to prevent modifying the params after objects have been created. Thus, be sure to set up all mutations for all objects before creating an object. "},{"id":"\/packages\/4.x\/Di\/inheritance.html#2-1-5","title":"2.1.5. Class, Interface, and Trait Inheritance","content":" N.b.: When specifying fully-qualified class names, do not include the leading namespace separator. Doing so may lead to unexpected behavior. In other words, always use ClassName and never use \\ClassName. "},{"id":"\/packages\/4.x\/Di\/inheritance.html#2-1-5-1","title":"2.1.5.1. Class Inheritance","content":"Each class instantiated through the Container \"inherits\" the constructor parameter and setter method values of its parents by default. This means we can specify a constructor parameter or setter method value on a parent class, and the child class will use it (that is, unless we set an overriding value on the child class).Let's say we have this parent class and this child class:class ExampleParent { protected $foo; protected $bar; public function __construct($foo) { $this-&gt;foo = $foo; } public function setBar($bar) { $this-&gt;bar = $bar; } } class ExampleChild extends ExampleParent { protected $baz; public function setBaz($baz) { $this-&gt;baz = $baz; } } If we define the constructor parameters and setter method values for the parent ...$di-&gt;params['ExampleParent']['foo'] = 'parent_foo'; $di-&gt;setters['ExampleParent']['setBar'] = 'parent_bar'; ... then when we call $di-&gt;newInstance('ExampleChild'), the child class will \"inherit\" those values as defaults.We can always override the \"inherited\" values by specifying them for the child class directly:$di-&gt;params['ExampleChild']['foo'] = 'child_foo'; $di-&gt;setters['ExampleChild']['setBaz'] = 'child_baz'; Classes extended from the child class will then inherit those new values. In this way, constructor parameter and setter method values are propagated down the inheritance hierarchy."},{"id":"\/packages\/4.x\/Di\/inheritance.html#2-1-5-2","title":"2.1.5.2. Interface And Trait Inheritance","content":"If a class exposes a setter method by implementing an interface or using a trait, we can specify the default value for that setter method on the interface or trait. That value will then be applied by default to every class that extends that implements that interface or uses that trait.For example, let's say we have this interface, trait, and class:interface ExampleBarInterface { public function setBar($bar); } trait ExampleFooTrait { public function setFoo($foo) { $this-&gt;foo = $foo; } } class Example implements ExampleBarInterface { use ExampleFooTrait; protected $foo; protected $bar; public function setBar($bar) { $this-&gt;bar = $bar; } } We can define the default setter method values on the trait and interface:$di-&gt;setters['ExampleFooTrait']['setFoo'] = 'foo_value'; $di-&gt;setters['ExampleBarInterface']['setBar'] = 'bar_value'; When we call $di-&gt;newInstance('Example'), those setter methods will be called by the Container with those values.Note that if we have class-specific $di-&gt;setter values, those will take precedence over the trait and interface setter values."},{"id":"\/packages\/4.x\/Di\/services.html#2-1-6","title":"2.1.6. Services","content":"A \"service\" is an object stored in the Container under a unique name. Any time you get() the named service, you always get back the same object instance.\/\/ define the Example class class Example { \/\/ ... } \/\/ set services as lazy; if you use newInstance() it will lock the container $di-&gt;set('service_name', $di-&gt;lazyNew('Example')); \/\/ get a service; the first get() will lock the container $service1 = $di-&gt;get('service_name'); $service2 = $di-&gt;get('service_name'); \/\/ the two service objects are the same var_dump($service1 === $service2); \/\/ true  N.b.: If you try to access $params or $setters, or to call set(), after calling get() or after locking the Container using the lock() method, the Container will throw an exception. This is to prevent modifying the params after objects have been created. Thus, be sure to set up all params for all objects before creating an object. "},{"id":"\/packages\/4.x\/Di\/lazy.html#2-1-7","title":"2.1.7. Lazy Injection","content":"Unlike the newInstance() and get() methods, calling one of the lazy*() methods on the Container will not lock the Container. Using lazy injection is the preferred and recommended way to define object values for $params and $setters, and to define services."},{"id":"\/packages\/4.x\/Di\/lazy.html#2-1-7-1","title":"2.1.7.1. Lazy Instances","content":"Thus far, we have used newInstance() to create objects through the Container. However, we usually don't want to create an object right at that moment when defining it. Instead, we almost always want to wait to create the object only at the time it is actually needed. Using lazyNew() instead allows us to defer object creation until it is needed as a dependency for another object.$di-&gt;params['Example']['foo'] = $di-&gt;lazyNew('AnotherExample'); Now the AnotherExample object will only be instantiated when the Example object is instantiated. It will use the default AnotherExample injection values.If we want to override the default $di-&gt;params values for a specific lazy instance, we can pass a $params array as the second argument to lazyNew() to merge with the default values. For example:$di-&gt;set('service_name', $di-&gt;lazyNew( 'AnotherExample', [ 'bar' =&gt; 'alternative_bar_value', ] )); This will leave the $foo parameter default in place, and override the $bar parameter value, for just that instance of the ExampleWithParams.Likewise, we can note instance-specific setter values to use in place of the defaults. We do so via the third argument to $di-&gt;lazyNew(). For example:$di-&gt;set('service_name', $di-&gt;lazyNew( 'AnotherExample', [], \/\/ no $params overrides [ 'setFoo' =&gt; 'alternative_foo_value', ] )); "},{"id":"\/packages\/4.x\/Di\/lazy.html#2-1-7-2-1","title":"2.1.7.2.1. Setting","content":"As with object instances, we generally want to create a service instance only at the moment we get it, not at the moment we set it. To lazy-load a service, set the service using the lazyNew() method:\/\/ set the service as a lazy-loaded new instance $di-&gt;set('service_name', $di-&gt;lazyNew('Example')); Now the service is created only when we we get() it, and not before. This lets us set as many services as we want, but only incur the overhead of creating the instances we actually use."},{"id":"\/packages\/4.x\/Di\/lazy.html#2-1-7-2-2","title":"2.1.7.2.2. Getting","content":"Sometimes a class will need a service as one of its parameters. By way of example, the following class needs a database connection:class ExampleNeedsService { protected $db; public function __construct($db) { $this-&gt;db = $db; } } To inject a shared service as a parameter value, use $di-&gt;lazyGet() so that the service object is not created until the ExampleNeedsService object is created:$di-&gt;params['ExampleNeedsService']['db'] = $di-&gt;lazyGet('db_service'); This keeps the service from being created until the very moment it is needed. If we never instantiate anything that needs the service, the service itself will never be instantiated."},{"id":"\/packages\/4.x\/Di\/lazy.html#2-1-7-2-3","title":"2.1.7.2.3. Getting-and-Calling","content":"Sometimes it will be useful to retrieve the result of a method call to a shared service. To do so, use the lazyGetCall() method, passing the name of the service first, followed by the method name, and optionally followed by any arguments to the method.$di-&gt;params['ExampleNeedsFactoriedObject']['object'] = $di-&gt;lazyGetCall('factory_service', 'newInstance'); "},{"id":"\/packages\/4.x\/Di\/lazy.html#2-1-7-3","title":"2.1.7.3. Lazy Values","content":"Sometimes we know that a parameter needs to be specified, but we don't know what it will be until later. Perhaps it is the result of looking up an API key from an environment variable. In these and other cases, we can tell a constructor parameter or setter method to use a \"lazy value\" and then specify that value elsewhere.For example, we can configure the Example constructor parameters to use lazy values like so:$di-&gt;params['Example']['foo'] = $di-&gt;lazyValue('fooval'); $di-&gt;params['Example']['bar'] = $di-&gt;lazyValue('barval'); We can then specify at some later time the values of fooval and barval using the $di-&gt;values array:$di-&gt;values['fooval'] = 'lazy value for foo'; $di-&gt;values['barval'] = 'lazy value for bar'; Lazy values can be lazy themselves:$di-&gt;values['fooval'] = $di-&gt;lazyGetCall('option_container', 'getFooOption'); "},{"id":"\/packages\/4.x\/Di\/lazy.html#2-1-7-4","title":"2.1.7.4. Lazy Include and Require","content":"Occasionally we will need to include a file that returns a value, such as data file that returns a PHP array:\/\/ \/path\/to\/data.php return [ 'foo' =&gt; 'bar', 'baz' =&gt; 'dib', 'zim' =&gt; 'gir' ]; We could set a constructor parameter or setter method value to include \"\/path\/to\/data.php\", but that would cause the file to be read filesystem at that moment, instead of at instantiation time. To lazy-load a file as a value, call $di-&gt;lazyInclude() or $di-&gt;lazyRequire() (depending on your preference for warning levels).$di-&gt;params['Example1']['data'] = $di-&gt;lazyInclude('\/path\/to\/data.php'); $di-&gt;params['Example2']['data'] = $di-&gt;lazyRequire('\/path\/to\/data.php'); "},{"id":"\/packages\/4.x\/Di\/lazy.html#2-1-7-5","title":"2.1.7.5. Lazy Array","content":"Sometimes you'll be working with code that expects an array of objects. If you want the objects within the array to be lazy, you can use the $di-&gt;lazyArray() method. This will iterate through your array and resolve any lazy objects before returning the array.$di-&gt;setters['Example']['addFoos'] = $di-&gt;lazyArray([ $di-&gt;lazyNew('FirstFoo'), $di-&gt;lazyNew('SecondFoo'), ]); \/\/ Nesting Lazy Arrays $di-&gt;setters['Example']['addBars'] = $di-&gt;lazyArray([ $di-&gt;lazyArray(['name1', $di-&gt;lazyNew('FirstBar'), 'en']), $di-&gt;lazyArray(['name2', $di-&gt;lazyNew('SecondFoo'), 'es']), ]); LazyArray extends ArrayObject so if you need to modify the LazyArray after you've assigned it you can use any of the ArrayObject methods.$di-&gt;setters['Example']['addFoos'] = $di-&gt;lazyArray([]); \/\/ Append to array $di-&gt;setters['Example']['addFoos']-&gt;append($di-&gt;lazyNew('SecondFoo')); \/\/ Get a copy of the internal array $copy = $di-&gt;setters['Example']['addFoos']-&gt;getArrayCopy(); \/\/ Manipulate the array array_unshift($copy, $di-&gt;lazyNew('FirstFoo')); \/\/ Reassign with new array $di-&gt;setters['Example']['addFoos'] = $di-&gt;lazyArray($copy); "},{"id":"\/packages\/4.x\/Di\/lazy.html#2-1-7-6","title":"2.1.7.6. Lazy Callable","content":"Sometimes you'll be working with code that deals with callables. This code may expect to invoke the callable once, or many times. If you wanted to use a service in this situation, you can use the lazyCallable method. This will produce a callable that will lazily resolve other lazies, and ensure that all calls to the service are made appropriately.$di-&gt;params['Example']['foo'] = $di-&gt;lazyCallable($di-&gt;lazyGet('service_name')); $di-&gt;params['Example']['bar'] = $di-&gt;lazyCallable([$di-&gt;lazyNew('ServiceClass'), 'methodName']); "},{"id":"\/packages\/4.x\/Di\/lazy.html#2-1-7-7","title":"2.1.7.7. Generic Lazy Calls","content":"It may be that we have a complex bit of logic we need to execute for a value. If none of the existing $di-&gt;lazy*() methods meet our needs, we can wrap an anonymous function or other callable in a lazy() call, and the callable's return will be used as the value.$di-&gt;params['Example']['foo'] = $di-&gt;lazy(function () { \/\/ complex calculations, and then: return $result; }); Note that this will work with any PHP callable, such as a static method:\/\/ ServiceClass::staticMethod() $di-&gt;set('service', $di-&gt;lazy(['ServiceClass', 'staticMethod'])); You can pass arguments to the callable like so:\/\/ ServiceClass::staticMethod($arg1, $arg2, $arg3) $di-&gt;set('service', $di-&gt;lazy(['ServiceClass', 'staticMethod'], $arg1, $arg2, $arg3 )); Lazies in the callable array, and in the arguments, will be resolved automatically.\/\/ $serviceClass-&gt;methodName($configArray) $di-&gt;set('service', $di-&gt;lazy([$di-&gt;lazyNew('ServiceClass'), 'methodName'], $di-&gt;lazyInclude('\/path\/to\/config.array.php') )); You can also pass in lazies directly as the callable.$di-&gt;set('service', $di-&gt;lazy($di-&gt;lazyNew('InvokableServiceClass'), $arg1, $arg2 )); Beware of relying on generic Lazy calls too much; if we do, it probably means we need to separate our configuration concerns better than we are currently doing."},{"id":"\/packages\/4.x\/Di\/factories.html#2-1-8","title":"2.1.8. Instance Factories","content":"Occasionally, a class will need to receive not just an instance, but a factory that is capable of creating a new instance over and over. For example, say we have a class like the following:class ExampleNeedsFactory { protected $struct_factory; public function __construct($struct_factory) { $this-&gt;struct_factory = $struct_factory; } public function getStruct(array $data) { $struct = $this-&gt;struct_factory-&gt;__invoke($data); return $struct; } } class ExampleStruct { public function __construct(array $data) { foreach ($data as $key =&gt; $val) { $this-&gt;$key = $val; } } } We can inject a Factory that creates only ExampleStruct objects using $di-&gt;newFactory().$di-&gt;params['ExampleNeedsFactory']['struct_factory'] = $di-&gt;newFactory('ExampleStruct'); Note that the arguments passed to the factory __invoke() method will be passed to the underlying instance constructor sequentially, not by name. This means the __invoke() method works more like the native new keyword, and not like $di-&gt;lazyNew(). These arguments override any $di-&gt;params values that have been set for the class being factoried; without the overrides, all existing $di-&gt;params values for that class will be honored. (Values from $di-&gt;setter for the class will also be honored, but cannot be overridden.)Do not feel limited by the Factory implementation. We can create and inject factory objects of our own if we like. The Factory returned by the $di-&gt;newFactory() method is an occasional convenience, nothing more."},{"id":"\/packages\/4.x\/Di\/factories.html#2-1-8-1","title":"2.1.8.1. Broader Instantiation","content":"Sometimes you may want to more broadly leverage a configured container's ability to instantiate objects in your classes, for example in some kind of service locator. The ResolutionHelper provides a callable object which takes a \"specification\" as a parameter and will retrieve a service if the container has one appropriate to the specification or instantiate a new instance of the class if there is no matching service name. If an array is passed as the specification, the array is returned with the first value \"resolved\". This array functionality allows for a callable to be returned referencing an method on an instance. $helper = $di-&gt;newResolutionHelper(); $foo = $helper(\\My\\Foo::class); \/\/ will return service named \"My\\Foo\" if one is named as such \/\/ or else a new instance of \"My\\Foo\" $fooBar = $helper([\\My\\Foo::class, 'bar']); \/\/ will return the equivalent of [$foo, 'bar'] Using the ResolutionHelper, you can write consuming code that type hints a callable, rather than the container itself."},{"id":"\/packages\/4.x\/Di\/config.html#2-1-9","title":"2.1.9. Container Builder and Config Classes","content":"The ContainerBuilder also builds fully-configured Container objects using ContainerConfig classes. It works using a two-stage configuration system.The two stages are \"define\" and \"modify\". In the \"define\" stage, the ContainerConfig object defines constructor parameter values, setter method values, services, and so on. The ContainerBuilder then locks the Container so that these definitions cannot be changed, and begins the \"modify\" stage. In the \"modify\" stage, we may get() services from the Container and modify them programmatically if needed.To build a fully-configured Container using the ContainerBuilder, we do something like the following:use Aura\\Di\\ContainerBuilder; $container_builder = new ContainerBuilder(); \/\/ use the builder to create and configure a container \/\/ using an array of ContainerConfig classes $di = $container_builder-&gt;newConfiguredInstance([ 'Aura\\Cli\\_Config\\Common', 'Aura\\Router\\_Config\\Common', 'Aura\\Web\\_Config\\Common', ]); Note: As with the newInstance method of the ContainerBuilder, you will have to pass $container_builder::AUTO_RESOLVE to newConfiguredInstance (as the second parameter) if you want to enable auto-resolution.A configuration class looks like the following:namespace Vendor\\Package; use Aura\\Di\\Container; use Aura\\Di\\ContainerConfig; class Config extends ContainerConfig { public function define(Container $di) { $di-&gt;set('log_service', $di-&gt;lazyNew('Logger')); $di-&gt;params['Logger']['dir'] = '\/path\/to\/logs'; } public function modify(Container $di) { $log = $di-&gt;get('log_service'); $log-&gt;debug('Finished config.'); } } Here are some example ContainerConfig classes from earlier Aura packages: Aura.Cli Aura.Html Aura.Router Aura.View Alternatively, if you already have a ContainerConfig object created, you can pass it directly to the ContainerBuilder instead of a string class name:$routerConfig = new Aura\\Router\\_Config\\Common(); \/\/ use the builder to create and configure a container \/\/ using an array of ContainerConfig classes $di = $container_builder-&gt;newConfiguredInstance([ 'Aura\\Cli\\_Config\\Common', $routerConfig, 'Aura\\Web\\_Config\\Common', ]); If you have a package which combines a number of disparate components that each provide a ContainerConfig you could bundle them together using the ConfigCollection class. This class takes an array of ContainerConfigs or ContainerConfig class names and implements ContainerConfigInterface itself. namespace My\\App; use Aura\\Di\\ConfigCollection; use My\\Domain; use My\\WebInterface; use My\\DataSource; class Config extends ConfigCollection { public function __construct() { parent::__construct( [ Domain\\Config::class, WebInterface\\Config::class, DataSource\\Config::class, ] ); } } You can then use the Collection and it will instantiate (if necessary) and call the define and modify methods of each of the other ContainerConfigs.$di = $container_builder-&gt;newConfiguredInstance([\\My\\App\\Config::class]) "},{"id":"\/packages\/4.x\/Di\/auto.html#2-1-10","title":"2.1.10. Auto-Resolution Of Constructor Parameters","content":"Some developers prefer to let the Container resolve dependencies on its own, without having to specify anything in a configuration file. Note that there can be unusual debugging problems inherent in tracking down the default injections, so auto-resolution may or may not be your preference.To use auto-resolution in a Container, build the Container with $container = $builder-&gt;newInstance($builder::AUTO_RESOLVE). If you're using newConfiguredInstance to configure your dependency injector and want this functionality, you will need to pass $builder::AUTO_RESOLVE as the second parameter.Note that auto-resolution only works for class\/interface typehints. It does not work for array typehints.Note also that auto-resolution does not apply to setter methods. This is because the Container does not know which methods are setters and which are \"normal use\" methods. Since you have to specify $di-&gt;setters anyway, the Container has no chance to attempt auto-resolution."},{"id":"\/packages\/4.x\/Di\/auto.html#2-1-10-1","title":"2.1.10.1. Auto-Resolving From Concrete Typehints","content":"If the parameter is typehinted to a class but there is no $di-&gt;params value for that parameter, and also no default value, the Container will automatically fill in a lazyNew() call to the typehinted class.For example, look at the following class; it has a parameter typehinted to a class, and no default value:class Example { public function __construct(Foo $foo) { \/\/ ... } } The Container will auto-resolve the constructor param as if you had explicitly specified the following:$di-&gt;params['Example']['foo'] = $di-&gt;lazyNew('Foo'); "},{"id":"\/packages\/4.x\/Di\/auto.html#2-1-10-2","title":"2.1.10.2. Auto-Resolving From Abstract and Interface Typehints","content":"Obviously, you can't instantiate an interface or an abstract class. So, if a constructor parameter is typehinted like this ...class Example { public function __construct(FooInterface $foo) { \/\/ ... } } ... the Container cannot auto-resolve with lazyNew('FooInterface').When it comes to interfaces and abstracts, then, you have to tell the Container how to resolve them using $di-&gt;types:$di-&gt;types['FooInterface'] = $di-&gt;lazyNew('Foo'); The Container will now resolve all FooInterface typehints to a lazy-new instance of Foo."},{"id":"\/packages\/4.x\/Di\/auto.html#2-1-10-3","title":"2.1.10.3. Auto-Resolving to Services","content":"Sometimes you don't want a new instance of the typehinted param. Often, you will want to use a service instead. Auto-resolving a typehint to a service is easy, using the $di-&gt;types technique from above. For example, given this class ...class Example { public function __construct(DbInterface $db) { \/\/ ... } } ... we can auto-resolve all DbInterface typehints to a service in the Container:$di-&gt;types['DbInterface'] = $di-&gt;lazyGet('database_connection'); This works for concrete classes as well. Given this class:class Example { public function __construct(Db $db) { \/\/ ... } } ... we can auto-resolve all concrete PDO typehints to a service in the Container:$di-&gt;types['Db'] = $di-&gt;lazyGet('database_connection'); "},{"id":"\/packages\/4.x\/Di\/auto.html#2-1-10-4","title":"2.1.10.4. Overriding Auto-Resolution","content":"You may wish to explicitly specify a constructor parameter for a class, instead of letting the Container use auto-resolution. You can do so through the old familiar $di-&gt;params technique.\/\/ by default, resolve to this service $di-&gt;types['DbInterface'] = $di-&gt;lazyGet('database_connection'); \/\/ but in this particular class, and its children, \/\/ resolve to this other service $di-&gt;params['OtherClass']['db'] = $di-&gt;lazyGet('other_connection'); "},{"id":"\/packages\/4.x\/Di\/serializing.html#2-1-11","title":"2.1.11. Serializing the Container","content":"The Container supports setter serialization. It is only possible to serialize containers that do not contain any closures.Say we the following:$di-&gt;params[VendorClass::class] = [ 'param' =&gt; $di-&gt;lazyNew(VendorParamClass::class), ]; $di-&gt;set('fake', $di-&gt;lazyNew(VendorClass::class)); We can then serialize and unserialize the container:$serialized = serialize($di); $di = unserialize($serialized); $fakeService = $di-&gt;get('fake'); Serializing won't work with closures. The following example throws an exception.$di-&gt;params[VendorClass::class] = [ 'param' =&gt; $di-&gt;lazy( function () { return new VendorParamClass(); } ), ]; $di-&gt;set('fake', $di-&gt;lazyNew(VendorClass::class)); serialize($di); \/\/ throws exceptions because of the closure in the params of VendorClass::class. "},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12","title":"2.1.12. Migrating","content":"This document helps to upgrade users moving from 3.x to 4.x. Below you can also (still) find the upgrade guide for people upgrading from 2.x to 3.x."},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-1","title":"2.1.12.1. Migrating from 3.x to 4.x","content":"Aura.Di 4.x is largely similar to 3.x, but there are some backwards-compatibility breaks, as well as some new features."},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-1-1","title":"2.1.12.1.1. Dropped PHP 7.1 and lower, no HHVM","content":"Make sure you use the correct PHP version. This library uses the object type-hint and therefore requires PHP 7.2+. The support for HHVM is dropped."},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-1-2","title":"2.1.12.1.2. Type-hinting","content":"All classes are now using type hinting for method arguments and return types, including the void return type. This means if you have extended or implemented one of the library classes in your code, you will have to update the signatures of your extended\/implemented methods to match the new signatures.For most users this involves only updating classes implementing the ContainerConfigInterface."},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-1-3","title":"2.1.12.1.3. InjectionFactory::newInstance()","content":"Aura\\Di\\Injection\\InjectionFactory::newInstance() now requires an instance of Aura\\Di\\Resolver\\Blueprint to be passed as the parameter, instead of the former classname, parameter array and setter array."},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-1-4","title":"2.1.12.1.4. Container Interop","content":"From version 4.x the library will implement the official container standard interface (PSR 11) instead of the container-interop interface."},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-1-5","title":"2.1.12.1.5. Dropped features","content":"LazyRequire and LazyInclude could be constructed with a lazy object instead of a filename. This was probably only used for testing purposes (it was not included in any docs) but is included here in case someone is actually using this."},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-2","title":"2.1.12.2. Migrating from 2.x to 3.x","content":"Aura.Di 3.x is largely similar to 2.x, but there are some backwards-compatibility breaks, as well as some new features."},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-2-1-1","title":"2.1.12.2.1.1. Instantiation","content":"The way the container is instantiated has been changed from this ...use Aura\\Di\\Container; use Aura\\Di\\Factory; use Aura\\Di\\ContainerBuilder; $di = new Container(new Factory); \/\/ or $container_builder = new ContainerBuilder(); $di = $container_builder-&gt;newInstance( array(), array(), $auto_resolve = false ); ... to this:use Aura\\Di\\ContainerBuilder; $container_builder = new ContainerBuilder(); \/\/ use the builder to create and configure a container \/\/ using an array of ContainerConfig classes $di = $container_builder-&gt;newConfiguredInstance([ 'Aura\\Cli\\_Config\\Common', 'Aura\\Router\\_Config\\Common', 'Aura\\Web\\_Config\\Common', ]); "},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-2-1-2","title":"2.1.12.2.1.2. \nsetter vs setters\n","content":"Use of $di-&gt;setter in 2.x is now $di-&gt;setters in 3.x. Please note there is an additional s in the end."},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-2-1-3","title":"2.1.12.2.1.3. Automatic Locking","content":"The container now calls lock() automatically when you call get() or newInstance(), so make sure everything is lazy-loaded, or else you will run into something like cannot modify container when locked."},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-2-1-4","title":"2.1.12.2.1.4. Config vs ContainerConfig","content":"Aura\\Di\\Config in 2.x is now Aura\\Di\\ContainerConfig in 3.x."},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-2-2-1","title":"2.1.12.2.2.1. lazyGetCall()","content":"Example taken from Radar:$di-&gt;params['Radar\\Adr\\Handler\\RoutingHandler']['matcher'] = $di-&gt;lazyGetCall('radar\/adr:router', 'getMatcher'); Here the value assigned to matcher is taken from the RouterContainer getMatcher() method."},{"id":"\/packages\/4.x\/Di\/migrating.html#2-1-12-2-2-2","title":"2.1.12.2.2.2. Instance Factories","content":"An instance factory creates multiple instances of the same class; refer the docs for more information."},{"id":"\/packages\/4.x\/Sql\/getting-started.html#2-2-1-1","title":"2.2.1.1. Instantiation","content":"You can instantiate ExtendedPdo so that it uses lazy connection, or you can use DecoratedPdo to decorate an existing PDO instance."},{"id":"\/packages\/4.x\/Sql\/getting-started.html#2-2-1-1-1","title":"2.2.1.1.1. Lazy Connection Instance","content":"Instantiation is the same as with the native PDO class: pass a data source name, username, password, and driver options. There is one additional parameter that allows you to pass attributes to be set after the connection is made.use Aura\\Sql\\ExtendedPdo; $pdo = new ExtendedPdo( 'mysql:host=localhost;dbname=test', 'username', 'password', [], \/\/ driver attributes\/options as key-value pairs [] \/\/ queries to execute after connection ); Whereas the native PDO connects on instantiation, ExtendedPdo does not connect immediately. Instead, it connects only when you call a method that actually needs the connection to the database; e.g., on query().If you want to force a connection, call the connect() method.\/\/ does not connect to the database $pdo = new ExtendedPdo( 'mysql:host=localhost;dbname=test', 'username', 'password' ); \/\/ automatically connects $pdo-&gt;exec('SELECT * FROM test'); \/\/ explicitly forces a connection $pdo-&gt;connect(); If you want to explicitly force a disconnect, call the disconnect() method.\/\/ explicitly forces disconnection $pdo-&gt;disconnect(); Doing so will close the connection by unsetting the internal PDO instance. However, calling an ExtendedPdo method that implicitly establishes a connection, such as query() or one of the fetch*() methods, will automatically re-connect to the database."},{"id":"\/packages\/4.x\/Sql\/getting-started.html#2-2-1-1-2","title":"2.2.1.1.2. Decorator Instance","content":"The DecoratedPdo class can be used to decorate an existing PDO connection with the ExtendedPdo methods. To do so, instantiate DecoratedPdo by passing an existing PDO connection:use Aura\\Sql\\DecoratedPdo; $pdo = new PDO(...); $decoratedPdo = new DecoratedPdo($pdo); The decorated PDO instance now provides all the ExtendedPdo functionality (aside from lazy connection, which is not possible since the PDO instance by definition has already connected).Decoration of this kind can be useful when you have access to an existing PDO connection managed elsewhere in your application. N.b.: The disconnect() method will not work on decorated PDO connections, since DecoratedPdo did not create the connection itself. You will need to manage the decorated PDO instance yourself in that case. "},{"id":"\/packages\/4.x\/Sql\/getting-started.html#2-2-1-2","title":"2.2.1.2. Array Quoting","content":"The native PDO quote() method will not quote arrays. This makes it difficult to bind an array to something like an IN (...) condition in SQL. However, ExtendedPdo recognizes arrays and converts them into comma- separated quoted strings.\/\/ the array to be quoted $array = array('foo', 'bar', 'baz'); \/\/ the native PDO way: \/\/ \"Warning: PDO::quote() expects parameter 1 to be string, array given\" $pdo = new PDO(...); $cond = 'IN (' . $pdo-&gt;quote($array) . ')'; \/\/ the ExtendedPdo way: \/\/ \"IN ('foo', 'bar', 'baz')\" $pdo = new ExtendedPdo(...); $cond = 'IN (' . $pdo-&gt;quote($array) . ')'; "},{"id":"\/packages\/4.x\/Sql\/getting-started.html#2-2-1-3","title":"2.2.1.3. The perform() Method","content":"The ExtendedPdo::perform() method will prepare a query with bound values in a single step. Also, because the native PDO does not deal with bound array values, perform() modifies the query string to expand the array-bound placeholder into multiple placeholders.\/\/ the array to be quoted $array = array('foo', 'bar', 'baz'); \/\/ the statement to prepare $stm = 'SELECT * FROM test WHERE foo IN (:foo)' \/\/ the native PDO way does not work (PHP Notice: Array to string conversion) $pdo = new ExtendedPdo(...); $sth = $pdo-&gt;prepare($stm); $sth-&gt;bindValue('foo', $array); \/\/ the ExtendedPdo way allows a single call to prepare and execute the query. \/\/ it quotes the array and expands the array placeholder directly in the \/\/ query string. $pdo = new ExtendedPdo(...); $bind_values = array('foo' =&gt; $array); $sth = $pdo-&gt;perform($stm, $bind_values); echo $sth-&gt;queryString; \/\/ the query string has been modified by ExtendedPdo to become \/\/ \"SELECT * FROM test WHERE foo IN (:foo_1, :foo_2, :foo_3)\" Finally, note that array quoting works only via the perform() method, not on returned PDOStatement instances."},{"id":"\/packages\/4.x\/Sql\/fetch.html#2-2-2","title":"2.2.2. The fetch*() Methods","content":"ExtendedPdo comes with fetch*() methods to help reduce boilerplate code. Instead of issuing prepare(), a series of bindValue() calls, execute(), and then fetch*() on a PDOStatement, you can bind values and fetch results in one call on ExtendedPdo directly. (The fetch*() methods use perform() internally, so quoting-and-replacement of array placeholders is supported.)$stm = 'SELECT * FROM test WHERE foo = :foo AND bar = :bar'; $bind = array('foo' =&gt; 'baz', 'bar' =&gt; 'dib'); \/\/ the native PDO way to \"fetch all\" where the result is a sequential array \/\/ of rows, and the row arrays are keyed on the column names $pdo = new PDO(...); $sth = $pdo-&gt;prepare($stm); $sth-&gt;execute($bind); $result = $sth-&gt;fetchAll(PDO::FETCH_ASSOC); \/\/ the ExtendedPdo way to do the same kind of \"fetch all\" $pdo = new ExtendedPdo(...); $result = $pdo-&gt;fetchAll($stm, $bind); \/\/ fetchAssoc() returns an associative array of all rows where the key is the \/\/ first column, and the row arrays are keyed on the column names $result = $pdo-&gt;fetchAssoc($stm, $bind); \/\/ fetchGroup() is like fetchAssoc() except that the values aren't wrapped in \/\/ arrays. Instead, single column values are returned as a single dimensional \/\/ array and multiple columns are returned as an array of arrays \/\/ Set style to PDO::FETCH_NAMED when values are an array \/\/ (i.e. there are more than two columns in the select) $result = $pdo-&gt;fetchGroup($stm, $bind, $style = PDO::FETCH_COLUMN) \/\/ fetchObject() returns the first row as an object of your choosing; the \/\/ columns are mapped to object properties. an optional 4th parameter array \/\/ provides constructor arguments when instantiating the object. $result = $pdo-&gt;fetchObject($stm, $bind, 'ClassName', array('ctor_arg_1')); \/\/ fetchObjects() returns an array of objects of your choosing; the \/\/ columns are mapped to object properties. an optional 4th parameter array \/\/ provides constructor arguments when instantiating the object. $result = $pdo-&gt;fetchObjects($stm, $bind, 'ClassName', array('ctor_arg_1')); \/\/ fetchOne() returns the first row as an associative array where the keys \/\/ are the column names $result = $pdo-&gt;fetchOne($stm, $bind); \/\/ fetchPairs() returns an associative array where each key is the first \/\/ column and each value is the second column $result = $pdo-&gt;fetchPairs($stm, $bind); \/\/ fetchValue() returns the value of the first row in the first column $result = $pdo-&gt;fetchValue($stm, $bind); \/\/ fetchAffected() returns the number of affected rows $stm = \"UPDATE test SET incr = incr + 1 WHERE foo = :foo AND bar = :bar\"; $row_count = $pdo-&gt;fetchAffected($stm, $bind); "},{"id":"\/packages\/4.x\/Sql\/yield.html#2-2-3","title":"2.2.3. The yield*() Methods","content":"ExtendedPdo comes with yield*() methods to help reduce memory usage. Whereas many fetch*() methods collect all the query result rows before returning them all at once, the equivalent yield*() methods generate one result row at a time. For example:$stm = 'SELECT * FROM test WHERE foo = :foo AND bar = :bar'; $bind = array('foo' =&gt; 'baz', 'bar' =&gt; 'dib'); \/\/ like fetchAll(), each row is an associative array foreach ($pdo-&gt;yieldAll($stm, $bind) as $row) { \/\/ ... } \/\/ like fetchAssoc(), each key is the first column, \/\/ and the row is an associative array foreach ($pdo-&gt;yieldAssoc($stm, $bind) as $key =&gt; $row) { \/\/ ... } \/\/ like fetchCol(), each result is a value from the first column foreach ($pdo-&gt;yieldCol($stm, $bind) as $val) { \/\/ ... } \/\/ like fetchObjects(), each result is an object; pass an optional \/\/ class name and optional array of constructor arguments. $class = 'ClassName'; $args = ['arg0', 'arg1', 'arg2']; foreach ($pdo-&gt;yieldObjects($stm, $bind, $class, $args) as $object) { \/\/ ... } \/\/ like fetchPairs(), each result is a key-value pair from the \/\/ first and second columns foreach ($pdo-&gt;yieldPairs($stm, $bind) as $key =&gt; $val) { \/\/ ... } "},{"id":"\/packages\/4.x\/Sql\/profiling-logging.html#2-2-4","title":"2.2.4. Profiling and Logging","content":"It is often useful to see what queries have been executed, where they were issued from in the codebase, and how long they took to complete. As such, ExtendedPdo comes with a profiler that logs to any PSR-3 implementation. The profiler defaults to a naive memory-based logger for debugging purposes."},{"id":"\/packages\/4.x\/Sql\/profiling-logging.html#2-2-4-1","title":"2.2.4.1. Using The Profiler","content":"You can activate and deactivate the profiler using the Profiler::setActive() method. (Messages are not logged when the profiler is not active.)You can then examine the log messages using the underlying log system; in the below example, we use the default MemoryLogger implementation.&lt;?php \/\/ activate the profiler $pdo-&gt;getProfiler()-&gt;setActive(true); \/\/ ... \/\/ query(), fetch(), beginTransaction()\/commit()\/rollback() etc. \/\/ ... \/\/ now retrieve the array messages from the default memory logger: $messages = $pdo-&gt;getProfiler()-&gt;getLogger()-&gt;getMessages(); print_r($messages); "},{"id":"\/packages\/4.x\/Sql\/profiling-logging.html#2-2-4-2","title":"2.2.4.2. Other Logger Implementations","content":"You can set your own profiler and PSR-3 logger implementation using the ExtendedPdo::setProfiler() method.use Aura\\Sql\\Profiler\\Profiler; $myLogger = new Psr3LoggerImplementation(); $pdo-&gt;setProfiler(new Profiler($myLogger)); "},{"id":"\/packages\/4.x\/Sql\/profiling-logging.html#2-2-4-3","title":"2.2.4.3. Profiler Log Messages","content":"Profiler log messages, by default, will match this format:{function} ({duration} seconds): {statement} {backtrace} You can customize the message format using the Profiler::setLogFormat() method, like so:$pdo-&gt;getProfiler()-&gt;setLogFormat(\"{duration}: {function} {statement}\") The context keys are: {function}: The method that was called on ExtendedPdo that created the profile entry. {start}: The microtime when the profile began. {finish}: The microtime when the profile ended. {duration}: The profile duration, in seconds. {statement}: The query string that was issued, if any. (Methods like connect() and rollBack() do not send query strings.) {values}: The values bound to the statement, if any. {backtrace}: An exception stack trace indicating where the query was issued from in the codebase. "},{"id":"\/packages\/4.x\/Sql\/profiling-logging.html#2-2-4-4","title":"2.2.4.4. Profiler Log Level","content":"By default, all messages are logged at the DEBUG level. You can change the logging level with the Profiler::setLogLevel() method:use Psr\\Log\\LogLevel; $pdo-&gt;getProfiler()-&gt;setLogLevel(LogLevel::INFO); Likewise, you can get the current log level with Profiler::getLogLevel()."},{"id":"\/packages\/4.x\/Sql\/connection-locator.html#2-2-5","title":"2.2.5. Connection Locator","content":"Frequently, high-traffic PHP applications use multiple database servers, generally one for writes, and one or more for reads. The ConnectionLocator allows you to define multiple ExtendedPdo objects for lazy-loaded read and write connections. It will create the connections only when they are when called. The creation logic is wrapped in a callable."},{"id":"\/packages\/4.x\/Sql\/connection-locator.html#2-2-5-1","title":"2.2.5.1. Runtime Configuration","content":"First, create the ConnectionLocator:use Aura\\Sql\\ExtendedPdo; use Aura\\Sql\\ConnectionLocator; $connections = new ConnectionLocator(); Now add a default connection; this will be used when a read or write connection is not defined. (This is also useful for setting up connection location in advance of actually having multiple database servers.)$connections-&gt;setDefault(function () { return new ExtendedPdo( 'mysql:host=default.db.localhost;dbname=database', 'username', 'password' ); }); Next, add as many named read and write connections as you like:\/\/ the write (master) server $connections-&gt;setWrite('master', function () { return new ExtendedPdo( 'mysql:host=master.db.localhost;dbname=database', 'username', 'password' ); }); \/\/ read (slave) #1 $connections-&gt;setRead('slave1', function () { return new ExtendedPdo( 'mysql:host=slave1.db.localhost;dbname=database', 'username', 'password' ); }); \/\/ read (slave) #2 $connections-&gt;setRead('slave2', function () { return new ExtendedPdo( 'mysql:host=slave2.db.localhost;dbname=database', 'username', 'password' ); }); \/\/ read (slave) #3 $connections-&gt;setRead('slave3', function () { return new ExtendedPdo( 'mysql:host=slave3.db.localhost;dbname=database', 'username', 'password' ); }); Finally, retrieve a connection from the locator when you need it. This will create the connection (if needed) and then return it. getDefault() will return the default connection. getRead() will return a named read connection; if no name is specified, it will return a random read connection. If no read connections are defined, it will return the default connection. getWrite() will return a named write connection; if no name is specified, it will return a random write connection. If no write connections are defined, it will return the default connection. $read = $connections-&gt;getRead(); $results = $read-&gt;fetchAll('SELECT * FROM table_name LIMIT 10'); "},{"id":"\/packages\/4.x\/Sql\/connection-locator.html#2-2-5-2","title":"2.2.5.2. Construction-Time Configuration","content":"The ConnectionLocator can be configured with all its connections at construction time; this is useful with dependency injection mechanisms.use Aura\\Sql\\ConnectionLocator; use Aura\\Sql\\ExtendedPdo; \/\/ default connection $default = function () { return new ExtendedPdo( 'mysql:host=default.db.localhost;dbname=database', 'username', 'password' ); }; \/\/ read connections $read = array( 'slave1' =&gt; function () { return new ExtendedPdo( 'mysql:host=slave1.db.localhost;dbname=database', 'username', 'password' ); }, 'slave2' =&gt; function () { return new ExtendedPdo( 'mysql:host=slave2.db.localhost;dbname=database', 'username', 'password' ); }, 'slave3' =&gt; function () { return new ExtendedPdo( 'mysql:host=slave3.db.localhost;dbname=database', 'username', 'password' ); }, ); \/\/ write connection $write = array( 'master' =&gt; function () { return new ExtendedPdo( 'mysql:host=master.db.localhost;dbname=database', 'username', 'password' ); }, ); \/\/ configure locator at construction time $connections = new ConnectionLocator($default, $read, $write); "},{"id":"\/packages\/4.x\/Sql\/upgrade.html#2-2-6","title":"2.2.6. 3.x Upgrade Notes","content":"The vast majority of changes and breaks from the 2.x version are \"under the hood,\" so to speak. The main functionality methods (query(), exec(), perform(), fetch*(), yield*(), etc.) are unchanged and work just the same as in 2.x.The remaining changes and breaks can be categorized as: the rebuilder and parsers; profiling and logging; instantiation; and miscellaneous. "},{"id":"\/packages\/4.x\/Sql\/upgrade.html#2-2-6-1","title":"2.2.6.1. Rebuilder and Parsers","content":"The 2.x Rebuilder has been redone entirely, and now provides separate parsers for the separate database drivers (mysql, pgsql, sqlite, and sqlsrv). This originated from #104, along with #107 and #111, all of which are now resolved. It took a great deal of time and effort to complete, with several approaches attempted."},{"id":"\/packages\/4.x\/Sql\/upgrade.html#2-2-6-1-1","title":"2.2.6.1.1. Array Placeholders","content":"Given this code ...$stm = \"SELECT * FROM test WHERE foo IN (:foo)\"; $sth = $pdo-&gt;perform($stm, [ 'foo' =&gt; ['bar', 'baz', 'dib']; ]); echo $sth-&gt;queryString; ... 2.x would quote and replace the array values directly into the query:SELECT * FROM test WHERE foo IN ('bar', 'baz', 'dib') Now, under 3.x, the placeholder is expanded to match the number of array keys, so that there are multiple placeholders:SELECT * FROM test WHERE foo IN (:foo_0, :foo_1, :foo_2) The array values passed to the query will also be bound individually. (If you profile the query, you will see :foo_0 (et al.) in the bindings.)"},{"id":"\/packages\/4.x\/Sql\/upgrade.html#2-2-6-1-2","title":"2.2.6.1.2. Sequential Placeholders","content":"Given this code ...$stm = 'SELECT * FROM test WHERE foo = ? AND bar = ?'; $sth = $pdo-&gt;perform($stm, [ 'foo_value', 'bar_value', ]); echo $sth-&gt;queryString; ... the 2.x rebuilder would leave ? placeholders alone:SELECT * FROM test WHERE foo = ? AND bar = ? Now, under 3.x, sequential placeholders are converted to named placeholders; the name corresponds to the sequential position:SELECT * FROM test WHERE foo = :__1 AND bar = :__2 The sequential values passed to the query will be bound to the named replacements.This helps to correct errors associated with binding sequential and named placeholders together, and in identifiying bound values in longer query strings."},{"id":"\/packages\/4.x\/Sql\/upgrade.html#2-2-6-1-3","title":"2.2.6.1.3. Repetition of Named Placeholders","content":"With 3.x, you can use the same placeholder multiple times. Given this code ...$stm = 'SELECT * FROM test WHERE foo = :val OR bar = :val'; $sth = $pdo-&gt;perform($stm, [ 'val' =&gt; 'whatever', ]); echo $sth-&gt;queryString; ... the 3.x parser modifies repeated placeholders by suffixing them each time they reappear, and binds the needed values automatically:SELECT * FROM test WHERE foo = :val OR bar = :val__1 "},{"id":"\/packages\/4.x\/Sql\/upgrade.html#2-2-6-1-4","title":"2.2.6.1.4. Custom Parsers","content":"You can inject your own parsers as well via ExtendedPdo::setParser(). See the src\/Parser\/ directory for examples of the existing parsers."},{"id":"\/packages\/4.x\/Sql\/upgrade.html#2-2-6-2","title":"2.2.6.2. Profiling and Logging","content":"The 2.x version used a custom profiler system, retaining profiles as array constructs and returning them as such. You needed to inject it yourself.use Aura\\Sql\\Profiler; $pdo-&gt;setProfiler(new Profiler()); \/\/ ... \/\/ query(), fetch(), beginTransaction()\/commit()\/rollback() etc. \/\/ ... \/\/ retrieve the profile information as a series of arrays $profiles = $pdo-&gt;getProfiler()-&gt;getProfiles(); Under 3.x, the profiler interface itself remains custom, but it is now backed with the PSR-3 logger interface. This means you can use any PSR-3 implementation to capture profiler information. This means that the profiler emits strings, rather than arrays, for the logger to capture.A profiler is now automatically set on the ExtendedPdo instance, and uses an in-memory logger by default for debugging purposes.\/\/ no need to set a profiler, but you do need to activate it: $pdo-&gt;getProfiler()-&gt;setActive(); \/\/ ... \/\/ query(), fetch(), beginTransaction()\/commit()\/rollback() etc. \/\/ ... \/\/ retrieve the profiler logs from the default MemoryLogger $messages = $pdo-&gt;getProfiler()-&gt;getLogger()-&gt;getMessages(); You can set the log message format and log level through the profiler, to capture just the information you want.You can set your own profiler and backing logger with the setProfiler() method.use Aura\\Sql\\Profiler\\Profiler; $myLogger = new Psr3LoggerImplementation(); $pdo-&gt;setProfiler(new Profiler($myLogger)); Finally, under 2.x, ExtendedPdo would profile every function call. Unless you examined very carefully, a call to prepare() followed by perform() looked like 2 executions of the same query. To make it easier to examine logs, the 3.x version does not profile every function call (e.g., prepare() and prepareWithValues() are no longer logged)."},{"id":"\/packages\/4.x\/Sql\/upgrade.html#2-2-6-3","title":"2.2.6.3. Instantiation","content":"Under 2.x you would do this:$pdo = new ExtendedPdo( 'pgsql:host=localhost;dbname=test', 'username', 'password', array(), \/\/ driver options as key-value pairs array() \/\/ attributes as key-value pairs ); It appears the last argument ended up being extraneous. The 3.x ExtendedPdo changes the last argument to this:$pdo = new ExtendedPdo( 'pgsql:host=localhost;dbname=test', 'username', 'password', [], \/\/ driver options as key-value pairs [] \/\/ queries to execute after connection ); This lets you execute queries at connection time; e.g., to make connection configuration changes that cannot be made as driver options\/attributes. For example:$pdo = new ExtendedPdo( 'pgsql:host=localhost;dbname=test', 'username', 'password', [ PDO::ATTR_CASE =&gt; PDO::CASE_NATURAL, ], [ \"SET NAMES 'utf8'\", ] ) "},{"id":"\/packages\/4.x\/Sql\/upgrade.html#2-2-6-4","title":"2.2.6.4. Miscellaneous","content":" PHP 5.6 is now the minimum required PHP version, though using the latest PHP version is recommended. 3.x (as with previous versions) starts PDO in ERRMODE_EXCEPTION when no error mode is explicitly specified.. However, the sqlsrv driver balks at this, so it is started in ERRMODE_WARNING instead. The ExtendedPdo::yield*() methods now use the yield keyword instead of returning Iterator instances. 1.x had a quoteName() method to quote identifier names. This was removed in 2.x, when that (and related functionality) were split off to SqlQuery. The functionality is added back in 3.x as quoteName() and quoteSingleName() as a convenience, though it is less robust than in SqlQuery. Some drivers cause PDO to make additional methods available (e.g., sqlite and pgsql). The 3.x ExtendedPdo now proxies all unknown method calls to the underlying PDO instance to make those methods available, if they exist. When dumping an ExtendedPdo object, the username and password are omitted. This should help keep unexpected output of stack traces from revealing credentials. "},{"id":"\/packages\/3.x\/Di\/getting-started.html#3-1-1-1","title":"3.1.1.1. Overview","content":"The Aura.Di package provides a serializable dependency injection container with the following features: constructor and setter injection inheritance of constructor parameter and setter method values from parent classes inheritance of setter method values from interfaces and traits lazy-loaded instances, services, includes\/requires, and values instance factories optional auto-resolution of typehinted constructor parameter values Fully describing the nature and benefits of dependency injection, while desirable, is beyond the scope of this document. For more information about \"inversion of control\" and \"dependency injection\" please consult http:\/\/martinfowler.com\/articles\/injection.html by Martin Fowler.Finally, please note that this package is intended for use as a dependency injection system, not as a service locator system. If you use it as a service locator, that's bad, and you should feel bad."},{"id":"\/packages\/3.x\/Di\/getting-started.html#3-1-1-1-1","title":"3.1.1.1.1. Intended Usage","content":"The intent behind Aura.Di is for it be used like so: Instantiate a container. Do all configuration for all classes and services. Lock the container so it cannot be modified further. Retrieve objects from the locked container. Note that calling get() or newInstance() will automatically lock the container, preventing further configuration changes. This is true even inside configuration code, so use the lazy*() methods instead while configuring the container."},{"id":"\/packages\/3.x\/Di\/getting-started.html#3-1-1-2","title":"3.1.1.2. Container Instantiation","content":"We instantiate a Container like so:use Aura\\Di\\ContainerBuilder; $builder = new ContainerBuilder(); $di = $builder-&gt;newInstance(); "},{"id":"\/packages\/3.x\/Di\/getting-started.html#3-1-1-3","title":"3.1.1.3. Creating Object Instances","content":"The most straightforward way is to create an object through the Container is via the newInstance() method:$object = $di-&gt;newInstance('Vendor\\Package\\ClassName');  N.b.: The Container locks itself once a new instance is produced; this ensures that the Container configuration cannot be modified once objects have been created. However, this is a relatively naive way to create objects with the Container. It is better to specify the various constructor parameters, setter methods, and so on, and let the Container inject those values for us only when the object is used as a dependency for something else."},{"id":"\/packages\/3.x\/Di\/constructor.html#3-1-2","title":"3.1.2. Constructor Injection","content":"When we use the Container to instantiate a new object, we often need to inject (i.e., set) constructor parameter values in various ways.We can define default values for constructor parameters using the $di-&gt;params array on the Container before locking it.Let's look at a class that takes some constructor parameters:namespace Vendor\\Package; class Example { protected $foo; protected $bar; public function __construct($foo, $bar) { $this-&gt;foo = $foo; $this-&gt;bar = $bar; } } If we were to try to create an object using $di-&gt;newInstance('Vendor\\Package\\Example'), the instantiation would fail. The $foo and $bar params are required, and the Container does not know what to use for that value.To remedy this, we tell the Container what values to use for each Vendor\\Package\\Example constructor parameter by name using the $di-&gt;params array:$di-&gt;params['Vendor\\Package\\Example']['foo'] = 'foo_value'; $di-&gt;params['Vendor\\Package\\Example']['bar'] = 'bar_value'; We can also specify by position:$di-&gt;params['Vendor\\Package\\Example'][0] = 'foo_value'; $di-&gt;params['Vendor\\Package\\Example'][1] = 'bar_value'; Once all the params are set, we create an object with $di-&gt;newInstance('Vendor\\Package\\Example'), the instantiation will work correctly. Each time we create an instance through the Container, it will apply the $di-&gt;params values for the matching class. N.b.: If you try to access $params after calling newInstance() (or after locking the Container using the lock() method) the Container will throw an exception. This is to prevent modifying the params after objects have been created. Thus, be sure to set up all params for all objects before creating an object. "},{"id":"\/packages\/3.x\/Di\/setter.html#3-1-3","title":"3.1.3. Setter Injection","content":"The Container supports setter injection in addition to constructor injection. (These can be combined as needed.)After the Container constructs a new instance of an object, we can specify that certain methods should be called with certain values immediately after instantiation by using the $di-&gt;setter array before locking it.Say we have class like the following:namespace Vendor\\Package; class Example { protected $foo; public function setFoo($foo) { $this-&gt;foo = $foo; } } We can specify that, by default, the setFoo() method should be called with a specific value after construction like so:$di-&gt;setters['Vendor\\Package\\Example']['setFoo'] = 'foo_value'; Note also that this works only with explicitly-defined setter methods. Setter methods that exist only via magic __call() will not be honored. N.b.: If you try to access $setters after calling newInstance() (or after locking the Container using the lock() method) the Container will throw an exception. This is to prevent modifying the params after objects have been created. Thus, be sure to set up all params for all objects before creating an object. "},{"id":"\/packages\/3.x\/Di\/inheritance.html#3-1-4","title":"3.1.4. Class, Interface, and Trait Inheritance","content":" N.b.: When specifying fully-qualified class names, do not include the leading namespace separator. Doing so may lead to unexpected behavior. In other words, always use ClassName and never use \\ClassName. "},{"id":"\/packages\/3.x\/Di\/inheritance.html#3-1-4-1","title":"3.1.4.1. Class Inheritance","content":"Each class instantiated through the Container \"inherits\" the constructor parameter and setter method values of its parents by default. This means we can specify a constructor parameter or setter method value on a parent class, and the child class will use it (that is, unless we set an overriding value on the child class).Let's say we have this parent class and this child class:class ExampleParent { protected $foo; protected $bar; public function __construct($foo) { $this-&gt;foo = $foo; } public function setBar($bar) { $this-&gt;bar = $bar; } } class ExampleChild extends ExampleParent { protected $baz; public function setBaz($baz) { $this-&gt;baz = $baz; } } If we define the constructor parameters and setter method values for the parent ...$di-&gt;params['ExampleParent']['foo'] = 'parent_foo'; $di-&gt;setters['ExampleParent']['setBar'] = 'parent_bar'; ... then when we call $di-&gt;newInstance('ExampleChild'), the child class will \"inherit\" those values as defaults.We can always override the \"inherited\" values by specifying them for the child class directly:$di-&gt;params['ExampleChild']['foo'] = 'child_foo'; $di-&gt;setters['ExampleChild']['setBaz'] = 'child_baz'; Classes extended from the child class will then inherit those new values. In this way, constructor parameter and setter method values are propagated down the inheritance hierarchy."},{"id":"\/packages\/3.x\/Di\/inheritance.html#3-1-4-2","title":"3.1.4.2. Interface And Trait Inheritance","content":"If a class exposes a setter method by implementing an interface or using a trait, we can specify the default value for that setter method on the interface or trait. That value will then be applied by default to every class that extends that implements that interface or uses that trait.For example, let's say we have this interface, trait, and class:interface ExampleBarInterface { public function setBar($bar); } trait ExampleFooTrait { public function setFoo($foo) { $this-&gt;foo = $foo; } } class Example implements ExampleBarInterface { use ExampleFooTrait; protected $foo; protected $bar; public function setBar($bar) { $this-&gt;bar = $bar; } } We can define the default setter method values on the trait and interface:$di-&gt;setters['ExampleFooTrait']['setFoo'] = 'foo_value'; $di-&gt;setters['ExampleBarInterface']['setBar'] = 'bar_value'; When we call $di-&gt;newInstance('Example'), those setter methods will be called by the Container with those values.Note that if we have class-specific $di-&gt;setter values, those will take precedence over the trait and interface setter values."},{"id":"\/packages\/3.x\/Di\/services.html#3-1-5","title":"3.1.5. Services","content":"A \"service\" is an object stored in the Container under a unique name. Any time you get() the named service, you always get back the same object instance.\/\/ define the Example class class Example { \/\/ ... } \/\/ set services as lazy; if you use newInstance() it will lock the container $di-&gt;set('service_name', $di-&gt;lazyNew('Example')); \/\/ get a service; the first get() will lock the container $service1 = $di-&gt;get('service_name'); $service2 = $di-&gt;get('service_name'); \/\/ the two service objects are the same var_dump($service1 === $service2); \/\/ true  N.b.: If you try to access $params or $setters, or to call set(), after calling get() or after locking the Container using the lock() method, the Container will throw an exception. This is to prevent modifying the params after objects have been created. Thus, be sure to set up all params for all objects before creating an object. "},{"id":"\/packages\/3.x\/Di\/lazy.html#3-1-6","title":"3.1.6. Lazy Injection","content":"Unlike the newInstance() and get() methods, calling one of the lazy*() methods on the Container will not lock the Container. Using lazy injection is the preferred and recommended way to defines object values for $params and $setters, and to define services."},{"id":"\/packages\/3.x\/Di\/lazy.html#3-1-6-1","title":"3.1.6.1. Lazy Instances","content":"Thus far, we have used newInstance() to create objects through the Container. However, we usually don't want to create an object right at that moment when defining it. Instead, we almost always want to wait to create the object only at the time it is actually needed. Using lazyNew() instead allows us to defer object creation until it is needed as a dependency for another object.$di-&gt;params['Example']['foo'] = $di-&gt;lazyNew('AnotherExample'); Now the AnotherExample object will only be instantiated when the Example object is instantiated. It will use the default AnotherExample injection values.If we want to override the default $di-&gt;params values for a specific lazy instance, we can pass a $params array as the second argument to lazyNew() to merge with the default values. For example:$di-&gt;set('service_name', $di-&gt;lazyNew( 'AnotherExample', [ 'bar' =&gt; 'alternative_bar_value', ] )); This will leave the $foo parameter default in place, and override the $bar parameter value, for just that instance of the ExampleWithParams.Likewise, we can note instance-specific setter values to use in place of the defaults. We do so via the third argument to $di-&gt;lazyNew(). For example:$di-&gt;set('service_name', $di-&gt;lazyNew( 'AnotherExample', [], \/\/ no $params overrides [ 'setFoo' =&gt; 'alternative_foo_value', ] )); "},{"id":"\/packages\/3.x\/Di\/lazy.html#3-1-6-2-1","title":"3.1.6.2.1. Setting","content":"As with object instances, we generally want to create a service instance only at the moment we get it, not at the moment we set it. To lazy-load a service, set the service using the lazyNew() method:\/\/ set the service as a lazy-loaded new instance $di-&gt;set('service_name', $di-&gt;lazyNew('Example')); Now the service is created only when we we get() it, and not before. This lets us set as many services as we want, but only incur the overhead of creating the instances we actually use."},{"id":"\/packages\/3.x\/Di\/lazy.html#3-1-6-2-2","title":"3.1.6.2.2. Getting","content":"Sometimes a class will need a service as one of its parameters. By way of example, the following class needs a database connection:class ExampleNeedsService { protected $db; public function __construct($db) { $this-&gt;db = $db; } } To inject a shared service as a parameter value, use $di-&gt;lazyGet() so that the service object is not created until the ExampleNeedsService object is created:$di-&gt;params['ExampleNeedsService']['db'] = $di-&gt;lazyGet('db_service'); This keeps the service from being created until the very moment it is needed. If we never instantiate anything that needs the service, the service itself will never be instantiated."},{"id":"\/packages\/3.x\/Di\/lazy.html#3-1-6-2-3","title":"3.1.6.2.3. Getting-and-Calling","content":"Sometimes it will be useful to retrieve the result of a method call to a shared service. To do so, use the lazyGetCall() method, passing the name of the service first, followed by the method name, and optionally followed by any arguments to the method.$di-&gt;params['ExampleNeedsFactoriedObject']['object'] = $di-&gt;lazyGetCall('factory_service', 'newInstance'); "},{"id":"\/packages\/3.x\/Di\/lazy.html#3-1-6-3","title":"3.1.6.3. Lazy Values","content":"Sometimes we know that a parameter needs to be specified, but we don't know what it will be until later. Perhaps it is the result of looking up an API key from an environment variable. In these and other cases, we can tell a constructor parameter or setter method to use a \"lazy value\" and then specify that value elsewhere.For example, we can configure the Example constructor parameters to use lazy values like so:$di-&gt;params['Example']['foo'] = $di-&gt;lazyValue('fooval'); $di-&gt;params['Example']['bar'] = $di-&gt;lazyValue('barval'); We can then specify at some later time the values of fooval and barval using the $di-&gt;values array:$di-&gt;values['fooval'] = 'lazy value for foo'; $di-&gt;values['barval'] = 'lazy value for bar'; Lazy values can be lazy themselves:$di-&gt;values['fooval'] = $di-&gt;lazyGetCall('option_container', 'getFooOption'); "},{"id":"\/packages\/3.x\/Di\/lazy.html#3-1-6-4","title":"3.1.6.4. Lazy Include and Require","content":"Occasionally we will need to include a file that returns a value, such as data file that returns a PHP array:\/\/ \/path\/to\/data.php return [ 'foo' =&gt; 'bar', 'baz' =&gt; 'dib', 'zim' =&gt; 'gir' ]; We could set a constructor parameter or setter method value to include \"\/path\/to\/data.php\", but that would cause the file to be read filesystem at that moment, instead of at instantiation time. To lazy-load a file as a value, call $di-&gt;lazyInclude() or $di-&gt;lazyRequire() (depending on your preference for warning levels).$di-&gt;params['Example1']['data'] = $di-&gt;lazyInclude('\/path\/to\/data.php'); $di-&gt;params['Example2']['data'] = $di-&gt;lazyRequire('\/path\/to\/data.php'); "},{"id":"\/packages\/3.x\/Di\/lazy.html#3-1-6-5","title":"3.1.6.5. Lazy Array","content":"Sometimes you'll be working with code that expects an array of objects. If you want the objects within the array to be lazy, you can use the $di-&gt;lazyArray() method. This will iterate through your array and resolve any lazy objects before returning the array.$di-&gt;setters['Example']['addFoos'] = $di-&gt;lazyArray([ $di-&gt;lazyNew('FirstFoo'), $di-&gt;lazyNew('SecondFoo'), ]); \/\/ Nesting Lazy Arrays $di-&gt;setters['Example']['addBars'] = $di-&gt;lazyArray([ $di-&gt;lazyArray(['name1', $di-&gt;lazyNew('FirstBar'), 'en']), $di-&gt;lazyArray(['name2', $di-&gt;lazyNew('SecondFoo'), 'es']), ]); LazyArray extends ArrayObject so if you need to modify the LazyArray after you've assigned it you can use any of the ArrayObject methods.$di-&gt;setters['Example']['addFoos'] = $di-&gt;lazyArray([]); \/\/ Append to array $di-&gt;setters['Example']['addFoos']-&gt;append($di-&gt;lazyNew('SecondFoo')); \/\/ Get a copy of the internal array $copy = $di-&gt;setters['Example']['addFoos']-&gt;getArrayCopy(); \/\/ Manipulate the array array_unshift($copy, $di-&gt;lazyNew('FirstFoo')); \/\/ Reassign with new array $di-&gt;setters['Example']['addFoos'] = $di-&gt;lazyArray($copy); "},{"id":"\/packages\/3.x\/Di\/lazy.html#3-1-6-6","title":"3.1.6.6. Lazy Callable","content":"Sometimes you'll be working with code that deals with callables. This code may expect to invoke the callable once, or many times. If you wanted to use a service in this situation, you can use the lazyCallable method. This will produce a callable that will lazily resolve other lazies, and ensure that all calls to the service are made appropriately.$di-&gt;params['Example']['foo'] = $di-&gt;lazyCallable($di-&gt;lazyGet('service_name')); $di-&gt;params['Example']['bar'] = $di-&gt;lazyCallable([$di-&gt;lazyNew('ServiceClass'), 'methodName']); "},{"id":"\/packages\/3.x\/Di\/lazy.html#3-1-6-7","title":"3.1.6.7. Generic Lazy Calls","content":"It may be that we have a complex bit of logic we need to execute for a value. If none of the existing $di-&gt;lazy*() methods meet our needs, we can wrap an anonymous function or other callable in a lazy() call, and the callable's return will be used as the value.$di-&gt;params['Example']['foo'] = $di-&gt;lazy(function () { \/\/ complex calculations, and then: return $result; }); Note that this will work with any PHP callable, such as a static method:\/\/ ServiceClass::staticMethod() $di-&gt;set('service', $di-&gt;lazy(['ServiceClass', 'staticMethod'])); You can pass arguments to the callable like so:\/\/ ServiceClass::staticMethod($arg1, $arg2, $arg3) $di-&gt;set('service', $di-&gt;lazy(['ServiceClass', 'staticMethod'], $arg1, $arg2, $arg3 )); Lazies in the callable array, and in the arguments, will be resolved automatically.\/\/ $serviceClass-&gt;methodName($configArray) $di-&gt;set('service', $di-&gt;lazy([$di-&gt;lazyNew('ServiceClass'), 'methodName'], $di-&gt;lazyInclude('\/path\/to\/config.array.php') )); You can also pass in lazies directly as the callable.$di-&gt;set('service', $di-&gt;lazy($di-&gt;lazyNew('InvokableServiceClass'), $arg1, $arg2 )); Beware of relying on generic Lazy calls too much; if we do, it probably means we need to separate our configuration concerns better than we are currently doing."},{"id":"\/packages\/3.x\/Di\/factories.html#3-1-7","title":"3.1.7. Instance Factories","content":"Occasionally, a class will need to receive not just an instance, but a factory that is capable of creating a new instance over and over. For example, say we have a class like the following:class ExampleNeedsFactory { protected $struct_factory; public function __construct($struct_factory) { $this-&gt;struct_factory = $struct_factory; } public function getStruct(array $data) { $struct = $this-&gt;struct_factory-&gt;__invoke($data); return $struct; } } class ExampleStruct { public function __construct(array $data) { foreach ($data as $key =&gt; $val) { $this-&gt;$key = $val; } } } We can inject a Factory that creates only ExampleStruct objects using $di-&gt;newFactory().$di-&gt;params['ExampleNeedsFactory']['struct_factory'] = $di-&gt;newFactory('ExampleStruct'); Note that the arguments passed to the factory __invoke() method will be passed to the underlying instance constructor sequentially, not by name. This means the __invoke() method works more like the native new keyword, and not like $di-&gt;lazyNew(). These arguments override any $di-&gt;params values that have been set for the class being factoried; without the overrides, all existing $di-&gt;params values for that class will be honored. (Values from $di-&gt;setter for the class will also be honored, but cannot be overridden.)Do not feel limited by the Factory implementation. We can create and inject factory objects of our own if we like. The Factory returned by the $di-&gt;newFactory() method is an occasional convenience, nothing more."},{"id":"\/packages\/3.x\/Di\/factories.html#3-1-7-1","title":"3.1.7.1. Broader Instantiation","content":"Sometimes you may want to more broadly leverage a configured containers ability to instantiate objects in your classes, for example in some kind of service locator. The ResolutionHelper provides a callable object which takes a \"specification\" as a parameter and will retrieve a service if the container has one appropriate to the specification or instantiate a new instance of the class if there is no matching service name. If an array is passed as the specification, the array is returned with the first value \"resolved\". This array functionality allows for a callable to be returned referencing an method on an instance. $helper = $di-&gt;newResolutionHelper(); $foo = $helper(\\My\\Foo::class); \/\/ will return service named \"My\\Foo\" if on is named as such \/\/ or else a new instance of \"My\\Foo\" $fooBar = $helper([\\My\\Foo::class, 'bar']); \/\/ will return the equivalent of [$foo, 'bar'] Using the ResolutionHelper, you can write consuming code that type hints a callable, rather than the container itself."},{"id":"\/packages\/3.x\/Di\/config.html#3-1-8","title":"3.1.8. Container Builder and Config Classes","content":"The ContainerBuilder also builds fully-configured Container objects using ContainerConfig classes. It works using a two-stage configuration system.The two stages are \"define\" and \"modify\". In the \"define\" stage, the ContainerConfig object defines constructor parameter values, setter method values, services, and so on. The ContainerBuilder then locks the Container so that these definitions cannot be changed, and begins the \"modify\" stage. In the \"modify\" stage, we may get() services from the Container and modify them programmatically if needed.To build a fully-configured Container using the ContainerBuilder, we do something like the following:use Aura\\Di\\ContainerBuilder; $container_builder = new ContainerBuilder(); \/\/ use the builder to create and configure a container \/\/ using an array of ContainerConfig classes $di = $container_builder-&gt;newConfiguredInstance([ 'Aura\\Cli\\_Config\\Common', 'Aura\\Router\\_Config\\Common', 'Aura\\Web\\_Config\\Common', ]); Note: As with the newInstance method of the ContainerBuilder, you will have to pass $container_builder::AUTO_RESOLVE to newConfiguredInstance (as the second parameter) if you want to enable auto-resolution.A configuration class looks like the following:namespace Vendor\\Package; use Aura\\Di\\Container; use Aura\\Di\\ContainerConfig; class Config extends ContainerConfig { public function define(Container $di) { $di-&gt;set('log_service', $di-&gt;lazyNew('Logger')); $di-&gt;params['Logger']['dir'] = '\/path\/to\/logs'; } public function modify(Container $di) { $log = $di-&gt;get('log_service'); $log-&gt;debug('Finished config.'); } } Here are some example ContainerConfig classes from earlier Aura packages: Aura.Cli Aura.Html Aura.Router Aura.View Alternatively, if you already have a ContainerConfig object created, you can pass it directly to the ContainerBuilder instead of a string class name:$routerConfig = new Aura\\Router\\_Config\\Common(); \/\/ use the builder to create and configure a container \/\/ using an array of ContainerConfig classes $di = $container_builder-&gt;newConfiguredInstance([ 'Aura\\Cli\\_Config\\Common', $routerConfig, 'Aura\\Web\\_Config\\Common', ]); If you have a package which combines a number of disparate components that each provide a ContainerConfig you could bundle them together using the ConfigCollection class. This class takes an array of ContainerConfigs or ContainerConfig class names and implements ContainerConfigInterface itself. namespace My\\App; use Aura\\Di\\ConfigCollection; use My\\Domain; use My\\WebInterface; use My\\DataSource; class Config extends ConfigCollection { public function __construct() { parent::__construct( [ Domain\\Config::class, WebInterface\\Config::class, DataSource\\Config::class, ] ); } } You can then use the Collection and it will instantiate (if necessary) and call the define and modify methods of each of the other ContainerConfigs.$di = $container_builder-&gt;newConfiguredInstance([\\My\\App\\Config::class]) "},{"id":"\/packages\/3.x\/Di\/auto.html#3-1-9","title":"3.1.9. Auto-Resolution Of Constructor Parameters","content":"Some developers prefer to let the Container resolve dependencies on its own, without having to specify anything in a configuration file. Note that there can be unusual debugging problems inherent in tracking down the default injections, so auto-resolution may or may not be your preference.To use auto-resolution in a Container, build the Container with $container = $builder-&gt;newInstance($builder::AUTO_RESOLVE). If you're using newConfiguredInstance to configure your dependency injector and want this functionality, you will need to pass $builder::AUTO_RESOLVE as the second parameter.Note that auto-resolution only works for class\/interface typehints. It does not work for array typehints.Note also that auto-resolution does not apply to setter methods. This is because the Container does not know which methods are setters and which are \"normal use\" methods. Since you have to specify $di-&gt;setters anyway, the Container has no chance to attempt auto-resolution."},{"id":"\/packages\/3.x\/Di\/auto.html#3-1-9-1","title":"3.1.9.1. Auto-Resolving From Concrete Typehints","content":"If the parameter is typehinted to a class but there is no $di-&gt;params value for that parameter, and also no default value, the Container will automatically fill in a lazyNew() call to the typehinted class.For example, look at the following class; it has a parameter typehinted to a class, and no default value:class Example { public function __construct(Foo $foo) { \/\/ ... } } The Container will auto-resolve the constructor param as if you had explicitly specified the following:$di-&gt;params['Example']['foo'] = $di-&gt;lazyNew('Foo'); "},{"id":"\/packages\/3.x\/Di\/auto.html#3-1-9-2","title":"3.1.9.2. Auto-Resolving From Abstract and Interface Typehints","content":"Obviously, you can't instantiate an interface or an abstract class. So, if a constructor parameter is typehinted like this ...class Example { public function __construct(FooInterface $foo) { \/\/ ... } } ... the Container cannot auto-resolve with lazyNew('FooInterface').When it comes to interfaces and abstracts, then, you have to tell the Container how to resolve them using $di-&gt;types:$di-&gt;types['FooInterface'] = $di-&gt;lazyNew('Foo'); The Container will now resolve all FooInterface typehints to a lazy-new instance of Foo."},{"id":"\/packages\/3.x\/Di\/auto.html#3-1-9-3","title":"3.1.9.3. Auto-Resolving to Services","content":"Sometimes you don't want a new instance of the typehinted param. Often, you will want to use a service instead. Auto-resolving a typehint to a service is easy, using the $di-&gt;types technique from above. For example, given this class ...class Example { public function __construct(DbInterface $db) { \/\/ ... } } ... we can auto-resolve all DbInterface typehints to a service in the Container:$di-&gt;types['DbInterface'] = $di-&gt;lazyGet('database_connection'); This works for concrete classes as well. Given this class:class Example { public function __construct(Db $db) { \/\/ ... } } ... we can auto-resolve all concrete PDO typehints to a service in the Container:$di-&gt;types['Db'] = $di-&gt;lazyGet('database_connection'); "},{"id":"\/packages\/3.x\/Di\/auto.html#3-1-9-4","title":"3.1.9.4. Overriding Auto-Resolution","content":"You may wish to explicitly specify a constructor parameter for a class, instead of letting the Container use auto-resolution. You can do so through the old familiar $di-&gt;params technique.\/\/ by default, resolve to this service $di-&gt;types['DbInterface'] = $di-&gt;lazyGet('database_connection'); \/\/ but in this particular class, and its children, \/\/ resolve to this other service $di-&gt;params['OtherClass']['db'] = $di-&gt;lazyGet('other_connection'); "},{"id":"\/packages\/3.x\/Di\/migrating.html#3-1-10","title":"3.1.10. Migrating from 2.x to 3.x","content":"Aura.Di 3.x is largely similar to 2.x, but there are some backwards-compatibility breaks, as well as some new features."},{"id":"\/packages\/3.x\/Di\/migrating.html#3-1-10-1-1","title":"3.1.10.1.1. Instantiation","content":"The way the container is instantiated has been changed from this ...use Aura\\Di\\Container; use Aura\\Di\\Factory; use Aura\\Di\\ContainerBuilder; $di = new Container(new Factory); \/\/ or $container_builder = new ContainerBuilder(); $di = $container_builder-&gt;newInstance( array(), array(), $auto_resolve = false ); ... to this:use Aura\\Di\\ContainerBuilder; $container_builder = new ContainerBuilder(); \/\/ use the builder to create and configure a container \/\/ using an array of ContainerConfig classes $di = $container_builder-&gt;newConfiguredInstance([ 'Aura\\Cli\\_Config\\Common', 'Aura\\Router\\_Config\\Common', 'Aura\\Web\\_Config\\Common', ]); "},{"id":"\/packages\/3.x\/Di\/migrating.html#3-1-10-1-2","title":"3.1.10.1.2. \nsetter vs setters\n","content":"Use of $di-&gt;setter in 2.x is now $di-&gt;setters in 3.x. Please note there is an additional s in the end."},{"id":"\/packages\/3.x\/Di\/migrating.html#3-1-10-1-3","title":"3.1.10.1.3. Automatic Locking","content":"The container now calls lock() automatically when you call get() or newInstance(), so make sure everything is lazy-loaded, or else you will run into something like cannot modify container when locked."},{"id":"\/packages\/3.x\/Di\/migrating.html#3-1-10-1-4","title":"3.1.10.1.4. Config vs ContainerConfig","content":"Aura\\Di\\Config in 2.x is now Aura\\Di\\ContainerConfig in 3.x."},{"id":"\/packages\/3.x\/Di\/migrating.html#3-1-10-2-1","title":"3.1.10.2.1. lazyGetCall()","content":"Example taken from Radar:$di-&gt;params['Radar\\Adr\\Handler\\RoutingHandler']['matcher'] = $di-&gt;lazyGetCall('radar\/adr:router', 'getMatcher'); Here the value assigned to matcher is taken from the RouterContainer getMatcher() method."},{"id":"\/packages\/3.x\/Di\/migrating.html#3-1-10-2-2","title":"3.1.10.2.2. Instance Factories","content":"An instance factory creates multiple instances of the same class; refer the docs for more information."},{"id":"\/packages\/3.x\/Intl.html#3-2","title":"3.2. Aura.Intl","content":"The Aura.Intl package provides internationalization (I18N) tools, specifically package-oriented per-locale message translation."},{"id":"\/packages\/3.x\/Intl.html#3-2-1","title":"3.2.1. Getting Started","content":"You can instantiate TranslatorLocator object from TranslatorLocatorFactory as below&lt;?php use Aura\\Intl\\TranslatorLocatorFactory; $factory = new TranslatorLocatorFactory(); $translators = $factory-&gt;newInstance(); ?&gt; Alternatively, we can add the Aura.Intl package \/path\/to\/Aura.Intl\/src to our autoloader and build a translator locator manually:&lt;?php use Aura\\Intl\\PackageLocator; use Aura\\Intl\\FormatterLocator; use Aura\\Intl\\TranslatorFactory; use Aura\\Intl\\TranslatorLocator; return new TranslatorLocator( new PackageLocator, new FormatterLocator([ 'basic' =&gt; function () { return new \\Aura\\Intl\\BasicFormatter; }, 'intl' =&gt; function () { return new \\Aura\\Intl\\IntlFormatter; }, ]), new TranslatorFactory, 'en_US' ); ?&gt; "},{"id":"\/packages\/3.x\/Intl.html#3-2-2","title":"3.2.2. Setting Localized Messages For A Package","content":"We can set localized messages for a package through the PackageLocator object from the translator locator. We create a new Package with messages and place it into the locator as a callable. The messages take the form of a message key and and message string.&lt;?php use Aura\\Intl\\Package; \/\/ get the package locator $packages = $translators-&gt;getPackages(); \/\/ place into the locator for Vendor.Package $packages-&gt;set('Vendor.Package', 'en_US', function() { \/\/ create a US English message set $package = new Package; $package-&gt;setMessages([ 'FOO' =&gt; 'The text for \"foo.\"', 'BAR' =&gt; 'The text for \"bar.\"', ]); return $package; }); \/\/ place into the locator for a Vendor.Package $packages-&gt;set('Vendor.Package', 'pt_BR', function() { \/\/ a Brazilian Portuguese message set $package = new Package; $package-&gt;setMessages([ 'FOO' =&gt; 'O texto de \"foo\".', 'BAR' =&gt; 'O texto de \"bar\".', ]); return $package; }); ?&gt; "},{"id":"\/packages\/3.x\/Intl.html#3-2-3","title":"3.2.3. Setting The Default Locale","content":"We can set the default locale for translations using the setLocale() method:&lt;?php $translators-&gt;setLocale('pt_BR'); ?&gt; "},{"id":"\/packages\/3.x\/Intl.html#3-2-4","title":"3.2.4. Getting A Localized Message","content":"Now that the translator locator has messages and a default locale, we can get an individual package translator. The package translator is suitable for injection into another class, or for standalone use.&lt;?php \/\/ recall that the default locale is pt_BR $translator = $translators-&gt;get('Vendor.Package'); echo $translator-&gt;translate('FOO'); \/\/ 'O texto de \"foo\".' ?&gt; You can get a translator for a non-default locale as well:&lt;?php $translator = $translators-&gt;get('Vendor.Package', 'en_US'); echo $translator-&gt;translate('FOO'); \/\/ 'The text for \"foo.\"' ?&gt; "},{"id":"\/packages\/3.x\/Intl.html#3-2-5","title":"3.2.5. Replacing Message Tokens With Values","content":"We often need to use dynamic values in translated messages. First, the message string needs to have a token placeholder for the dynamic value:&lt;?php \/\/ get the packages out of the translator locator $packages = $translators-&gt;getPackages(); $packages-&gt;set('Vendor.Dynamic', 'en_US', function() { \/\/ US English messages $package = new Package; $package-&gt;setMessages([ 'PAGE' =&gt; 'Page {page} of {pages} pages.', ]); return $package; }); $packages-&gt;set('Vendor.Dynamic', 'pt_BR', function() { \/\/ Brazilian Portuguese messages $package = new Package; $package-&gt;setMessages([ 'PAGE' =&gt; 'P\u00c3\u00a1gina {page} de {pages} p\u00c3\u00a1ginas.', ]); return $package; }); ?&gt; Then, when we translate the message, we provide an array of tokens and replacement values. These will be interpolated into the message string.&lt;?php \/\/ recall that the default locale is pt_BR $translator = $translators-&gt;get('Vendor.Dynamic'); echo $translator-&gt;translate('PAGE', [ 'page' =&gt; 1, 'pages' =&gt; 1, ]); \/\/ 'P\u00c3\u00a1gina 1 de 1 p\u00c3\u00a1ginas.' ?&gt; "},{"id":"\/packages\/3.x\/Intl.html#3-2-6","title":"3.2.6. Pluralized Messages","content":"Usually, we need to use different messages when a value is singular or plural. The BasicFormatter is not capable of presenting different messages based on different token values. The IntlFormatter is capable, but the PHP intl extension must be loaded to take advantage of it, and we must specify the 'intl' formatter for the package in the catalog.When using the IntlFormatter, we can build our message strings to present singular or plural messages, as in the following example:&lt;?php \/\/ get the packages out of the translator locator $packages = $translators-&gt;getCatalog(); \/\/ get the Vendor.Dynamic package en_US locale and set \/\/ US English messages with pluralization. note the use \/\/ of # instead of {pages} herein; using the placeholder \/\/ \"inside itself\" with the Intl formatter causes trouble. $package-&gt;setMessages([ 'PAGE' =&gt; '{pages,plural,' . '=0{No pages.}' . '=1{One page only.}' . 'other{Page {page} of # pages.}' . '}' ]); \/\/ use the 'intl' formatter for this package and locale $package-&gt;setFormatter('intl'); \/\/ now that we have added the pluralizable messages, \/\/ get the US English translator for the package $translator = $translators-&gt;get('Vendor.Dynamic', 'en_US'); \/\/ zero translation echo $translator-&gt;translate('PAGE', [ 'page' =&gt; 0, 'pages' =&gt; 0, ]); \/\/ 'No pages.' \/\/ singular translation echo $translator-&gt;translate('PAGE', [ 'page' =&gt; 1, 'pages' =&gt; 1, ]); \/\/ 'One page only.' \/\/ plural translation echo $translator-&gt;translate('PAGE', [ 'page' =&gt; 3, 'pages' =&gt; 10, ]); \/\/ 'Page 3 of 10 pages.' ?&gt; Note that you can use other tokens within a pluralized token string to build more complex messages. For more information, see the following:http:\/\/icu-project.org\/apiref\/icu4j\/com\/ibm\/icu\/text\/MessageFormat.html"},{"id":"\/packages\/3.x\/Payload.html#3-3","title":"3.3. Aura.Payload","content":"You use a Payload as a data transfer object to send domain-layer results to your user-interface layer, along with meta-data indicating the meaning of the domain results."},{"id":"\/packages\/3.x\/Payload.html#3-3-1","title":"3.3.1. Getting Started","content":"Instantiating a Payload object is straighforward:&lt;?php use Aura\\Payload\\Payload; $payload = new Payload(); ?&gt; You can then set the payload status and domain output, along with error codes, error messages, the input as received by the domain layer, and any extras you like.While this may suffice for your particular implementation, there is also a factory object to allow each call to return its own payload.&lt;?php use Aura\\Payload\\PayloadFactory; $payloadFactory = new PayloadFactory(); $payload = $payloadFactory-&gt;newInstance(); ?&gt; "},{"id":"\/packages\/3.x\/Payload.html#3-3-2","title":"3.3.2. Methods","content":"Use these methods in your domain layer to modify the Payload. (All set*() methods return the Payload object itself, so you can chain the methods fluently.) setStatus(): Sets the payload status in terms of the domain layer. setInput(): Sets the input as received by the domain layer. setOutput(): Sets the output produced by the domain layer. setMessages(): Sets the messages reported by the domain layer. setExtras(): Sets \"extra\" values produced by the domain layer. Your calling code can then examine the payload object using the get*() complements to the the set*() methods. getStatus(): Gets the payload status in terms of the domain layer. getInput(): Gets the input as received by the domain layer. getOutput(): Gets the output produced by the domain layer. getMessages(): Gets the messages reported by the domain layer. getExtras(): Gets \"extra\" values produced by the domain layer. "},{"id":"\/packages\/3.x\/Payload.html#3-3-3","title":"3.3.3. Status Values","content":"Several generic status values are available as constants on the Aura\\Payload_Interface\\PayloadStatus class: PayloadStatus::ACCEPTED: A command has been accepted for later processing. PayloadStatus::AUTHENTICATED: An authentication attempt succeeded. PayloadStatus::AUTHORIZED: An authorization request succeeded. PayloadStatus::CREATED: A creation attempt succeeded. PayloadStatus::DELETED: A deletion attempt succeeded. PayloadStatus::ERROR: There was a major error of some sort. PayloadStatus::FAILURE: There was a generic failure of some sort. PayloadStatus::FOUND: A query successfullly returned results. PayloadStatus::NOT_ACCEPTED: A command failed to be accepted. PayloadStatus::NOT_AUTHENTICATED: The user is not authenticated. PayloadStatus::NOT_AUTHORIZED: The user is not authorized for the action. PayloadStatus::NOT_CREATED: A creation attempt failed. PayloadStatus::NOT_DELETED: A deletion attempt failed. PayloadStatus::NOT_FOUND: A query failed to return results. PayloadStatus::NOT_UPDATED: An update attempt failed. PayloadStatus::NOT_VALID: User input was invalid. PayloadStatus::PROCESSING: A command is in-process but not finished. PayloadStatus::SUCCESS: There was a generic success of some sort. PayloadStatus::UPDATED: An update attempt succeeded. PayloadStatus::VALID: User input was valid. You should consider creating your own domain-specific payload statuses as well.Your user-interface layer can use these to determine how to process and present the domain objects retrieved via Payload::getOutput()."},{"id":"\/packages\/3.x\/Payload.html#3-3-4","title":"3.3.4. Example","content":"Here is a naive example Application Service class that uses a Payload to return its results. Note how: the browsePosts() method returns either FOUND or NOT_FOUND payloads; the readPost() method also returns either FOUND or NOT_FOUND payloads; the editPost() method returns ... ... a NOT_FOUND payload if the $id does not exist, ... a NOT_AUTHORIZED payload if the user does not own the post, ... a NOT_VALID payload for invalid input, ... or an UPDATED payload on success; the addPost() method returns ... ... a NOT_VALID payload for invalid input, ... or a CREATED payload on success; the deletePost() method returns ... ... a NOT_FOUND payload if the $id does not exist, ... a NOT_AUTHORIZED payload if the user does not own the post, ... or a DELETED payload on success. Any raised Exception gets transformed into an ERROR payload, with the exception and the input that led to the problem.When your user-interface code receives the Payload, it can examine the payload status to discover exactly what happened in the domain layer, then determine how to present the information from the domain.&lt;?php namespace App\\Blog; use Aura\\Payload\\PayloadFactory; use Aura\\Payload_Interface\\PayloadStatus; use Exception; class ApplicationService { protected $user; protected $mapper; protected $filter; protected $payloadFactory; public function __construct( User $user, BlogMapper $mapper, BlogFilter $filter, PayloadFactory $payloadFactory ) { $this-&gt;user = $user; $this-&gt;mapper = $mapper; $this-&gt;filter = $filter; $this-&gt;payloadFactory = $payloadFactory; } public function browsePosts($page = 1, $perPage = 10) { $payload = $this-&gt;payloadFactory-&gt;newInstance(); try { $posts = $this-&gt;mapper-&gt;fetchAllByPage($page, $perPage); if (! $posts) { return $payload -&gt;setStatus(PayloadStatus::NOT_FOUND) -&gt;setInput(func_get_args()); } return $payload -&gt;setStatus(PayloadStatus::FOUND) -&gt;setOutput($posts); } catch (Exception $e) { return $this-&gt;error($e, func_get_args()); } } public function readPost($id) { $payload = $this-&gt;payloadFactory-&gt;newInstance(); try { $post = $this-&gt;mapper-&gt;fetchOneById($id); if (! $post) { return $payload -&gt;setStatus(PayloadStatus::NOT_FOUND) -&gt;setInput(func_get_args()); } return $payload -&gt;setStatus(PayloadStatus::FOUND) -&gt;setOutput($post); } catch (Exception $e) { return $this-&gt;error($e, func_get_args()); } } public function editPost($id, array $input) { $payload = $this-&gt;payloadFactory-&gt;newInstance(); try { $post = $this-&gt;mapper-&gt;fetchOneById($id); if (! $post) { return $payload -&gt;setStatus(PayloadStatus::NOT_FOUND) -&gt;setInput(func_get_args()); } if (! $post-&gt;isOwnedBy($user)) { return $payload -&gt;setStatus(PayloadStatus::NOT_AUTHORIZED) -&gt;setInput(func_get_args()); } $post-&gt;setData($input); if (! $this-&gt;filter-&gt;forUpdate($post)) { return $payload -&gt;setStatus(PayloadStatus::NOT_VALID) -&gt;setInput($input) -&gt;setOutput($post) -&gt;setMessages($this-&gt;filter-&gt;getMessages()); } $this-&gt;mapper-&gt;update($post); return $payload -&gt;setStatus(PayloadStatus::UPDATED) -&gt;setOutput($post); } catch (Exception $e) { return $this-&gt;error($e, func_get_args()); } } public function addPost(array $input) { $payload = $this-&gt;payloadFactory-&gt;newInstance(); try { $post = $this-&gt;mapper-&gt;newPost($input); if (! $this-&gt;filter-&gt;forInsert($post)) { return $payload -&gt;setStatus(PayloadStatus::NOT_VALID) -&gt;setInput($input) -&gt;setOutput($post) -&gt;setMessages($this-&gt;filter-&gt;getMessages()); } $this-&gt;mapper-&gt;create($post); return $payload -&gt;setStatus(PayloadStatus::CREATED) -&gt;setOutput($post); } catch (Exception $e) { return $this-&gt;error($e, func_get_args()); } } public function deletePost($id) { $payload = $this-&gt;payloadFactory-&gt;newInstance(); try { $post = $this-&gt;mapper-&gt;fetchOneById($id); if (! $post) { return $payload -&gt;setStatus(PayloadStatus::NOT_FOUND) -&gt;setInput(func_get_args()); } if (! $post-&gt;isOwnedBy($user)) { return $payload -&gt;setStatus(PayloadStatus::NOT_AUTHORIZED) -&gt;setInput(func_get_args()); } $this-&gt;mapper-&gt;delete($post); return $payload -&gt;setStatus(PayloadStatus::DELETED) -&gt;setOutput($post); } catch (Exception $e) { return $this-&gt;error($e, func_get_args()); } } protected function error(Exception $e, array $args) { $payload = $this-&gt;payloadFactory-&gt;newInstance(); return $payload -&gt;setStatus(PayloadStatus::ERROR) -&gt;setInput($args) -&gt;setOutput($e); } } ?&gt; "},{"id":"\/packages\/3.x\/Router\/getting-started.html#3-4-1","title":"3.4.1. Getting Started","content":"Aura.Router is a web router implementation for PSR-7.You get all the router objects through a library-specific RouterContainer, which manages object creation, dependencies, and wiring for you. That means you need to instantiate the container before anything else.&lt;?php use Aura\\Router\\RouterContainer; $routerContainer = new RouterContainer(); ?&gt; You can then retrieve a Map for adding routes, a Matcher for matching the incoming request to a route, and a Generator for generating paths from routes.Let's go step-by-step to add a route, match a request against it, and dispatch it. A full working example is provided at the end of this page."},{"id":"\/packages\/3.x\/Router\/getting-started.html#3-4-1-1","title":"3.4.1.1. Adding A Route","content":"To add a route, first retrieve the Map from the RouterContainer.&lt;?php $map = $routerContainer-&gt;getMap(); ?&gt; Then call one of its route-adding methods: $map-&gt;get() adds a GET route $map-&gt;post() adds a POST route $map-&gt;patch() adds a PATCH route $map-&gt;delete() adds a DELETE route $map-&gt;options() adds a OPTIONS route $map-&gt;head() adds a HEAD route Each route-adding method takes three parameters: A $name (for when you need to generate a link from the route) A $path (with optional, named token placeholders) An optional $handler (a closure, callback, action object, controller class, etc); if you do not pass a handler, the route will use the $name parameter as the handler. For example, this route named blog.read will match against a GET request on the path \/blog\/42 (or any other {id} value). It also defines a closure as a handler for the route, using a ServerRequestInterface instance and a ResponseInterface instance as arguments.&lt;?php $map-&gt;get('blog.read', '\/blog\/{id}', function ($request, $response) { $id = (int) $request-&gt;getAttribute('id'); $response-&gt;getBody()-&gt;write(\"You asked for blog entry {$id}.\"); return $response; }); ?&gt; If you want to add a route with a custom HTTP verb, call $map-&gt;route() and follow with a fluent call to allows():&lt;?php $map-&gt;route('route-name', '\/route\/path', function () { ... }) -&gt;allows('CUSTOMVERB'); ?&gt; "},{"id":"\/packages\/3.x\/Router\/getting-started.html#3-4-1-2","title":"3.4.1.2. Matching A Request To A Route","content":"First, get the Matcher from the RouterContainer.&lt;?php $matcher = $routerContainer-&gt;getMatcher(); ?&gt; Then call the match() method to match a PSR-7 ServerRequestInterface instance to a mapped Route.For this you need an implementation of psr-7 .The most widely used one is zend-diactoros.composer require zendframework\/zend-diactoros Create an instance of ServerRequestInterface object.$request = Zend\\Diactoros\\ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); and pass $request to match method.&lt;?php \/** * @var Psr\\Http\\Message\\ServerRequestInterface $request *\/ $route = $matcher-&gt;match($request); ?&gt; "},{"id":"\/packages\/3.x\/Router\/getting-started.html#3-4-1-3","title":"3.4.1.3. Dispatching A Route","content":"This is the point at which your application takes over. The route has two properties that you are most likely to be interested in: $route-&gt;attributes is the array of attribute values captured during matching $route-&gt;handler is the handler you added to the route when you mapped it For example, with the $route in hand, you can transfer its attributes to the $request ...&lt;?php foreach ($route-&gt;attributes as $key =&gt; $val) { $request = $request-&gt;withAttribute($key, $val); } ?&gt; ... and dispatch to the route handler directly if it was a callable or closure:&lt;?php $callable = $route-&gt;handler; $response = $callable($request); ?&gt; Alternatively, if you used a class name for the handler, you can create a class from the handler and do what you like with it:&lt;?php $actionClass = $route-&gt;handler; $action = new $actionClass(); $response = $action($request); ?&gt; "},{"id":"\/packages\/3.x\/Router\/getting-started.html#3-4-1-4","title":"3.4.1.4. Handling Failure To Match","content":"When $map-&gt;match() returns empty, it means there was no matching route for the request. However, we can still discover the closest-matching, failed route, and which rule it failed to match against.Your application might do something like the following:&lt;?php $route = $matcher-&gt;match($request); if (! $route) { \/\/ get the first of the best-available non-matched routes $failedRoute = $matcher-&gt;getFailedRoute(); \/\/ which matching rule failed? switch ($failedRoute-&gt;failedRule) { case 'Aura\\Router\\Rule\\Allows': \/\/ 405 METHOD NOT ALLOWED \/\/ Send the $failedRoute-&gt;allows as 'Allow:' break; case 'Aura\\Router\\Rule\\Accepts': \/\/ 406 NOT ACCEPTABLE break; default: \/\/ 404 NOT FOUND break; } } ?&gt; "},{"id":"\/packages\/3.x\/Router\/getting-started.html#3-4-1-5","title":"3.4.1.5. Working Example","content":"The following is a working example. First, at the command line, require the necessary libraries:$ composer require aura\/router zendframework\/zend-diactoros Then create the following file as index.php:&lt;?php \/\/ set up composer autoloader require __DIR__ . '\/vendor\/autoload.php'; \/\/ create a server request object $request = Zend\\Diactoros\\ServerRequestFactory::fromGlobals( $_SERVER, $_GET, $_POST, $_COOKIE, $_FILES ); \/\/ create the router container and get the routing map $routerContainer = new Aura\\Router\\RouterContainer(); $map = $routerContainer-&gt;getMap(); \/\/ add a route to the map, and a handler for it $map-&gt;get('blog.read', '\/blog\/{id}', function ($request) { $id = (int) $request-&gt;getAttribute('id'); $response = new Zend\\Diactoros\\Response(); $response-&gt;getBody()-&gt;write(\"You asked for blog entry {$id}.\"); return $response; }); \/\/ get the route matcher from the container ... $matcher = $routerContainer-&gt;getMatcher(); \/\/ .. and try to match the request to a route. $route = $matcher-&gt;match($request); if (! $route) { echo \"No route found for the request.\"; exit; } \/\/ add route attributes to the request foreach ($route-&gt;attributes as $key =&gt; $val) { $request = $request-&gt;withAttribute($key, $val); } \/\/ dispatch the request to the route handler. \/\/ (consider using https:\/\/github.com\/auraphp\/Aura.Dispatcher \/\/ in place of the one callable below.) $callable = $route-&gt;handler; $response = $callable($request); \/\/ emit the response foreach ($response-&gt;getHeaders() as $name =&gt; $values) { foreach ($values as $value) { header(sprintf('%s: %s', $name, $value), false); } } http_response_code($response-&gt;getStatusCode()); echo $response-&gt;getBody(); Now start the built in PHP server ...$ php -S localhost:8000 -t . ... and point your browser to http:\/\/localhost:8000\/blog\/12 ."},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2","title":"3.4.2. Defining Routes","content":"Every time you add a route to the Map, you get back a Route object. The Route object is pretty powerful, and allows you to define a wide range of matching conditions. All of the Route methods are fluent, so you can chain them together."},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-1","title":"3.4.2.1. Placeholder Tokens and Default Values","content":"When you add a {token} placeholder in the path, it uses a default regular expression of ([^\/]+). Essentially, this matches everything except a slash, which of course indicates the next path segment.To define custom regular expressions for placeholder tokens, use the tokens() method.&lt;?php $map-&gt;get('blog.read', '\/blog\/{id}') -&gt;tokens(['id' =&gt; '\\d+']) ?&gt; The Route object does not predefine any tokens for you. One that you may find useful is a {format} token, to specify an optional dot-format extension at the end of a file name:&lt;?php $map-&gt;get('blog.read', '\/blog\/{id}{format}') -&gt;tokens([ 'id' =&gt; '\\d+', 'format' =&gt; '(\\.[^\/]+)?', ]); ?&gt; If no default value is specified for a placeholder token, the corresponding attribute value will be null. To set your own default values, call the defaults() method.&lt;?php $map-&gt;post('blog.archive', '\/blog\/{id}{format}') -&gt;defaults([ 'format' =&gt; '.html', ]); ?&gt; "},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-2","title":"3.4.2.2. Custom Placeholder Token Matching","content":"Sometimes it's useful to be able to do custom matching of placeholder tokens.To define a custom callback for placeholder tokens, use the tokens() method.The following will verify that date is a valid DateTime format:&lt;?php $map-&gt;get('\/calendar\/from\/{date}') -&gt;tokens([ 'date' =&gt; function ($date, $route, $request) { try { new \\DateTime($date); return true; } catch(\\Exception $e) { return false; } } ]); "},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-3","title":"3.4.2.3. Optional Placeholder Tokens","content":"Sometimes it is useful to have a route with optional placeholder tokens for attributes. None, some, or all of the optional values may be present, and the route will still match.To specify optional attributes, use the notation {\/attribute1,attribute2,attribute3} in the path. For example:&lt;?php $map-&gt;get('archive', '\/archive{\/year,month,day}') -&gt;tokens([ 'year' =&gt; '\\d{4}', 'month' =&gt; '\\d{2}', 'day' =&gt; '\\d{2}', ]); ?&gt; Note that the leading slash separator is inside the placeholder token, not outside.With that, the following paths will all match the 'archive' route, and set the attribute values accordingly: \/archive : ['year' =&gt; null, 'month' =&gt; null, 'day' = null] \/archive\/1979 : ['year' =&gt; '1979', 'month' =&gt; null, 'day' = null] \/archive\/1979\/11 : ['year' =&gt; '1979', 'month' =&gt; '11', 'day' = null] \/archive\/1979\/11\/07 : ['year' =&gt; '1979', 'month' =&gt; '11', 'day' = '07'] Optional attributes are sequentially optional. This means that, in the above example, you cannot have a \"day\" without a \"month\", and you cannot have a \"month\" without a \"year\".You can have only one set of optional attributes in a route path.Optional attributes belong at the end of a route path. Placing them elsewhere may result in unexpected behavior."},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-4","title":"3.4.2.4. Wildcard Attributes","content":"Sometimes it is useful to allow the trailing part of the path be anything at all. To allow arbitrary trailing path segments on a route, call the wildcard() method. This will let you specify the attribute name under which the arbitrary trailing values will be stored.&lt;?php $map-&gt;get('wild', '\/wild') -&gt;wildcard('card'); ?&gt; All slash-separated path segments after the {id} will be captured as an array in the in wildcard attribute. For example: \/wild : ['card' =&gt; []] \/wild\/foo : ['card' =&gt; ['foo']] \/wild\/foo\/bar : ['card' =&gt; ['foo', 'bar']] \/wild\/foo\/bar\/baz : ['card' =&gt; ['foo', 'bar', 'baz']] "},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-5","title":"3.4.2.5. Host Matching","content":"You can limit a route to specific hosts with the host() method and a regular expression. The following example will only match when the request is on example.com domain:&lt;?php $map-&gt;get('blog.browse', '\/blog') -&gt;host('example.com'); ?&gt; (Dots in the regular expression will automatically be escaped for you.)You can use placeholder tokens and default values in the host specification, and capture those values into route attributes. The following matches *.example.com and captures the subdomain value as a route attribute:&lt;?php $map-&gt;get('blog.browse', '\/blog') -&gt;host('{subdomain}.?example.com'); ?&gt; "},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-6","title":"3.4.2.6. Accept Headers","content":"The accepts() method adds to a list of content types that the route handler can be expected to return.&lt;?php $map-&gt;get('blog.browse', '\/blog') -&gt;accepts([ 'application\/json', 'application\/xml', 'text\/csv', ]); ?&gt; Note that this is not a content negotiation method. It is only a pro-forma check to see if one of the specified types is present in the Accept header with a non-zero q value. The route handler, or some other layer, should perform content negotation proper."},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-7","title":"3.4.2.7. Multiple HTTP Verbs","content":"The allows() method adds to the allowed HTTP verbs for the route.&lt;?php $map-&gt;post('blog.edit', '\/blog\/{id}') -&gt;allows(['PATCH', 'PUT']) ?&gt; "},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-8","title":"3.4.2.8. Secure Protocols","content":"You can use the secure() method to specify that a route should only match a secure protcol. (Specifically, $_SERVER['HTTPS'] must be on, or the request must be on port 443.)&lt;?php $map-&gt;post('blog.edit', '\/blog\/{id}') -&gt;secure(); ?&gt; You can call secure(false) to limit the route to only non-secure protocols. Calling secure(null) causes the route to ignore the protocol security."},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-9","title":"3.4.2.9. Non-Routable Routes","content":"Sometimes you will want to have a route in the Map that is used only for generating paths, and not for matching to handlers. In this case, you can call isRoutable(false). (This is rare but useful.)"},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-10","title":"3.4.2.10. Authentication","content":"Each route instance has a special-purpose method and property, auth() and $auth, for you to store authentication\/authorization values. These values are entirely arbitrary, and are best used with custom matching rules of your own design.&lt;?php $map-&gt;post('blog.admin', '\/blog\/admin') -&gt;auth([ 'isAdmin' =&gt; true, ]); ?&gt; "},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-11","title":"3.4.2.11. Custom Extras","content":"Other, custom data about the route can be stored using the extras() method. Pass an array of key-value pairs and it will be merged with any other custom data already stored.&lt;?php $map-&gt;post('blog.other', '\/blog\/other') -&gt;extras([ 'foo' =&gt; true, 'bar' =&gt; false, ]); ?&gt; You can then use these extra values in your own custom matching rules."},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-12","title":"3.4.2.12. Route-Specific Matching Logic","content":"If you need a special matching logic on an individual Route, you can use the special() method to add a callable to the Route for matching. The method should return a boolean to indicate if the Route is a match or not.&lt;?php $map-&gt;get('foo', '\/foo\/bar\/{baz}') -&gt;special(function ($request, $route) { if ($request-&gt;getHeader('Foo') == 'bar') { $route-&gt;extras(['foo' =&gt; true]); return true; } return false; } }) ?&gt;  N.b.: You can also create a Rule that applies to all routes; see this section for more. "},{"id":"\/packages\/3.x\/Router\/defining-routes.html#3-4-2-13","title":"3.4.2.13. Default Map Route Specifications","content":"You can call any of the above Route methods on the Map. When you do so, the Map will then use those as the defaults for every route you add thereafter. This is useful for defining a base set of placeholder token expressions, default values, and so on.&lt;?php \/\/ define defaults for all routes added hereafter $map-&gt;tokens([ 'id' =&gt; '\\d+', 'format' =&gt; '(\\.[^\/]+)?', ])-&gt;defaults([ 'format' =&gt; '.json', ])-&gt;host( '{subdomain}.?example.com' )-&gt;accepts([ 'application\/json', 'application\/xml', 'text\/html', ]); \/\/ each added route now uses the map defaults $map-&gt;get('blog.browse', '\/blog'); $map-&gt;get('blog.read', '\/blog\/{id}{format}'); $map-&gt;patch('blog.edit', '\/blog\/{id}'); $map-&gt;post('blog.add', '\/blog'); $map-&gt;delete('blog.delete', '\/blog\/{id}'); ?&gt; "},{"id":"\/packages\/3.x\/Router\/attaching-route-groups.html#3-4-3","title":"3.4.3. Attaching Route Groups","content":"You can add a series of routes under a single master path in the Map using the Map::attach() method with a name prefix, path prefix, and a callable to perform the attachment logic. The callable must take a Map as its only argument.For example, if you want all your blog-related routes to be mounted at \/blog in your application, and all of their names to be prefixed with blog., you can do the following:&lt;?php $namePrefix = 'blog.'; $pathPrefix = '\/blog'; $map-&gt;attach($namePrefix, $pathPrefix, function ($map) { $map-&gt;tokens([ 'id' =&gt; '\\d+', 'format' =&gt; '(\\.json|\\.atom|\\.html)?' ]); $map-&gt;defaults([ 'format' =&gt; '.html', ]); $map-&gt;get('browse', ''); $map-&gt;get('read', '\/{id}{format}'); $map-&gt;patch('edit', '\/{id}'); $map-&gt;put('add', ''); $map-&gt;delete('delete', '\/{id}'); }); ?&gt; Each of the route names will be prefixed with 'blog.', and each of the route paths will be prefixed with \/blog, so the effective route names and paths become: blog.browse =&gt; \/blog blog.read =&gt; \/blog\/{id}{format} blog.edit =&gt; \/blog\/{id} blog.add =&gt; \/blog\/{id} blog.delete =&gt; \/blog\/{id} Any defaults you set on the $map inside the callable will revert to their previous values when the callable is complete."},{"id":"\/packages\/3.x\/Router\/generating-paths.html#3-4-4","title":"3.4.4. Generating Paths From Routes","content":"To generate a path from a route so that you can create links, first retrieve the Generator from the RouterContainer.&lt;?php $generator = $routerContainer-&gt;getGenerator(); ?&gt; You can then call Generator::generate() with the route name and optional attributes to use for named placeholder tokens.&lt;?php $path = $generator-&gt;generate('blog.read', ['id' =&gt; 42]); $href = htmlspecialchars($path, ENT_QUOTES, 'UTF-8'); echo \"&lt;a href=\\\"{$href}\\\"&gt;Blog link&lt;\/a&gt;\"; ?&gt; The generate() method will URL-encode the placeholder token values automatically. Use the generateRaw() method to leave them un-encoded.If there are named placeholder tokens in path without corresponding attributes, those tokens will not be replaced, leaving the placeholder token in the path.If there are attributes without corresponding tokens, those attributes will not be added to the path."},{"id":"\/packages\/3.x\/Router\/generating-paths.html#3-4-4-1","title":"3.4.4.1. Optional Attributes","content":"If you generate() a path from a route with optional attributes, the attributes will be filled in if they are present in the data for the link. Remember, the optional attributes are sequentially optional, so the attributes will not be filled in after the first missing one:&lt;?php $map-&gt;route('archive', '\/archive{\/year,month,day}') -&gt;tokens([ 'year' =&gt; '\\d{4}', 'month' =&gt; '\\d{2}', 'day' =&gt; '\\d{2}' ]); $link = $generator-&gt;generate('archive', [ 'year' =&gt; '1979', 'month' =&gt; '11', ]); \/\/ \"\/archive\/1979\/11\" ?&gt; "},{"id":"\/packages\/3.x\/Router\/generating-paths.html#3-4-4-2","title":"3.4.4.2. Wildcard Attributes","content":"If you generate() a link with wildcard attributes, the wildcard key in the data will be used for the trailing arbitrary attribute values:&lt;?php $map-&gt;route('wild_post', '\/post\/{id}') -&gt;wildcard('other'); $link = $generator-&gt;generate('wild_post', [ 'id' =&gt; '88', 'other' =&gt; [ 'foo', 'bar', 'baz', ] ]); \/\/ \"\/post\/88\/foo\/bar\/baz\" ?&gt; "},{"id":"\/packages\/3.x\/Router\/custom-maps.html#3-4-5-1","title":"3.4.5.1. Extending the Map Class","content":"You might want to extend the Map class to provide convenience methods specific to your application. As with writing a custom matching rule, this is a bit involved but not difficult: Write your Map extended class. Add your extended class factory to the RouterContainer. Use the RouterContainer as normal, and it will return your custom Map class. For example, you may wish to have a resource() method that automatically attaches a series of routes all at once for a given route name and route path. First, write your extension of the Map class:&lt;?php use Aura\\Router\\Map; class MyResourceMap extends Map { public function resource($namePrefix, $pathPrefix) { return $this-&gt;attach($namePrefix, $pathPrefix, function ($map) { $map-&gt;get('browse', ''); $map-&gt;get('read', '\/{id}'); $map-&gt;patch('edit', '\/{id}'); $map-&gt;post('add', ''); $map-&gt;delete('delete', '\/{id}'); }); } } ?&gt; Then tell the RouterContainer how to create your extended class using a factory callable:&lt;?php use Aura\\Router\\Route; $routerContainer-&gt;setMapFactory(function () { return new MyResourceMap(new Route()); }); ?&gt; Now you can get the Map from the RouterContainer, and it will be your custom extended class:&lt;?php $map = $routerContainer-&gt;getMap(); echo get_class($map); \/\/ \"ResourceMap\" ?&gt; "},{"id":"\/packages\/3.x\/Router\/custom-maps.html#3-4-5-2","title":"3.4.5.2. Extending The Route Class","content":"Likewise, you may only need to add special parameters to the routes themselves, without needing to change the Map logic. This too is a bit involved but not difficult: Write your Route extended class. Add your extended class factory to the RouterContainer. Use the RouterContainer as normal, and it will use your custom Route for the Map. For example, you may need to add a model() method that specifes the model to use with the handler. First, write your extended Route class:&lt;?php use Aura\\Router\\Route; class ModelRoute extends Route { protected $model; public function model($model) { $this-&gt;model = $model; return $this; } } ?&gt; Then tell the RouterContainer how to create your extended class using a factory callable:&lt;?php use ModelRoute; $routerContainer-&gt;setRouteFactory(function () { return new ModelRoute(); }); ?&gt; Now you can get the Map from the RouterContainer, and it will use your custom extended route object when adding routes:&lt;?php $map = $routerContainer-&gt;getMap(); $route = $map-&gt;get('foo', '\/path\/to\/foo')-&gt;model('MyModelClass'); echo get_class($route); \/\/ \"ModelRoute\" echo $route-&gt;model; \/\/ \"MyModelClass\" ?&gt; Because the Map object proxies unknown method calls to the underlying route object, your new methods will also be honored by the Map object to set route defaults:&lt;?php $map-&gt;model('DefaultModelClass'); $route = $map-&gt;get('foo', '\/path\/to\/foo'); echo get_class($route); \/\/ \"ModelRoute\" echo $route-&gt;model; \/\/ \"DefaultModelClass\" ?&gt; "},{"id":"\/packages\/3.x\/Router\/custom-maps.html#3-4-5-3","title":"3.4.5.3. Automated Route Caching and Building","content":"You may wish to build your route map from some external source. Alternatively, you might want to cache your route map for production deployments so that you do not have to add the routes from scratch on each page load.To effect this or other automated map-building functionality, call the RouterContainer::setMapBuilder() method and pass a builder callable to set up the Map before the container returns it. The builder callable should take a Map instance as its only argument.The following is a naive example for file-based caching and restoring of Map routes. It uses the Map::setRoutes() and Map::getRoutes() methods to work with the array of mapped route objects.&lt;?php $routerContainer-&gt;setMapBuilder(function ($map) { \/\/ the cache file location $cache = '\/path\/to\/routes.cache'; \/\/ does the cache exist? if (file_exists($cache)) { \/\/ restore from the cache $routes = unserialize(file_get_contents($cache)); $map-&gt;setRoutes($routes); } else { \/\/ build the routes on the map ... $map-&gt;get(...); $map-&gt;post(...); \/\/ ... then save them to the cache for the next page load $routes = $map-&gt;getRoutes(); file_put_contents($cache, serialize($routes)); } }); ?&gt;  N.b.: If there are closures in the Route objects (e.g. in the handlers), you will not be able to serialize the routes for caching. This is because closures cannot be serialized by PHP. Consider using non-closure callables instead. Now when you call $routerContainer-&gt;getMap(), the container will automatically call the map-builder logic and apply it to the $map before returning it."},{"id":"\/packages\/3.x\/Router\/custom-matching.html#3-4-6-1","title":"3.4.6.1. Writing A Custom Rule","content":"Writing a custom matching rule, say one that checks the authentication state, is a bit involved but not difficult. Write a rule class that implements the RuleInterface. Get the RuleIterator from the RouterContainer and append() or prepend() your new Rule. (You can also wrap it in a callable to make it lazy-loaded, such as with Aura.Di Lazy instances.) Use the Matcher as normal. Here is a naive rule that checks to see if the request has a particular header set; the rule passes if it is, and fails if it does not. The header value is captured into the route attributes.&lt;?php use Aura\\Router\\Route; use Aura\\Router\\Rule\\RuleInterface; use Psr\\Http\\Message\\ServerRequestInterface; class ApiVersionRule implements RuleInterface { public function __invoke(ServerRequestInterface $request, Route $route) { $versions = $request-&gt;getHeader('X-Api-Version'); if (count($versions) !== 1) { return false; } $route-&gt;attributes(['apiVersion' =&gt; $versions[0]]); return true; } } ?&gt; You can then prepend() or append() the rule to the RuleIterator from the RouterContainer. (Prepended rules get run first, appended ones last.)&lt;?php $ruleIterator = $routerContainer-&gt;getRuleIterator(); $ruleIterator-&gt;append(new ApiVersionRule()); ?&gt; Then you can run the Matcher as normal, and your new rule will be honored.&lt;?php $matcher = $routerContainer-&gt;getMatcher(); $route = $matcher-&gt;match($request); ?&gt; "},{"id":"\/packages\/3.x\/Router\/custom-matching.html#3-4-6-2","title":"3.4.6.2. Setting Rules","content":"If you want, you can set all the matching rules into the RouterContainer in advance. They will be injected into the RuleIterator and thereby into the Matcher automatically.For good or bad, you need to pass the entire set of rules, not just your custom ones. This is because you need to include not just your own rules, but the default ones as well. It would look something like this:use Aura\\Router\\Rule; $routerContainer-&gt;getRuleIterator()-&gt;set([ \/\/ default rules new Rule\\Secure(), new Rule\\Host(), new Rule\\Path(), new Rule\\Allows(), new Rule\\Accepts(), new Rule\\Special(), \/\/ custom rule new ApiVersionRule() ]);  N.b. You can review the RouterContainer::getRules() method to see the default rule set. Setting all the rules at once means you can place your rule exactly where you want. If you want your custom rule to go right in the middle of the default set, you could do something like this:use Aura\\Router\\Rule; $routerContainer-&gt;getRuleIterator()-&gt;set([ new Rule\\Secure(), new Rule\\Host(), new ApiVersionRule(), \/\/ custom rule in the middle new Rule\\Path(), new Rule\\Allows(), new Rule\\Accepts(), new Rule\\Special(), ]); Finally, if you feel you don't need some rules, you can omit them from the list. For example, you may only care about path and HTTP method matching:use Aura\\Router\\Rule; $routerContainer-&gt;getRuleIterator()-&gt;set([ new Rule\\Path(), new Rule\\Allows(), ]); "},{"id":"\/packages\/3.x\/Router\/other-topics.html#3-4-7-1","title":"3.4.7.1. Catchall Routes","content":"You can use optional placeholder tokens to create a generic catchall route:&lt;?php $map-&gt;get('catchall', '{\/controller,action,id}') -&gt;defaults([ 'controller' =&gt; 'index', 'action' =&gt; 'browse', 'id' =&gt; null, ]); ?&gt; That will match these paths, with these attribute values: \/ : ['controller' =&gt; 'index', 'action' =&gt; 'browse', 'id' =&gt; null] \/foo : ['controller' =&gt; 'foo', 'action' =&gt; 'browse', 'id' =&gt; null] \/foo\/bar : ['controller' =&gt; 'foo', 'action' =&gt; 'bar', 'id' =&gt; null] \/foo\/bar\/42 : ['controller' =&gt; 'foo', 'action' =&gt; 'bar', 'id' =&gt; '42'] Because routes are matched in the order they are added, the catchall should be the last route in the Map so that more specific routes may match first."},{"id":"\/packages\/3.x\/Router\/other-topics.html#3-4-7-2","title":"3.4.7.2. Logging","content":"You may wish to log the Matcher activity using a PSR-3 compliant logger. You can tell the RouterContainer how to create a logger instance by passing a factory callable to setLoggerFactory().&lt;?php $routerContainer-&gt;setLoggerFactory(function () { return new Psr3Logger(); }); ?&gt; The RouterContainer will use that callable to create the logger and inject it into the Matcher. You can then review the debug-level logs for Matcher activity."},{"id":"\/packages\/3.x\/Router\/other-topics.html#3-4-7-3","title":"3.4.7.3. Base Path","content":"The router assumes that all URL paths begin at the top document root, but sometimes you will need them to begin in a subdirectory. In that case, you can instantiate the RouterContainer with an explicit base path; this base path will be used as a prefix for all route matching and path generation.&lt;?php \/\/ create a container with a base path $routerContainer = new RouterContainer('\/path\/to\/subdir'); \/\/ define a route as normal $map = $routerContainer-&gt;getMap(); $map-&gt;get('blog.read', '\/blog\/{id}', ...); \/\/ if the incoming request is for \"\/path\/to\/subdir\/blog\/{id}\" \/\/ then the route will match. $matcher = $routerContainer-&gt;getMatcher(); $route = $matcher-&gt;match($request); \/\/ generating a path from the route will add the base path automatically $generator = $routerContainer-&gt;getGenerator(); $path = $generator-&gt;generate('blog.read', ['id' =&gt; 88]); echo $path; \/\/ \"\/path\/to\/subdir\/blog\/88\" ?&gt; "},{"id":"\/packages\/3.x\/Router\/other-topics.html#3-4-7-4","title":"3.4.7.4. Route Helpers","content":"You may wish to be able to generate route URLs from your views. Helper\\Route and Helper\\RouteRaw are available to assist you in creating these URLs.The invocation of the helpers accept the same parameters as the Generator generate() method.&lt;?php \/\/ create a container with a base path $routerContainer = new RouterContainer('\/path\/to\/subdir'); \/\/ define a route as normal $map = $routerContainer-&gt;getMap(); $map-&gt;get('blog.read', '\/blog\/{slug}', ...); \/\/ get the helper from the container $routeHelper = $routerContainer-&gt;newRouteHelper(); \/\/ use the helper in a view; note how the URL is escaped echo $routeHelper('blog.read', [ 'slug' =&gt; 'my title' ]); \/\/ \"\/path\/to\/subdir\/blog\/my%20title\" \/\/ get the raw helper from the container $routeRawHelper = $routerContainer-&gt;newRouteRawHelper(); \/\/ use the raw helper; note that no URL escaping is applied echo $routeRawHelper('blog.read', [ 'slug' =&gt; 'my title' ]); \/\/ \"\/path\/to\/subdir\/blog\/my title\" "},{"id":"\/packages\/3.x\/Sql\/getting-started.html#3-5-1-1","title":"3.5.1.1. Instantiation","content":"You can instantiate ExtendedPdo so that it uses lazy connection, or you can use DecoratedPdo to decorate an existing PDO instance."},{"id":"\/packages\/3.x\/Sql\/getting-started.html#3-5-1-1-1","title":"3.5.1.1.1. Lazy Connection Instance","content":"Instantiation is the same as with the native PDO class: pass a data source name, username, password, and driver options. There is one additional parameter that allows you to pass attributes to be set after the connection is made.use Aura\\Sql\\ExtendedPdo; $pdo = new ExtendedPdo( 'mysql:host=localhost;dbname=test', 'username', 'password', [], \/\/ driver attributes\/options as key-value pairs [] \/\/ queries to execute after connection ); Whereas the native PDO connects on instantiation, ExtendedPdo does not connect immediately. Instead, it connects only when you call a method that actually needs the connection to the database; e.g., on query().If you want to force a connection, call the connect() method.\/\/ does not connect to the database $pdo = new ExtendedPdo( 'mysql:host=localhost;dbname=test', 'username', 'password' ); \/\/ automatically connects $pdo-&gt;exec('SELECT * FROM test'); \/\/ explicitly forces a connection $pdo-&gt;connect(); If you want to explicitly force a disconnect, call the disconnect() method.\/\/ explicitly forces disconnection $pdo-&gt;disconnect(); Doing so will close the connection by unsetting the internal PDO instance. However, calling an ExtendedPdo method that implicitly establishes a connection, such as query() or one of the fetch*() methods, will automatically re-connect to the database."},{"id":"\/packages\/3.x\/Sql\/getting-started.html#3-5-1-1-2","title":"3.5.1.1.2. Decorator Instance","content":"The DecoratedPdo class can be used to decorate an existing PDO connection with the ExtendedPdo methods. To do so, instantiate DecoratedPdo by passing an existing PDO connection:use Aura\\Sql\\DecoratedPdo; $pdo = new PDO(...); $decoratedPdo = new DecoratedPdo($pdo); The decorated PDO instance now provides all the ExtendedPdo functionality (aside from lazy connection, which is not possible since the PDO instance by definition has already connected).Decoration of this kind can be useful when you have access to an existing PDO connection managed elsewhere in your application. N.b.: The disconnect() method will not work on decorated PDO connections, since DecoratedPdo did not create the connection itself. You will need to manage the decorated PDO instance yourself in that case. "},{"id":"\/packages\/3.x\/Sql\/getting-started.html#3-5-1-2","title":"3.5.1.2. Array Quoting","content":"The native PDO quote() method will not quote arrays. This makes it difficult to bind an array to something like an IN (...) condition in SQL. However, ExtendedPdo recognizes arrays and converts them into comma- separated quoted strings.\/\/ the array to be quoted $array = array('foo', 'bar', 'baz'); \/\/ the native PDO way: \/\/ \"Warning: PDO::quote() expects parameter 1 to be string, array given\" $pdo = new PDO(...); $cond = 'IN (' . $pdo-&gt;quote($array) . ')'; \/\/ the ExtendedPdo way: \/\/ \"IN ('foo', 'bar', 'baz')\" $pdo = new ExtendedPdo(...); $cond = 'IN (' . $pdo-&gt;quote($array) . ')'; "},{"id":"\/packages\/3.x\/Sql\/getting-started.html#3-5-1-3","title":"3.5.1.3. The perform() Method","content":"The ExtendedPdo::perform() method will prepare a query with bound values in a single step. Also, because the native PDO does not deal with bound array values, perform() modifies the query string to expand the array-bound placeholder into multiple placeholders.\/\/ the array to be quoted $array = array('foo', 'bar', 'baz'); \/\/ the statement to prepare $stm = 'SELECT * FROM test WHERE foo IN (:foo)' \/\/ the native PDO way does not work (PHP Notice: Array to string conversion) $pdo = new ExtendedPdo(...); $sth = $pdo-&gt;prepare($stm); $sth-&gt;bindValue('foo', $array); \/\/ the ExtendedPdo way allows a single call to prepare and execute the query. \/\/ it quotes the array and expands the array placeholder directly in the \/\/ query string. $pdo = new ExtendedPdo(...); $bind_values = array('foo' =&gt; $array); $sth = $pdo-&gt;perform($stm, $bind_values); echo $sth-&gt;queryString; \/\/ the query string has been modified by ExtendedPdo to become \/\/ \"SELECT * FROM test WHERE foo IN (:foo_1, :foo_2, :foo_3)\" Finally, note that array quoting works only via the perform() method, not on returned PDOStatement instances."},{"id":"\/packages\/3.x\/Sql\/fetch.html#3-5-2","title":"3.5.2. The fetch*() Methods","content":"ExtendedPdo comes with fetch*() methods to help reduce boilerplate code. Instead of issuing prepare(), a series of bindValue() calls, execute(), and then fetch*() on a PDOStatement, you can bind values and fetch results in one call on ExtendedPdo directly. (The fetch*() methods use perform() internally, so quoting-and-replacement of array placeholders is supported.)$stm = 'SELECT * FROM test WHERE foo = :foo AND bar = :bar'; $bind = array('foo' =&gt; 'baz', 'bar' =&gt; 'dib'); \/\/ the native PDO way to \"fetch all\" where the result is a sequential array \/\/ of rows, and the row arrays are keyed on the column names $pdo = new PDO(...); $sth = $pdo-&gt;prepare($stm); $sth-&gt;execute($bind); $result = $sth-&gt;fetchAll(PDO::FETCH_ASSOC); \/\/ the ExtendedPdo way to do the same kind of \"fetch all\" $pdo = new ExtendedPdo(...); $result = $pdo-&gt;fetchAll($stm, $bind); \/\/ fetchAssoc() returns an associative array of all rows where the key is the \/\/ first column, and the row arrays are keyed on the column names $result = $pdo-&gt;fetchAssoc($stm, $bind); \/\/ fetchGroup() is like fetchAssoc() except that the values aren't wrapped in \/\/ arrays. Instead, single column values are returned as a single dimensional \/\/ array and multiple columns are returned as an array of arrays \/\/ Set style to PDO::FETCH_NAMED when values are an array \/\/ (i.e. there are more than two columns in the select) $result = $pdo-&gt;fetchGroup($stm, $bind, $style = PDO::FETCH_COLUMN) \/\/ fetchObject() returns the first row as an object of your choosing; the \/\/ columns are mapped to object properties. an optional 4th parameter array \/\/ provides constructor arguments when instantiating the object. $result = $pdo-&gt;fetchObject($stm, $bind, 'ClassName', array('ctor_arg_1')); \/\/ fetchObjects() returns an array of objects of your choosing; the \/\/ columns are mapped to object properties. an optional 4th parameter array \/\/ provides constructor arguments when instantiating the object. $result = $pdo-&gt;fetchObjects($stm, $bind, 'ClassName', array('ctor_arg_1')); \/\/ fetchOne() returns the first row as an associative array where the keys \/\/ are the column names $result = $pdo-&gt;fetchOne($stm, $bind); \/\/ fetchPairs() returns an associative array where each key is the first \/\/ column and each value is the second column $result = $pdo-&gt;fetchPairs($stm, $bind); \/\/ fetchValue() returns the value of the first row in the first column $result = $pdo-&gt;fetchValue($stm, $bind); \/\/ fetchAffected() returns the number of affected rows $stm = \"UPDATE test SET incr = incr + 1 WHERE foo = :foo AND bar = :bar\"; $row_count = $pdo-&gt;fetchAffected($stm, $bind); "},{"id":"\/packages\/3.x\/Sql\/yield.html#3-5-3","title":"3.5.3. The yield*() Methods","content":"ExtendedPdo comes with yield*() methods to help reduce memory usage. Whereas many fetch*() methods collect all the query result rows before returning them all at once, the equivalent yield*() methods generate one result row at a time. For example:$stm = 'SELECT * FROM test WHERE foo = :foo AND bar = :bar'; $bind = array('foo' =&gt; 'baz', 'bar' =&gt; 'dib'); \/\/ like fetchAll(), each row is an associative array foreach ($pdo-&gt;yieldAll($stm, $bind) as $row) { \/\/ ... } \/\/ like fetchAssoc(), each key is the first column, \/\/ and the row is an associative array foreach ($pdo-&gt;yieldAssoc($stm, $bind) as $key =&gt; $row) { \/\/ ... } \/\/ like fetchCol(), each result is a value from the first column foreach ($pdo-&gt;yieldCol($stm, $bind) as $val) { \/\/ ... } \/\/ like fetchObjects(), each result is an object; pass an optional \/\/ class name and optional array of constructor arguments. $class = 'ClassName'; $args = ['arg0', 'arg1', 'arg2']; foreach ($pdo-&gt;yieldObjects($stm, $bind, $class, $args) as $object) { \/\/ ... } \/\/ like fetchPairs(), each result is a key-value pair from the \/\/ first and second columns foreach ($pdo-&gt;yieldPairs($stm, $bind) as $key =&gt; $val) { \/\/ ... } "},{"id":"\/packages\/3.x\/Sql\/profiling-logging.html#3-5-4","title":"3.5.4. Profiling and Logging","content":"It is often useful to see what queries have been executed, where they were issued from in the codebase, and how long they took to complete. As such, ExtendedPdo comes with a profiler that logs to any PSR-3 implementation. The profiler defaults to a naive memory-based logger for debugging purposes."},{"id":"\/packages\/3.x\/Sql\/profiling-logging.html#3-5-4-1","title":"3.5.4.1. Using The Profiler","content":"You can activate and deactivate the profiler using the Profiler::setActive() method. (Messages are not logged when the profiler is not active.)You can then examine the log messages using the underlying log system; in the below example, we use the default MemoryLogger implementation.&lt;?php \/\/ activate the profiler $pdo-&gt;getProfiler()-&gt;setActive(true); \/\/ ... \/\/ query(), fetch(), beginTransaction()\/commit()\/rollback() etc. \/\/ ... \/\/ now retrieve the array messages from the default memory logger: $messages = $pdo-&gt;getProfiler()-&gt;getLogger()-&gt;getMessages(); print_r($messages); "},{"id":"\/packages\/3.x\/Sql\/profiling-logging.html#3-5-4-2","title":"3.5.4.2. Other Logger Implementations","content":"You can set your own profiler and PSR-3 logger implementation using the ExtendedPdo::setProfiler() method.use Aura\\Sql\\Profiler\\Profiler; $myLogger = new Psr3LoggerImplementation(); $pdo-&gt;setProfiler(new Profiler($myLogger)); "},{"id":"\/packages\/3.x\/Sql\/profiling-logging.html#3-5-4-3","title":"3.5.4.3. Profiler Log Messages","content":"Profiler log messages, by default, will match this format:{function} ({duration} seconds): {statement} {backtrace} You can customize the message format using the Profiler::setLogFormat() method, like so:$pdo-&gt;getProfiler()-&gt;setLogFormat(\"{duration}: {function} {statement}\") The context keys are: {function}: The method that was called on ExtendedPdo that created the profile entry. {start}: The microtime when the profile began. {finish}: The microtime when the profile ended. {duration}: The profile duration, in seconds. {statement}: The query string that was issued, if any. (Methods like connect() and rollBack() do not send query strings.) {values}: The values bound to the statement, if any. {backtrace}: An exception stack trace indicating where the query was issued from in the codebase. "},{"id":"\/packages\/3.x\/Sql\/profiling-logging.html#3-5-4-4","title":"3.5.4.4. Profiler Log Level","content":"By default, all messages are logged at the DEBUG level. You can change the logging level with the Profiler::setLogLevel() method:use Psr\\Log\\LogLevel; $pdo-&gt;getProfiler()-&gt;setLogLevel(LogLevel::INFO); Likewise, you can get the current log level with Profiler::getLogLevel()."},{"id":"\/packages\/3.x\/Sql\/connection-locator.html#3-5-5","title":"3.5.5. Connection Locator","content":"Frequently, high-traffic PHP applications use multiple database servers, generally one for writes, and one or more for reads. The ConnectionLocator allows you to define multiple ExtendedPdo objects for lazy-loaded read and write connections. It will create the connections only when they are when called. The creation logic is wrapped in a callable."},{"id":"\/packages\/3.x\/Sql\/connection-locator.html#3-5-5-1","title":"3.5.5.1. Runtime Configuration","content":"First, create the ConnectionLocator:use Aura\\Sql\\ExtendedPdo; use Aura\\Sql\\ConnectionLocator; $connections = new ConnectionLocator(); Now add a default connection; this will be used when a read or write connection is not defined. (This is also useful for setting up connection location in advance of actually having multiple database servers.)$connections-&gt;setDefault(function () { return new ExtendedPdo( 'mysql:host=default.db.localhost;dbname=database', 'username', 'password' ); }); Next, add as many named read and write connections as you like:\/\/ the write (master) server $connections-&gt;setWrite('master', function () { return new ExtendedPdo( 'mysql:host=master.db.localhost;dbname=database', 'username', 'password' ); }); \/\/ read (slave) #1 $connections-&gt;setRead('slave1', function () { return new ExtendedPdo( 'mysql:host=slave1.db.localhost;dbname=database', 'username', 'password' ); }); \/\/ read (slave) #2 $connections-&gt;setRead('slave2', function () { return new ExtendedPdo( 'mysql:host=slave2.db.localhost;dbname=database', 'username', 'password' ); }); \/\/ read (slave) #3 $connections-&gt;setRead('slave3', function () { return new ExtendedPdo( 'mysql:host=slave3.db.localhost;dbname=database', 'username', 'password' ); }); Finally, retrieve a connection from the locator when you need it. This will create the connection (if needed) and then return it. getDefault() will return the default connection. getRead() will return a named read connection; if no name is specified, it will return a random read connection. If no read connections are defined, it will return the default connection. getWrite() will return a named write connection; if no name is specified, it will return a random write connection. If no write connections are defined, it will return the default connection. $read = $connections-&gt;getRead(); $results = $read-&gt;fetchAll('SELECT * FROM table_name LIMIT 10'); "},{"id":"\/packages\/3.x\/Sql\/connection-locator.html#3-5-5-2","title":"3.5.5.2. Construction-Time Configuration","content":"The ConnectionLocator can be configured with all its connections at construction time; this is useful with dependency injection mechanisms.use Aura\\Sql\\ConnectionLocator; use Aura\\Sql\\ExtendedPdo; \/\/ default connection $default = function () { return new ExtendedPdo( 'mysql:host=default.db.localhost;dbname=database', 'username', 'password' ); }; \/\/ read connections $read = array( 'slave1' =&gt; function () { return new ExtendedPdo( 'mysql:host=slave1.db.localhost;dbname=database', 'username', 'password' ); }, 'slave2' =&gt; function () { return new ExtendedPdo( 'mysql:host=slave2.db.localhost;dbname=database', 'username', 'password' ); }, 'slave3' =&gt; function () { return new ExtendedPdo( 'mysql:host=slave3.db.localhost;dbname=database', 'username', 'password' ); }, ); \/\/ write connection $write = array( 'master' =&gt; function () { return new ExtendedPdo( 'mysql:host=master.db.localhost;dbname=database', 'username', 'password' ); }, ); \/\/ configure locator at construction time $connections = new ConnectionLocator($default, $read, $write); "},{"id":"\/packages\/3.x\/Sql\/upgrade.html#3-5-6","title":"3.5.6. 3.x Upgrade Notes","content":"The vast majority of changes and breaks from the 2.x version are \"under the hood,\" so to speak. The main functionality methods (query(), exec(), perform(), fetch*(), yield*(), etc.) are unchanged and work just the same as in 2.x.The remaining changes and breaks can be categorized as: the rebuilder and parsers; profiling and logging; instantiation; and miscellaneous. "},{"id":"\/packages\/3.x\/Sql\/upgrade.html#3-5-6-1","title":"3.5.6.1. Rebuilder and Parsers","content":"The 2.x Rebuilder has been redone entirely, and now provides separate parsers for the separate database drivers (mysql, pgsql, sqlite, and sqlsrv). This originated from #104, along with #107 and #111, all of which are now resolved. It took a great deal of time and effort to complete, with several approaches attempted."},{"id":"\/packages\/3.x\/Sql\/upgrade.html#3-5-6-1-1","title":"3.5.6.1.1. Array Placeholders","content":"Given this code ...$stm = \"SELECT * FROM test WHERE foo IN (:foo)\"; $sth = $pdo-&gt;perform($stm, [ 'foo' =&gt; ['bar', 'baz', 'dib']; ]); echo $sth-&gt;queryString; ... 2.x would quote and replace the array values directly into the query:SELECT * FROM test WHERE foo IN ('bar', 'baz', 'dib') Now, under 3.x, the placeholder is expanded to match the number of array keys, so that there are multiple placeholders:SELECT * FROM test WHERE foo IN (:foo_0, :foo_1, :foo_2) The array values passed to the query will also be bound individually. (If you profile the query, you will see :foo_0 (et al.) in the bindings.)"},{"id":"\/packages\/3.x\/Sql\/upgrade.html#3-5-6-1-2","title":"3.5.6.1.2. Sequential Placeholders","content":"Given this code ...$stm = 'SELECT * FROM test WHERE foo = ? AND bar = ?'; $sth = $pdo-&gt;perform($stm, [ 'foo_value', 'bar_value', ]); echo $sth-&gt;queryString; ... the 2.x rebuilder would leave ? placeholders alone:SELECT * FROM test WHERE foo = ? AND bar = ? Now, under 3.x, sequential placeholders are converted to named placeholders; the name corresponds to the sequential position:SELECT * FROM test WHERE foo = :__1 AND bar = :__2 The sequential values passed to the query will be bound to the named replacements.This helps to correct errors associated with binding sequential and named placeholders together, and in identifiying bound values in longer query strings."},{"id":"\/packages\/3.x\/Sql\/upgrade.html#3-5-6-1-3","title":"3.5.6.1.3. Repetition of Named Placeholders","content":"With 3.x, you can use the same placeholder multiple times. Given this code ...$stm = 'SELECT * FROM test WHERE foo = :val OR bar = :val'; $sth = $pdo-&gt;perform($stm, [ 'val' =&gt; 'whatever', ]); echo $sth-&gt;queryString; ... the 3.x parser modifies repeated placeholders by suffixing them each time they reappear, and binds the needed values automatically:SELECT * FROM test WHERE foo = :val OR bar = :val__1 "},{"id":"\/packages\/3.x\/Sql\/upgrade.html#3-5-6-1-4","title":"3.5.6.1.4. Custom Parsers","content":"You can inject your own parsers as well via ExtendedPdo::setParser(). See the src\/Parser\/ directory for examples of the existing parsers."},{"id":"\/packages\/3.x\/Sql\/upgrade.html#3-5-6-2","title":"3.5.6.2. Profiling and Logging","content":"The 2.x version used a custom profiler system, retaining profiles as array constructs and returning them as such. You needed to inject it yourself.use Aura\\Sql\\Profiler; $pdo-&gt;setProfiler(new Profiler()); \/\/ ... \/\/ query(), fetch(), beginTransaction()\/commit()\/rollback() etc. \/\/ ... \/\/ retrieve the profile information as a series of arrays $profiles = $pdo-&gt;getProfiler()-&gt;getProfiles(); Under 3.x, the profiler interface itself remains custom, but it is now backed with the PSR-3 logger interface. This means you can use any PSR-3 implementation to capture profiler information. This means that the profiler emits strings, rather than arrays, for the logger to capture.A profiler is now automatically set on the ExtendedPdo instance, and uses an in-memory logger by default for debugging purposes.\/\/ no need to set a profiler, but you do need to activate it: $pdo-&gt;getProfiler()-&gt;setActive(); \/\/ ... \/\/ query(), fetch(), beginTransaction()\/commit()\/rollback() etc. \/\/ ... \/\/ retrieve the profiler logs from the default MemoryLogger $messages = $pdo-&gt;getProfiler()-&gt;getLogger()-&gt;getMessages(); You can set the log message format and log level through the profiler, to capture just the information you want.You can set your own profiler and backing logger with the setProfiler() method.use Aura\\Sql\\Profiler\\Profiler; $myLogger = new Psr3LoggerImplementation(); $pdo-&gt;setProfiler(new Profiler($myLogger)); Finally, under 2.x, ExtendedPdo would profile every function call. Unless you examined very carefully, a call to prepare() followed by perform() looked like 2 executions of the same query. To make it easier to examine logs, the 3.x version does not profile every function call (e.g., prepare() and prepareWithValues() are no longer logged)."},{"id":"\/packages\/3.x\/Sql\/upgrade.html#3-5-6-3","title":"3.5.6.3. Instantiation","content":"Under 2.x you would do this:$pdo = new ExtendedPdo( 'pgsql:host=localhost;dbname=test', 'username', 'password', array(), \/\/ driver options as key-value pairs array() \/\/ attributes as key-value pairs ); It appears the last argument ended up being extraneous. The 3.x ExtendedPdo changes the last argument to this:$pdo = new ExtendedPdo( 'pgsql:host=localhost;dbname=test', 'username', 'password', [], \/\/ driver options as key-value pairs [] \/\/ queries to execute after connection ); This lets you execute queries at connection time; e.g., to make connection configuration changes that cannot be made as driver options\/attributes. For example:$pdo = new ExtendedPdo( 'pgsql:host=localhost;dbname=test', 'username', 'password', [ PDO::ATTR_CASE =&gt; PDO::CASE_NATURAL, ], [ \"SET NAMES 'utf8'\", ] ) "},{"id":"\/packages\/3.x\/Sql\/upgrade.html#3-5-6-4","title":"3.5.6.4. Miscellaneous","content":" PHP 5.6 is now the minimum required PHP version, though using the latest PHP version is recommended. 3.x (as with previous versions) starts PDO in ERRMODE_EXCEPTION when no error mode is explicitly specified.. However, the sqlsrv driver balks at this, so it is started in ERRMODE_WARNING instead. The ExtendedPdo::yield*() methods now use the yield keyword instead of returning Iterator instances. 1.x had a quoteName() method to quote identifier names. This was removed in 2.x, when that (and related functionality) were split off to SqlQuery. The functionality is added back in 3.x as quoteName() and quoteSingleName() as a convenience, though it is less robust than in SqlQuery. Some drivers cause PDO to make additional methods available (e.g., sqlite and pgsql). The 3.x ExtendedPdo now proxies all unknown method calls to the underlying PDO instance to make those methods available, if they exist. When dumping an ExtendedPdo object, the username and password are omitted. This should help keep unexpected output of stack traces from revealing credentials. "},{"id":"\/packages\/2.x\/Accept.html#4-1","title":"4.1. Aura.Accept","content":"Provides content-negotiation tools using Accept* headers."},{"id":"\/packages\/2.x\/Accept.html#4-1-1-1","title":"4.1.1.1. Installation","content":"This library requires PHP 5.3 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/accept.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/Accept.html#4-1-1-2","title":"4.1.1.2. Quality","content":" To run the PHPUnit unit tests at the command line, issue composer install and then vendor\/bin\/phpunit at the package root. This requires Composer to be available as composer.This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/Accept.html#4-1-1-3","title":"4.1.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/Accept.html#4-1-2-1","title":"4.1.2.1. Instantiation","content":"First, instantiate a AcceptFactory object, then use it to create an Accept object.&lt;?php use Aura\\Accept\\AcceptFactory; $accept_factory = new AcceptFactory($_SERVER); $accept = $accept_factory-&gt;newInstance(); ?&gt; The Accept object provides convenienence methods to negotiate between acceptable (to the client) and available (from the application) charset, encoding, language, and media-type values. The methods are: negotiateCharset() negotiateEncoding() negotiateLanguage() negotiateMedia() Your application code, knowing what values it has available, should pass an array of the available values to the negotiate*() method. (The values that are acceptable to the client are already indicated by $_SERVER).The result returned from the method will be a *Value object describing the highest-quality match that was negotiated between the available and acceptable values. If there is no negotiable match, the result will be false. N.b. Accept headers can be kind of complicated. See the HTTP Header Field Definitions for more detailed information regarding quality factors, matching rules, and parameters extensions. "},{"id":"\/packages\/2.x\/Accept.html#4-1-2-2","title":"4.1.2.2. Negotiating Media Types","content":"To negotiate a media type (aka a content type), call the negotiateMedia() method with a list of available media types. The available types should be in the order you prefer for delivery, from \"most preferred\" to \"least preferred\".&lt;?php \/\/ assume the request indicates these Accept values (XML is best, then CSV, \/\/ then anything else) $_SERVER['HTTP_ACCEPT'] = 'application\/xml;q=1.0,text\/csv;q=0.5,*;q=0.1'; \/\/ create the accept factory $accept_factory = new AcceptFactory($_SERVER); \/\/ create the accept object $accept = $accept_factory-&gt;newInstance(); \/\/ assume our application has `application\/json` and `text\/csv` available \/\/ as media types, in order of highest-to-lowest preference for delivery $available = array( 'application\/json', 'text\/csv', ); \/\/ get the best match between what the request finds acceptable and what we \/\/ have available; the result in this case is 'text\/csv' $media = $accept-&gt;negotiateMedia($available); echo $media-&gt;getValue(); \/\/ text\/csv ?&gt; If the requested URL ends in a recognized file extension for a media type, the MediaNegotiator object used by Accept will use that file extension instead of the explicit Accept header value to determine the acceptable media type:&lt;?php \/\/ assume the request indicates these Accept values (XML is best, then CSV, \/\/ then anything else) $_SERVER['HTTP_ACCEPT'] = 'application\/xml;q=1.0,text\/csv;q=0.5,*;q=0.1'; \/\/ assume also that the request URI explicitly notes a .json file extension $_SERVER['REQUEST_URI'] = '\/path\/to\/entity.json'; \/\/ create the accept factory $accept_factory = new AcceptFactory($_SERVER); \/\/ factory the accept object $accept = $accept_factory-&gt;newInstance(); \/\/ assume our application has `application\/json` and `text\/csv` available \/\/ as media types, in order of highest-to-lowest preference for delivery $available = array( 'application\/json', 'text\/csv', ); \/\/ get the best match between what the request finds acceptable and what we \/\/ have available; the result in this case is 'application\/json' because of \/\/ the file extenstion overriding the Accept header values $media = $accept-&gt;negotiateMedia($available); echo $media-&gt;getValue(); \/\/ application\/json ?&gt; (See the MediaNegotiator class file for the list of what file extensions map to what media types.)To create your own mappings, set them into the AcceptFactory object at construction time:&lt;?php $accept_factory = new AcceptFactory($_SERVER, array( '.foo' =&gt; 'application\/x-foo-content-type', )); $accept = $accept_factory-&gt;newInstance(); ?&gt; If the acceptable values indicate additional parameters, you can match on those as well:&lt;?php \/\/ assume the request indicates these Accept values (XML is best, then CSV, \/\/ then anything else) $_SERVER['HTTP_ACCEPT'] = 'text\/html;level=1;q=0.5,text\/html;level=3'; \/\/ create the accept factory $accept_factory = new AcceptFactory($_SERVER); \/\/ factory the accept object $accept = $accept_factory-&gt;newInstance(); \/\/ assume our application has these available as media types, \/\/ in order of highest-to-lowest preference for delivery $available = array( 'text\/html;level=1', 'text\/html;level=2', ); \/\/ get the best match between what the request finds acceptable and what we \/\/ have available; the result in this case is 'text\/html;level=1' $media = $accept-&gt;negotiateMedia($available); echo $media-&gt;getValue(); \/\/ text\/html var_dump($media-&gt;getParameters()); \/\/ array('level' =&gt; '1') ?&gt;  N.b. Parameters in the acceptable values that are not present in the available values will not be used for matching. "},{"id":"\/packages\/2.x\/Accept.html#4-1-2-3","title":"4.1.2.3. Negotiating Other Values","content":"The other negotiation methods work much the same way, although they are less complex than media-type negotiation.&lt;?php \/\/ assume the request indicates these Accept-* values $_SERVER['HTTP_ACCEPT_CHARSET'] = 'iso-8859-5, unicode-1-1;q=0.8'; $_SERVER['HTTP_ACCEPT_ENCODING'] = 'compress;q=0.5, gzip;q=1.0'; $_SERVER['HTTP_ACCEPT_LANGUAGE'] = 'en-US, en-GB, en, *'; \/\/ create the accept factory $accept_factory = new AcceptFactory($_SERVER); \/\/ factory the accept object $accept = $accept_factory-&gt;newInstance(); \/\/ charset negotiation $available_charsets = array('iso-1234', 'unicode-1-1'); $charset = $accept-&gt;negotiateCharset($available_charsets); echo $charset-&gt;getValue('unicode-1-1'); \/\/ encoding negotiation $available_encodings = array(); $encoding = $accept-&gt;negotiateEncoding($available_encodings); var_dump($encoding); \/\/ false \/\/ language negotiation $available_languages = array('pt-BR', 'fr-FR'); $language = $accept-&gt;negotiateLanguage($available_languages); echo $language-&gt;getValue(); \/\/ pt-BR ?&gt; "},{"id":"\/packages\/2.x\/Auth.html#4-2","title":"4.2. Aura.Auth","content":"Provides authentication functionality and session tracking using various adapters; currently supported adapters are: Apache htpasswd files SQL tables via the PDO extension IMAP\/POP\/NNTP via the imap extension LDAP and Active Directory via the ldap extension OAuth via customized adapters Note that the purpose of this package is only to authenticate user credentials. It does not currently, and probably will not in the future, handle user account creation and management. That is more properly the domain of application-level functionality, or at least a separate Aura bundle."},{"id":"\/packages\/2.x\/Auth.html#4-2-1-1","title":"4.2.1.1. Installation","content":"This library requires PHP 5.5 or later, and has no userland dependencies. (As a special consideration, this library is compatible with PHP 5.3 and 5.4 when the ircmaxell\/password-compat package is installed.)It is installable and autoloadable via Composer as aura\/auth.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/Auth.html#4-2-1-2","title":"4.2.1.2. Quality","content":" To run the unit tests at the command line, issue composer install and then vendor\/bin\/phpunit at the package root. This requires Composer to be available as composer.This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/Auth.html#4-2-1-3","title":"4.2.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/Auth.html#4-2-2-1","title":"4.2.2.1. Instantiation","content":"To track authentication state and related information, create an Auth object using the AuthFactory.&lt;?php $auth_factory = new \\Aura\\Auth\\AuthFactory($_COOKIE); $auth = $auth_factory-&gt;newInstance(); ?&gt; You can retrieve authentication information using the following methods on the Auth instance: getUserName(): returns the authenticated username string getUserData(): returns the array of optional arbitrary user data getFirstActive(): returns the Unix time of first activity (login) getLastActive(): return the Unix time of most-recent activity (generally that of the current request) getStatus(): returns the current authentication status constant. These constants are: Status::ANON -- anonymous\/unauthenticated Status::IDLE -- the authenticated session has been idle for too long Status::EXPIRED -- the authenticated session has lasted for too long in total Status::VALID -- authenticated and valid isAnon(), isIdle(), isExpired(), isValid(): these return true or false, based on the current authentication status. You can also use the set*() variations of the get*() methods above to force the Auth object to whatever values you like. However, because the values are stored in a $_SESSION segment, the values will not be retained if a session is not running.To retain values in a session, you can start a session by force with session_start() on your own. Alternatively, it would be better to use one of the Aura.Auth package services to handle authentication and session-state management for you."},{"id":"\/packages\/2.x\/Auth.html#4-2-2-2","title":"4.2.2.2. Services","content":"This package comes with three services for dealing with authentication phases: LoginService to log in and start (or resume) a session, LogoutService to log out and remove the username and user data in the session (note that this does not destroy the session), and ResumeService to resume a previously-started session. You can create each by using the AuthFactory. For now, we will look at how to force login and logout; later, we will show how to have the service use a credential adapter."},{"id":"\/packages\/2.x\/Auth.html#4-2-2-2-1","title":"4.2.2.2.1. Forcing Login","content":"You can force the Auth object to a logged-in state by calling the LoginService forceLogin() method with a user name and optional arbitrary user data.&lt;?php \/\/ the authentication status is currently anonymous echo $auth-&gt;getStatus(); \/\/ ANON \/\/ create the login service $login_service = $auth_factory-&gt;newLoginService(); \/\/ use the service to force $auth to a logged-in state $username = 'boshag'; $userdata = array( 'first_name' =&gt; 'Bolivar', 'last_name' =&gt; 'Shagnasty', 'email' =&gt; 'boshag@example.com', ); $login_service-&gt;forceLogin($auth, $username, $userdata); \/\/ now the authentication status is valid echo $auth-&gt;getStatus(); \/\/ VALID ?&gt; Using forceLogin() has these side effects: it starts a new session if one has not already been started, or resumes a previous session if one exists it regenerates the session ID The specified user name and user data will be stored in a $_SESSION segment, along with an authentication status of Status::VALID.Note that forceLogin() does not check any credential sources. You as the application owner are forcing the Auth object to a logged-in state."},{"id":"\/packages\/2.x\/Auth.html#4-2-2-2-2","title":"4.2.2.2.2. Forcing Logout","content":"You can force the Auth object to a logged-out state by calling the LogoutService forceLogout() method.&lt;?php \/\/ the authentication status is currently valid echo $auth-&gt;getStatus(); \/\/ VALID \/\/ create the logout service $logout_service = $auth_factory-&gt;newLogoutService(); \/\/ use the service to force $auth to a logged-out state $logout_service-&gt;forceLogout($auth); \/\/ now the authentication status is anonymous\/invalid echo $auth-&gt;getStatus(); \/\/ ANON ?&gt; Using forceLogout() has these side effects: it clears any existing username and user data from the $_SESSION segment it regenerates the session ID Note that forceLogout() does not check any credential sources. You as the application owner are forcing the Auth object to a logged-out state.Note also that this does not destroy the session. This is because you may have other things you need in the session memory, such as flash messages."},{"id":"\/packages\/2.x\/Auth.html#4-2-2-2-3","title":"4.2.2.2.3. Resuming A Session","content":"When a PHP request ends, PHP saves the $_SESSION data for you. However, on the next request, PHP does not automatically start a new session for you, so $_SESSION is not automatically available.You could start a new session yourself to repopulate $_SESSION, but that will incur a performance overhead if you don't actually need the session data. Similarly, there may be no need to start a session when there was no session previously (and thus no data to repopulate into $_SESSION). What we need is a way to start a session if one was started previously, but avoid starting a session if none was started previously.The ResumeService exists to address this problem. When you call the resume() method on the ResumeService, it examines $_COOKIE to see if a session cookie is present: If the cookie is not present, it will not start a session, and return to the calling code. This avoids starting a session when there is no $_SESSION data to be populated. If the cookie is present, the ResumeService will start a session, thereby repopulating $_SESSION. Then it will update the authentication status depending on how long the session has been in place: If the session has been idle for too long (i.e., too much time has passed since the last request), the ResumeService will log the user out automatically and return to the calling code. If the session has expired (i.e., the total logged-in time has been too long), the ResumeService will likewise log the user out automatically and return to the calling code. Otherwise, the ResumeService will update the last-active time on the Auth object and return to the calling code. Generally, you will want to invoke the ResumeService at the beginning of your application cycle, so that the session data becomes available at the earliest opportunity.&lt;?php \/\/ create the resume service $resume_service = $auth_factory-&gt;newResumeService(); \/\/ use the service to resume any previously-existing session $resume_service-&gt;resume($auth); \/\/ $_SESSION has now been repopulated, if a session was started previously, \/\/ meaning the $auth object is now populated with its previous values, if any ?&gt; "},{"id":"\/packages\/2.x\/Auth.html#4-2-2-3","title":"4.2.2.3. Adapters","content":"Forcing the Auth object to a particular state is fine for when you want to exercise manual control over the authentication status, user name, user data, and other information. However, it is more often the case that you will want to check user credential input (username and password) against a credential store. This is where the Adapter classes come in.To use an Adapter with a Service, you first need to create the Adapter, then pass it to the AuthFactory new*Service() method."},{"id":"\/packages\/2.x\/Auth.html#4-2-2-3-1-1","title":"4.2.2.3.1.1. Instantiation","content":"To create an adapter for Apache htpasswd files, call the AuthFactory newHtpasswdAdapter() method and pass the file path of the Apache htpasswd file.&lt;?php $htpasswd_adapter = $auth_factory-&gt;newHtpasswdAdapter( '\/path\/to\/accounts.htpasswd' ); ?&gt; This will automatically use the HtpasswdVerifier to check DES, MD5, and SHA passwords from the htpasswd file on a per-user basis."},{"id":"\/packages\/2.x\/Auth.html#4-2-2-3-1-2","title":"4.2.2.3.1.2. Service Integration","content":"You can then pass the Adapter to each Service factory method like so:&lt;?php $login_service = $auth_factory-&gt;newLoginService($htpasswd_adapter); $logout_service = $auth_factory-&gt;newLogoutService($htpasswd_adapter); $resume_service = $auth_factory-&gt;newResumeService($htpasswd_adapter); ?&gt; To attempt a user login, pass an array with username and password elements to the LoginService login() method along with the Auth object:&lt;?php $login_service-&gt;login($auth, array( 'username' =&gt; 'boshag', 'password' =&gt; '12345' )); ?&gt; For more on LoginService idioms, please see the Service Idioms section. (The LogoutService and ResumeService do not need credential information.)"},{"id":"\/packages\/2.x\/Auth.html#4-2-2-3-2-1","title":"4.2.2.3.2.1. Instantiation","content":"To create an adapter for IMAP\/POP\/NNTP servers, call the AuthFactory newImapAdapter() method and pass the mailbox specification string, along with any appropriate option constants:&lt;?php $imap_adapter = $auth_factory-&gt;newImapAdapter( '{mail.example.com:143\/imap\/secure}', OP_HALFOPEN ); ?&gt;  N.b.: See the imap_open() documentation for more variations on mailbox specification strings. "},{"id":"\/packages\/2.x\/Auth.html#4-2-2-3-2-2","title":"4.2.2.3.2.2. Service Integration","content":"You can then pass the Adapter to each Service factory method like so:&lt;?php $login_service = $auth_factory-&gt;newLoginService($imap_adapter); $logout_service = $auth_factory-&gt;newLogoutService($imap_adapter); $resume_service = $auth_factory-&gt;newResumeService($imap_adapter); ?&gt; To attempt a user login, pass an array with username and password elements to the LoginService login() method along with the Auth object:&lt;?php $login_service-&gt;login($auth, array( 'username' =&gt; 'boshag', 'password' =&gt; '12345' )); ?&gt; For more on LoginService idioms, please see the Service Idioms section. (The LogoutService and ResumeService do not need credential information.)"},{"id":"\/packages\/2.x\/Auth.html#4-2-2-3-3-1","title":"4.2.2.3.3.1. Instantiation","content":"To create an adapter for LDAP and Active Directory servers, call the AuthFactory newLdapAdapter() method and pass the server name with a distinguished name (DN) format string:&lt;?php $ldap_adapter = $auth_factory-&gt;newLdapAdapter( 'ldaps:\/\/ldap.example.com:636', 'ou=Company Name,dc=Department Name,cn=users,uid=%s' ); ?&gt;  N.b.: The username will be escaped and then passed to the DN format string via sprintf(). The completed DN will be used for binding to the server after connection. "},{"id":"\/packages\/2.x\/Auth.html#4-2-2-3-3-2","title":"4.2.2.3.3.2. Service Integration","content":"You can then pass the Adapter to each Service factory method like so:&lt;?php $login_service = $auth_factory-&gt;newLoginService($ldap_adapter); $logout_service = $auth_factory-&gt;newLogoutService($ldap_adapter); $resume_service = $auth_factory-&gt;newResumeService($ldap_adapter); ?&gt; To attempt a user login, pass an array with username and password elements to the LoginService login() method along with the Auth object:&lt;?php $login_service-&gt;login($auth, array( 'username' =&gt; 'boshag', 'password' =&gt; '12345' )); ?&gt; For more on LoginService idioms, please see the Service Idioms section. (The LogoutService and ResumeService do not need credential information.)"},{"id":"\/packages\/2.x\/Auth.html#4-2-2-3-4-1","title":"4.2.2.3.4.1. Instantiation","content":"To create an adapter for PDO connections to SQL tables, call the AuthFactory newPdoAdapter() method and pass these parameters in order: a PDO connection instance a indication of how passwords are hashed in the database: if a PASSWORD_* constant from PHP 5.5 and up, it is treated as password_hash() algorithm for a PasswordVerifier instance (this is the preferred method) if a string, it is treated as a hash() algorithm for a HashVerifier instance otherwise, it is expected to be an implementation of VerifierInterface an array of column names: the first element is the username column, the second element is the hashed-password column, and additional columns are used as extra user information to be selected and returned from the database a FROM specification string to indicate one or more table names, with any other JOIN clauses you wish to add an optional WHERE condition string; use this to add extra conditions to the SELECT statement built by the adapter Here is a legacy example where passwords are MD5 hashed in an accounts table:&lt;?php $pdo = new \\PDO(...); $hash = new PasswordVerifier('md5'); $cols = array('username', 'md5password'); $from = 'accounts'; $pdo_adapter = $auth_factory-&gt;newPdoAdapter($pdo, $hash, $cols, $from); ?&gt; Here is a modern, more complex example that uses bcrypt instead of md5, retrieves extra user information columns from joined tables, and filters for active accounts:&lt;?php $pdo = new \\PDO(...); $hash = new PasswordVerifier(PASSWORD_BCRYPT); $cols = array( 'accounts.username', \/\/ \"AS username\" is added by the adapter 'accounts.bcryptpass', \/\/ \"AS password\" is added by the adapter 'accounts.uid AS uid', 'userinfo.email AS email', 'userinfo.uri AS website', 'userinfo.fullname AS display_name', ); $from = 'accounts JOIN profiles ON accounts.uid = profiles.uid'; $where = 'accounts.active = 1'; $pdo_adapter = $auth_factory-&gt;newPdoAdapter($pdo, $hash, $cols, $from, $where); ?&gt; (The additional information columns will be retained in the session data after successful authentication.)"},{"id":"\/packages\/2.x\/Auth.html#4-2-2-3-4-2","title":"4.2.2.3.4.2. Service Integration","content":"You can then pass the Adapter to each Service factory method like so:&lt;?php $login_service = $auth_factory-&gt;newLoginService($pdo_adapter); $logout_service = $auth_factory-&gt;newLogoutService($pdo_adapter); $resume_service = $auth_factory-&gt;newResumeService($pdo_adapter); ?&gt; To attempt a user login, pass an array with username and password elements to the LoginService login() method along with the Auth object:&lt;?php $login_service-&gt;login($auth, array( 'username' =&gt; 'boshag', 'password' =&gt; '12345' )); ?&gt; For more on LoginService idioms, please see the Service Idioms section. (The LogoutService and ResumeService do not need credential information.)"},{"id":"\/packages\/2.x\/Auth.html#4-2-2-3-5","title":"4.2.2.3.5. Custom Adapters","content":"Although this package comes with multiple Adapter classes, it may be that none of them fit your needs.You may wish to extend one of the existing adapters to add login\/logout\/resume behaviors. Alternatively, you can create an Adapter of your own by implementing the AdapterInterface on a class of your choosing:&lt;?php use Aura\\Auth\\Adapter\\AdapterInterface; use Aura\\Auth\\Auth; use Aura\\Auth\\Status; class CustomAdapter implements AdapterInterface { \/\/ AdapterInterface::login() public function login(array $input) { if ($this-&gt;isLegit($input)) { $username = ...; $userdata = array(...); $this-&gt;updateLoginTime(time()); return array($username, $userdata); } else { throw CustomException('Something went wrong.'); } } \/\/ AdapterInterface::logout() public function logout(Auth $auth, $status = Status::ANON) { $this-&gt;updateLogoutTime($auth-&gt;getUsername(), time()); } \/\/ AdapterInterface::resume() public function resume(Auth $auth) { $this-&gt;updateActiveTime($auth-&gt;getUsername(), time()); } \/\/ custom support methods not in the interface protected function isLegit($input) { ... } protected function updateLoginTime($time) { ... } protected function updateActiveTime($time) { ... } protected function updateLogoutTime($time) { ... } } ?&gt; You can then pass an instance of the custom adapter when creating services through the AuthFactory methods:&lt;?php $custom_adapter = new CustomAdapter; $login_service = $auth_factory-&gt;newLoginService($custom_adapter); $logout_service = $auth_factory-&gt;newLogoutService($custom_adapter); $resume_service = $auth_factory-&gt;newResumeService($custom_adapter); ?&gt; "},{"id":"\/packages\/2.x\/Auth.html#4-2-2-3-5-1","title":"4.2.2.3.5.1. OAuth Adapters","content":"Should you desire to handle your authentication through a 3rd party service that uses OAuth 2.0, you'll need to write an adapter that implements Aura\\Auth\\Adapter\\AdapterInterface and provide your own implementation for fetching the access token and user information. Your implementation can be something you've written yourself or it can be an existing OAuth2 client.The following example will demonstrate how you'd go about creating this adapter using the PHP League's OAuth2 Client. We'll also be using Github as the service provider for this example.&lt;?php namespace OAuth2\\Adapter; use Aura\\Auth\\Adapter\\AdapterInterface; use Aura\\Auth\\Exception; use Aura\\Auth\\Auth; use Aura\\Auth\\Status; use League\\OAuth2\\Client\\Provider\\AbstractProvider; class LeagueOAuth2Adapter implements AdapterInterface { \/** * @var \\League\\OAuth2\\Client\\Provider\\IdentityProvider * The identity provider that the adapter will use *\/ protected $provider; public function __construct(AbstractProvider $provider) { $this-&gt;provider = $provider; } \/** * @param $input an input containing the OAuth 2 code * @return array the username and details for the user * @throws \\Aura\\Auth\\Exception * This method must be implemented to fulfill the contract * with AdapterInterface *\/ public function login(array $input) { if (!isset($input['code'])) { throw new Exception('Authorization code missing.'); } $token = $this-&gt;provider-&gt;getAccessToken( 'authorization_code', array('code' =&gt; $input['code']) ); $details = $this-&gt;provider-&gt;getResourceOwner($token); $data = [ 'name' =&gt; $details-&gt;getName(), 'email' =&gt; $details-&gt;getEmail(), ]; $data['token'] = $token; $username = $data['email']; return [$username, $data]; } \/** * @param Auth $auth * Logout method is required to fulfill the contract with AdapterInterface *\/ public function logout(Auth $auth, $status = Status::ANON) { \/\/nothing to do here } \/** * @param Auth $auth * Resume method required to fulfill the contract with AdapterInterface *\/ public function resume(Auth $auth) { \/\/ nothing to do here } } ?&gt; As you can see in the code, your adapter will be accepting a client as a parameter and using that client to fulfill the \\Aura\\Auth\\Adapter\\AdapterInterface contract. This adapter would be commonly used in an OAuth2 Callback process. Essentially, once you provide your credentials and authenticate with the 3rd Party service (in this case Github), you will be redirected back to a script on your server where you'll have to verify that you sent the request by sending an verification code back to the service. This is why it's a good idea to use a good OAuth2 client in lieu of writing your own. Below is an example of what this OAuth2 callback code might look like.&lt;?php namespace OAuth2; use Aura\\Auth\\AuthFactory; use League\\OAuth2\\Client\\Provider\\Github; use OAuth2\\Adapter\\LeagueOAuth2Adapter; use Aura\\Auth\\Exception; require_once 'vendor\/autoload.php'; $auth_factory = new AuthFactory($_COOKIE); $auth = $auth_factory-&gt;newInstance(); $github_provider = new Github(array( 'clientId' =&gt; 'xxxxxxxxxxxxxxxx', 'clientSecret' =&gt; 'xxxxxxxxxxxxxxxxxxxx', 'redirectUri' =&gt; 'http:\/\/aura.auth.dev\/' )); if (!isset($_GET['code'])) { header('Location: ' . $github_provider-&gt;getAuthorizationUrl()); exit; } else { $oauth_adapter = new LeagueOAuth2Adapter($github_provider); $login_service = $auth_factory-&gt;newLoginService($oauth_adapter); try { \/\/ array is the username and an array of info and indicates successful \/\/ login $data = $login_service-&gt;login($auth, $_GET); } catch (Exception $e) { \/\/ handle the exception } } ?&gt; The fact that not every 3rd Party Service returns data the same way means it's not reasonable for Aura to try to handle every different data set out of the box. By writing this little bit of code, you can easily implement Aura Auth for your 3rd Party OAuth2 services."},{"id":"\/packages\/2.x\/Auth.html#4-2-2-4-1","title":"4.2.2.4.1. Resuming A Session","content":"This is an example of the code needed to resume a pre-existing session. Note that the echo statements are intended to explain the different resulting states of the resume() call, and may be replaced by whatever logic you feel is appropriate. For example, you may wish to redirect to a login page when a session has idled or expired.&lt;?php $auth = $auth_factory-&gt;newInstance(); $resume_service = $auth_factory-&gt;newResumeService(...); $resume_service-&gt;resume($auth); switch (true) { case $auth-&gt;isAnon(): echo \"You are not logged in.\"; break; case $auth-&gt;isIdle(): echo \"Your session was idle for too long. Please log in again.\"; break; case $auth-&gt;isExpired(): echo \"Your session has expired. Please log in again.\"; break; case $auth-&gt;isValid(): echo \"You are still logged in.\"; break; default: echo \"You have an unknown status.\"; break; } ?&gt;  N.b.: Instead of creating the Auth and ResumeService objects by hand, you may wish to use a dependency injection container such as Aura.Di to retain them for shared use throughout your application. "},{"id":"\/packages\/2.x\/Auth.html#4-2-2-4-2","title":"4.2.2.4.2. Logging In","content":"This is an example of the code needed to effect a login. Note that the echo and $log statements are intended to explain the different resulting states of the login() call, and may be replaced by whatever logic you feel is appropriate; in particular, you should probably not expose the exact nature of the failure, to help mitigate brute-force attempts.&lt;?php class InvalidLoginException extends Exception {} $auth = $auth_factory-&gt;newInstance(); $login_service = $auth_factory-&gt;newLoginService(...); try { $login_service-&gt;login($auth, array( 'username' =&gt; $_POST['username'], 'password' =&gt; $_POST['password'], ); echo \"You are now logged into a new session.\"; } catch (\\Aura\\Auth\\Exception\\UsernameMissing $e) { $log-&gt;notice(\"The 'username' field is missing or empty.\"); throw new InvalidLoginException(); } catch (\\Aura\\Auth\\Exception\\PasswordMissing $e) { $log-&gt;notice(\"The 'password' field is missing or empty.\"); throw new InvalidLoginException(); } catch (\\Aura\\Auth\\Exception\\UsernameNotFound $e) { $log-&gt;warning(\"The username you entered was not found.\"); throw new InvalidLoginException(); } catch (\\Aura\\Auth\\Exception\\MultipleMatches $e) { $log-&gt;warning(\"There is more than one account with that username.\"); throw new InvalidLoginException(); } catch (\\Aura\\Auth\\Exception\\PasswordIncorrect $e) { $log-&gt;notice(\"The password you entered was incorrect.\"); throw new InvalidLoginException(); } catch (\\Aura\\Auth\\Exception\\ConnectionFailed $e) { $log-&gt;notice(\"Cound not connect to IMAP or LDAP server.\"); $log-&gt;info(\"This could be because the username or password was wrong,\"); $log-&gt;info(\"or because the the connect operation itself failed in some way. \"); $log-&gt;info($e-&gt;getMessage()); throw new InvalidLoginException(); } catch (\\Aura\\Auth\\Exception\\BindFailed $e) { $log-&gt;notice(\"Cound not bind to LDAP server.\"); $log-&gt;info(\"This could be because the username or password was wrong,\"); $log-&gt;info(\"or because the the bind operation itself failed in some way. \"); $log-&gt;info($e-&gt;getMessage()); throw new InvalidLoginException(); } catch (InvalidLoginException $e) { echo \"Invalid login details. Please try again.\"; } ?&gt;  N.b.: Instead of creating the Auth and LoginService objects by hand, you may wish to use a dependency injection container such as Aura.Di to retain them for shared use throughout your application. Alternatively, you may wish to use credentials from the HTTP Authorization: Basic headers instead of using $_POST or other form-related inputs. On Apache mod_php you might use the auto-populated $_SERVER['PHP_AUTH_*'] values:&lt;?php $authorization_basic = function () { return array( isset($_SERVER['PHP_AUTH_USER']) ? $_SERVER['PHP_AUTH_USER'] : null, isset($_SERVER['PHP_AUTH_PW']) ? $_SERVER['PHP_AUTH_PW'] : null, ); } list($username, $password) = $authorization_basic(); $login_service-&gt;login($auth, array( 'username' =&gt; $username, 'password' =&gt; $password, )); ?&gt; On other servers you may need to extract the credentials from the Authorization: Basic header itself:&lt;?php $authorization_basic = function () { $header = isset($_SERVER['HTTP_AUTHORIZATION']) ? $_SERVER['HTTP_AUTHORIZATION'] : ''; if (strtolower(substr($header, 0, 6)) !== 'basic ') { return array(null, null); } $encoded = substr($header, 6); $decoded = base64_decode($encoded); return explode(':', $decoded); } list($username, $password) = $authorization_basic(); $login_service-&gt;login($auth, array( 'username' =&gt; $username, 'password' =&gt; $password, )); ?&gt; "},{"id":"\/packages\/2.x\/Auth.html#4-2-2-4-3","title":"4.2.2.4.3. Logging Out","content":"This is an example of the code needed to effect a logout. Note that the echo statements are intended to explain the different resulting states of the logout() call, and may be replaced by whatever logic you feel is appropriate.&lt;?php $auth = $auth_factory-&gt;newInstance(); $logout_service = $auth_factory-&gt;newLogoutService(...); $logout_service-&gt;logout($auth); if ($auth-&gt;isAnon()) { echo \"You are now logged out.\"; } else { echo \"Something went wrong; you are still logged in.\"; } ?&gt;  N.b.: Instead of creating the Auth and LogoutService objects by hand, you may wish to use a dependency injection container such as Aura.Di to retain them for shared use throughout your application. "},{"id":"\/packages\/2.x\/Auth.html#4-2-2-4-4","title":"4.2.2.4.4. Custom Services","content":"You are not restricted to the login, logout, and resume services provided by this package. However, if you build a service of your own, or if you extend one of the provided services, you will have to instantiate that customized service object manually, instead of using the AuthFactory. This can be tedious but is not difficult, especially when using a dependency injection container system such as Aura.Di."},{"id":"\/packages\/2.x\/Auth.html#4-2-2-5","title":"4.2.2.5. Session Management","content":"The Service objects use a Session object to start sessions and regenerate session IDs. (Note that they do not destroy sessions.) The Session object uses the native PHP session_*() functions to manage sessions."},{"id":"\/packages\/2.x\/Auth.html#4-2-2-5-1","title":"4.2.2.5.1. Custom Sessions","content":"If you wish to use an alternative means of managing sessions, implement the SessionInterface on an object of your choice. One way to do this is by by wrapping a framework-specific session object and proxying the SessionInterface methods to the wrapped object:&lt;?php use Aura\\Auth\\Session\\SessionInterface; class CustomSession implements SessionInterface { protected $fwsession; public function __construct(FrameworkSession $fwsession) { $this-&gt;fwsession = $fwsession; } public function start() { return $this-&gt;fwsession-&gt;startSession(); } public function resume() { if ($this-&gt;fwsession-&gt;isAlreadyStarted()) { return true; } if ($this-&gt;fwsession-&gt;canBeRestarted()) { return $this-&gt;fwsession-&gt;restartSession(); } return false; } public function regenerateId() { return $this-&gt;fwsession-&gt;regenerateSessionId(); } } ?&gt; Then pass that custom session object to the AuthFactory instantiation:&lt;?php use Aura\\Auth\\AuthFactory; $custom_session = new CustomSession(new FrameworkSession); $auth_factory = new AuthFactory($_COOKIE, $custom_session); ?&gt; The factory will pass your custom session object wherever it is needed."},{"id":"\/packages\/2.x\/Auth.html#4-2-2-5-2","title":"4.2.2.5.2. Working Without Sessions","content":"In some situations, such as with APIs where credentials are provided with every request, it may be beneficial to avoid sessions altogether. In this case, pass a NullSession and NullSegment to the AuthFactory:&lt;?php use Aura\\Auth\\AuthFactory; use Aura\\Auth\\Session\\NullSession; use Aura\\Auth\\Session\\NullSegment; $null_session = new NullSession; $null_segment = new NullSegment; $auth_factory = new AuthFactory($_COOKIE, $null_session, $null_segment); ?&gt; With the NullSession, no session will ever be started, and no session ID will be created or regenerated. Likewise, no session will ever be resumed, because it will never have been saved at the end of the previous request. Finally, PHP will never create a session cookie to send in the response.Similarly, the NullSegment retains authentication information in an object property instead of in a $_SESSION segment. Unlike the normal Segment, which only retains data when $_SESSION is present, the NullSegment will always retain data that is set into it. When the request is over, all information retained in the NullSegment will disappear.When using the NullSession and NullSegment, you will have to check credentials via the LoginService login() or forceLogin() method on each request, which in turn will retain the authentication information in the Segment. In an API situation this is often preferable to managing an ongoing session. N.b. In an API situation, the credentials may be an API token, or passed as HTTP basic or digest authentication headers. Pass these to the adapter of your choice. "},{"id":"\/packages\/2.x\/Auth.html#4-2-2-6","title":"4.2.2.6. DI Configuration","content":"Here are some hints regarding configuration of Aura.Auth via Aura.Di."},{"id":"\/packages\/2.x\/Auth.html#4-2-2-6-1","title":"4.2.2.6.1. Aura\\Auth\\Adapter\\HtpasswdAdapter","content":"&lt;?php $di-&gt;params['Aura\\Auth\\Adapter\\HtpasswdAdapter'] = array( 'file' =&gt; '\/path\/to\/htpasswdfile', ); ?&gt; "},{"id":"\/packages\/2.x\/Auth.html#4-2-2-6-2","title":"4.2.2.6.2. Aura\\Auth\\Adapter\\ImapAdapter","content":"&lt;?php $di-&gt;params['Aura\\Auth\\Adapter\\ImapAdapter'] = array( 'mailbox' =&gt; '{mail.example.com:143\/imap\/secure}', ); ?&gt; "},{"id":"\/packages\/2.x\/Auth.html#4-2-2-6-3","title":"4.2.2.6.3. Aura\\Auth\\Adapter\\LdapAdapter","content":"&lt;?php $di-&gt;params['Aura\\Auth\\Adapter\\LdapAdapter'] = array( 'server' =&gt; 'ldaps:\/\/ldap.example.com:636', 'dnformat' =&gt; 'ou=Company Name,dc=Department Name,cn=users,uid=%s', ); ?&gt; "},{"id":"\/packages\/2.x\/Auth.html#4-2-2-6-4","title":"4.2.2.6.4. Aura\\Auth\\Adapter\\PdoAdapter","content":"&lt;?php $di-&gt;params['Aura\\Auth\\Adapter\\PdoAdapter'] = array( 'pdo' =&gt; $di-&gt;lazyGet('your_pdo_connection_service'), 'cols' =&gt; array( 'username_column', 'password_column', ), 'from' =&gt; 'users_table', 'where' =&gt; '', ); ?&gt; "},{"id":"\/packages\/2.x\/Autoload.html#4-3","title":"4.3. Aura.Autoload","content":"Provides a full PSR-4 and limited PSR-0 autoloader. Although it is installable via Composer, its best use is probably outside a Composer-oriented project.For a full PSR-0 only autoloader, please see Aura.Autoload v1."},{"id":"\/packages\/2.x\/Autoload.html#4-3-1-1","title":"4.3.1.1. Installation","content":"This library requires PHP 5.3 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/autoload.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/Autoload.html#4-3-1-2","title":"4.3.1.2. Quality","content":" To run the unit tests at the command line, issue phpunit at the package root. (This requires PHPUnit to be available as phpunit.)This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/Autoload.html#4-3-1-3","title":"4.3.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/Autoload.html#4-3-2","title":"4.3.2. Getting Started","content":"To use the autoloader, first instantiate it, then register it with SPL autoloader stack:&lt;?php \/\/ instantiate $loader = new \\Aura\\Autoload\\Loader; \/\/ append to the SPL autoloader stack; use register(true) to prepend instead $loader-&gt;register(); ?&gt; "},{"id":"\/packages\/2.x\/Autoload.html#4-3-2-1","title":"4.3.2.1. PSR-4 Namespace Prefixes","content":"To add a namespace conforming to PSR-4 specifications, point to the base directory for that namespace. Multiple base directories are allowed, and will be searched in the order they are added.&lt;?php $loader-&gt;addPrefix('Foo\\Bar', '\/path\/to\/foo-bar\/src'); $loader-&gt;addPrefix('Foo\\Bar', '\/path\/to\/foo-bar\/tests'); ?&gt; To set several namespaces prefixes at once, overriding all previous prefix settings, use setPrefixes().&lt;?php $loader-&gt;setPrefixes(array( 'Foo\\Bar' =&gt; array( '\/path\/to\/foo-bar\/src', '\/path\/to\/foo-bar\/tests', ), 'Baz\\Dib' =&gt; array( '\/path\/to\/baz.dib\/src', '\/path\/to\/baz.dib\/tests', ), )); ?&gt; "},{"id":"\/packages\/2.x\/Autoload.html#4-3-2-2","title":"4.3.2.2. PSR-0 Namespaces","content":"To add a namespace conforming to PSR-0 specifications, one that uses only namespace separators in the class names (no underscores allowed!), point to the directory containing classes for that namespace. Multiple directories are allowed, and will be searched in the order they are added.&lt;?php $loader-&gt;addPrefix('Baz\\Dib', '\/path\/to\/baz-dib\/src\/Baz\/Dib'); $loader-&gt;addPrefix('Baz\\Dib', '\/path\/to\/baz-dib\/tests\/Baz\/Dib'); ?&gt; To set several namespaces prefixes at once, as with PSR-4, use setPrefixes()."},{"id":"\/packages\/2.x\/Autoload.html#4-3-2-3","title":"4.3.2.3. Explicit Class-to-File Mappings","content":"To map a class explictly to a file, use the setClassFile() method.&lt;?php $loader-&gt;setClassFile('Foo\\Bar\\Baz', '\/path\/to\/Foo\/Bar\/Baz.php'); ?&gt; To set several class-to-file mappings at once, overriding all previous mappings, use setClassFiles(). (Alternatively, use addClassFiles() to append to the existing mappings.)&lt;?php $loader-&gt;setClassFiles(array( 'Foo\\Bar\\Baz' =&gt; '\/path\/to\/Foo\/Bar\/Baz.php', 'Foo\\Bar\\Qux' =&gt; '\/path\/to\/Foo\/Bar\/Qux.php', 'Foo\\Bar\\Quux' =&gt; '\/path\/to\/Foo\/Bar\/Quux.php', )); ?&gt; "},{"id":"\/packages\/2.x\/Autoload.html#4-3-2-4","title":"4.3.2.4. Inspection and Debugging","content":"These methods are available to inspect the Loader: getPrefixes() returns all the added namespace prefixes and their base directories getClassFiles() returns all the explicit class-to-file mappings getLoadedClasses() returns all the class names loaded by the Loader and the file names for the loaded classes If a class file cannot be loaded for some reason, review the debug information using getDebug(). This will show a log of information for the most-recent autoload attempt involving the Loader.&lt;?php \/\/ set the wrong path for Foo\\Bar classes $loader-&gt;addPrefix('Foo\\Bar', '\/wrong\/path\/to\/foo-bar\/src'); \/\/ this will fail $baz = new \\Foo\\Bar\\Baz; \/\/ examine the debug information var_dump($loader-&gt;getDebug()); \/\/ array( \/\/ 'Loading Foo\\\\Bar\\\\Baz', \/\/ 'No explicit class file', \/\/ 'Foo\\\\Bar\\\\: \/path\/to\/foo-bar\/Baz.php not found', \/\/ 'Foo\\\\: no base dirs', \/\/ 'Foo\\\\Bar\\\\Baz not loaded', \/\/ ) ?&gt; "},{"id":"\/packages\/2.x\/Cli.html#4-4","title":"4.4. Aura.Cli","content":"Provides the equivalent of request ( Context ) and response ( Stdio ) objects for the command line interface, including Getopt support, and an independent Help object for describing commands."},{"id":"\/packages\/2.x\/Cli.html#4-4-1-1","title":"4.4.1.1. Installation","content":"This library requires PHP 5.3 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/cli.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/Cli.html#4-4-1-2","title":"4.4.1.2. Quality","content":" To run the unit tests at the command line, issue composer install and then phpunit at the package root. This requires Composer to be available as composer, and PHPUnit to be available as phpunit.This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/Cli.html#4-4-1-3","title":"4.4.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/Cli.html#4-4-2-1","title":"4.4.2.1. Context Discovery","content":"The Context object provides information about the command line environment, including any option flags passed via the command line. (This is the command line equivalent of a web request object.)Instantiate a Context object using the CliFactory; pass it a copy of $GLOBALS.&lt;?php use Aura\\Cli\\CliFactory; $cli_factory = new CliFactory; $context = $cli_factory-&gt;newContext($GLOBALS); ?&gt; You can access the $_ENV, $_SERVER, and $argv values with the $env, $server, and $argv property objects, respectively. (Note that these properties are copies of those superglobals as they were at the time of Context instantiation.) You can pass an alternative default value if the related key is missing.&lt;?php \/\/ get copies of superglobals $env = $context-&gt;env-&gt;get(); $server = $context-&gt;server-&gt;get(); $argv = $context-&gt;argv-&gt;get(); \/\/ equivalent to: \/\/ $value = isset($_ENV['key']) ? $_ENV['key'] : null; $value = $context-&gt;env-&gt;get('key'); \/\/ equivalent to: \/\/ $value = isset($_ENV['key']) ? $_ENV['key'] : 'other_value'; $value = $context-&gt;env-&gt;get('key', 'other_value'); ?&gt; "},{"id":"\/packages\/2.x\/Cli.html#4-4-2-2","title":"4.4.2.2. Getopt Support","content":"The Context object provides support for retrieving command-line options and params, along with positional arguments.To retrieve options and arguments parsed from the command-line $argv values, use the getopt() method on the Context object. This will return a GetoptValues object for you to use as as you wish."},{"id":"\/packages\/2.x\/Cli.html#4-4-2-2-1","title":"4.4.2.2.1. Defining Options and Params","content":"To tell getopt() how to recognize command line options, pass an array of option definitions. The definitions array format is similar to, but not exactly the same as, the one used by the getopt() function in PHP. Instead of defining short flags in a string and long options in a separate array, they are both defined as elements in a single array. Adding a * after the option name indicates it can be passed multiple times; its values will be stored in an array.&lt;?php $options = array( 'a', \/\/ short flag -a, parameter is not allowed 'b:', \/\/ short flag -b, parameter is required 'c::', \/\/ short flag -c, parameter is optional 'foo', \/\/ long option --foo, parameter is not allowed 'bar:', \/\/ long option --bar, parameter is required 'baz::', \/\/ long option --baz, parameter is optional 'g*::', \/\/ short flag -g, parameter is optional, multi-pass ); $getopt = $context-&gt;getopt($options); ?&gt;  N.b.: When we say \"required\" here, it means \"the option, when present, must have a parameter.\" It does not mean \"the option must be present.\" These are options, after all. If a particular value must be passed, consider using positional arguments instead. Use the get() method on the returned GetoptValues object to retrieve the option values. You can provide an alternative default value for when the option is missing.&lt;?php $a = $getopt-&gt;get('-a', false); \/\/ true if -a was passed, false if not $b = $getopt-&gt;get('-b'); $c = $getopt-&gt;get('-c', 'default value'); $foo = $getopt-&gt;get('--foo', 0); \/\/ true if --foo was passed, false if not $bar = $getopt-&gt;get('--bar'); $baz = $getopt-&gt;get('--baz', 'default value'); $g = $getopt-&gt;get('-g', []); ?&gt; If you want to alias one option name to another, comma-separate the two names. The values will be stored under both names;&lt;?php \/\/ alias -f to --foo $options = array( 'foo,f:', \/\/ long option --foo or short flag -f, parameter required ); $getopt = $context-&gt;getopt($options); $foo = $getopt-&gt;get('--foo'); \/\/ both -f and --foo have the same values $f = $getopt-&gt;get('-f'); \/\/ both -f and --foo have the same values ?&gt; If you want to allow an option to be passed multiple times, add a '*' to the end of the option name.&lt;?php $options = array( 'f*', 'foo*:' ); $getopt = $context-&gt;getopt($options); \/\/ if the script was invoked with: \/\/ php script.php --foo=foo --foo=bar --foo=baz -f -f -f $foo = $getopt-&gt;get('--foo'); \/\/ ['foo', 'bar', 'baz'] $f = $getopt-&gt;get('-f'); \/\/ [true, true, true] ?&gt; If the user passes options that do not conform to the definitions, the GetoptValues object retains various errors related to the parsing failures. In these cases, hasErrors() will return true, and you can then review the errors. (The errors are actually Aura\\Cli\\Exception objects, but they don't get thrown as they occur; this is so that you can deal with or ignore the different kinds of errors as you like.)&lt;?php $getopt = $context-&gt;getopt($options); if ($getopt-&gt;hasErrors()) { $errors = $getopt-&gt;getErrors(); foreach ($errors as $error) { \/\/ print error messages to stderr using a Stdio object $stdio-&gt;errln($error-&gt;getMessage()); } }; ?&gt; "},{"id":"\/packages\/2.x\/Cli.html#4-4-2-2-2","title":"4.4.2.2.2. Positional Arguments","content":"To get the positional arguments passed to the command line, use the get() method and the argument position number:&lt;?php $getopt = $context-&gt;getopt($options); \/\/ if the script was invoked with: \/\/ php script.php arg1 arg2 arg3 arg4 $val0 = $getopt-&gt;get(0); \/\/ script.php $val1 = $getopt-&gt;get(1); \/\/ arg1 $val2 = $getopt-&gt;get(2); \/\/ arg2 $val3 = $getopt-&gt;get(3); \/\/ arg3 $val4 = $getopt-&gt;get(4); \/\/ arg4 ?&gt; Defined options will be removed from the arguments automatically.&lt;?php $options = array( 'a', 'foo:', ); $getopt = $context-&gt;getopt($options); \/\/ if the script was invoked with: \/\/ php script.php arg1 --foo=bar -a arg2 $arg0 = $getopt-&gt;get(0); \/\/ script.php $arg1 = $getopt-&gt;get(1); \/\/ arg1 $arg2 = $getopt-&gt;get(2); \/\/ arg2 $foo = $getopt-&gt;get('--foo'); \/\/ bar $a = $getopt-&gt;get('-a'); \/\/ 1 ?&gt;  N.b.: If a short flag has an optional parameter, the argument immediately after it will be treated as the option value, not as an argument. "},{"id":"\/packages\/2.x\/Cli.html#4-4-2-3","title":"4.4.2.3. Standard Input\/Output Streams","content":"The Stdio object allows you to work with standard input\/output streams. (This is the command line equivalent of a web response object.)Instantiate a Stdio object using the CliFactory.&lt;?php use Aura\\Cli\\CliFactory; $cli_factory = new CliFactory; $stdio = $cli_factory-&gt;newStdio(); ?&gt; It defaults to using php:\/\/stdin, php:\/\/stdout, and php:\/\/stderr, but you can pass whatever stream names you like as parameters to the newStdio() method.The Stdio object methods are ... getStdin(), getStdout(), and getStderr() to return the respective Handle objects; outln() and out() to print to stdout, with or without a line ending; errln() and err() to print to stderr, with or without a line ending; inln() and in() to read from stdin until the user hits enter; inln() leaves the trailing line ending in place, whereas in() strips it. You can use special formatting markup in the output and error strings to set text color, text weight, background color, and other display characteristics. See the formatter cheat sheet below.&lt;?php \/\/ print to stdout $stdio-&gt;outln('This is normal text.'); \/\/ print to stderr $stdio-&gt;errln('&lt;&lt;red&gt;&gt;This is an error in red.'); $stdio-&gt;errln('Output will stay red until a formatting change.&lt;&lt;reset&gt;&gt;'); ?&gt; "},{"id":"\/packages\/2.x\/Cli.html#4-4-2-4","title":"4.4.2.4. Exit Codes","content":"This library comes with a Status class that defines constants for exit status codes. You should use these whenever possible. For example, if a command is used with the wrong number of arguments or improper option flags, exit() with Status::USAGE. The exit status codes are the same as those found in sysexits.h."},{"id":"\/packages\/2.x\/Cli.html#4-4-2-5","title":"4.4.2.5. Writing Commands","content":"The Aura.Cli library does not come with an abstract or base command class to extend from, but writing commands for yourself is straightforward. The following is a standalone command script, but similar logic can be used in a class. Save it in a file named hello and invoke it with php hello [-v,--verbose] [name].&lt;?php use Aura\\Cli\\CliFactory; use Aura\\Cli\\Status; require '\/path\/to\/Aura.Cli\/autoload.php'; \/\/ get the context and stdio objects $cli_factory = new CliFactory; $context = $cli_factory-&gt;newContext($GLOBALS); $stdio = $cli_factory-&gt;newStdio(); \/\/ define options and named arguments through getopt $options = ['verbose,v']; $getopt = $context-&gt;getopt($options); \/\/ do we have a name to say hello to? $name = $getopt-&gt;get(1); if (! $name) { \/\/ print an error $stdio-&gt;errln(\"Please give a name to say hello to.\"); exit(Status::USAGE); } \/\/ say hello if ($getopt-&gt;get('--verbose')) { \/\/ verbose output $stdio-&gt;outln(\"Hello {$name}, it's nice to see you!\"); } else { \/\/ plain output $stdio-&gt;outln(\"Hello {$name}!\"); } \/\/ done! exit(Status::SUCCESS); ?&gt; "},{"id":"\/packages\/2.x\/Cli.html#4-4-2-6","title":"4.4.2.6. Writing Command Help","content":"Sometimes it will be useful to provide help output for your commands. With Aura.Cli, the Help object is separate from any command you may write. It may be manipulated externally or extended.For example, extend the Help object and override the init() method.&lt;?php use Aura\\Cli\\Help; class MyCommandHelp extends Help { protected function init() { $this-&gt;setSummary('A single-line summary.'); $this-&gt;setUsage('&lt;arg1&gt; [&lt;arg2&gt;]'); $this-&gt;setOptions(array( 'f,foo' =&gt; \"The -f\/--foo option description.\", 'bar::' =&gt; \"The --bar option description.\", )); $this-&gt;setDescr(\"A multi-line description of the command.\"); } } ?&gt; Then instantiate the new class and pass its getHelp() output through Stdio:&lt;?php use Aura\\Cli\\CliFactory; use Aura\\Cli\\Context\\OptionFactory; $cli_factory = new CliFactory; $stdio = $cli_factory-&gt;newStdio(); $help = new MyCommandHelp(new OptionFactory); $stdio-&gt;outln($help-&gt;getHelp('my-command')); ?&gt;  We keep the command name itself outside of the help class, because the command name may be mapped differently in different projects. We pass a GetoptParser to the Help object so it can parse the option definitions. We can get the option definitions out of the Help object using getOptions(); this allows us to pass a Help object into a hypothetical command object and reuse the definitions. The output will look something like this:SUMMARY my-command -- A single-line summary. USAGE my-command &lt;arg1&gt; [&lt;arg2&gt;] DESCRIPTION A multi-line description of the command. OPTIONS -f --foo The -f\/--foo option description. --bar[=&lt;value&gt;] The --bar option description. As a side note, the array of options passed to setOptions() may contain argument descriptions as well. These are in the format #argname (to indicate a required argument) and #argname? (to indicate an optional argument). They may additionally be used as keys, with corresponding description values. Their presence in a Getopt definition array is ignored, but the Help object will read them and generate output for them automatically.For example, the following code (notice the lack of a setUsage() call)...&lt;?php use Aura\\Cli\\CliFactory; use Aura\\Cli\\Context\\OptionFactory; use Aura\\Cli\\Help; $cli_factory = new CliFactory; $stdio = $cli_factory-&gt;newStdio(); $help = new Help(new OptionFactory); $this-&gt;setSummary('A single-line summary.'); $help-&gt;setOptions(array( 'f,foo' =&gt; \"The -f\/--foo option description.\", 'bar::' =&gt; \"The --bar option description.\", '#arg1' =&gt; \"The description for argument 1.\", '#arg2?' =&gt; \"The description for argument 2.\", )); $this-&gt;setDescr(\"A multi-line description of the command.\"); $stdio-&gt;outln($help-&gt;getHelp('my-command')); ?&gt; ... will generate the following output:SUMMARY my-command -- A single-line summary. USAGE my-command &lt;arg1&gt; [&lt;arg2&gt;] DESCRIPTION A multi-line description of the command. ARGUMENTS &lt;foo&gt; The description for argument 1. &lt;bar&gt; The description for argument 2. OPTIONS -f --foo The -f\/--foo option description. --bar[=&lt;value&gt;] The --bar option description. "},{"id":"\/packages\/2.x\/Cli.html#4-4-2-7","title":"4.4.2.7. Formatter Cheat Sheet","content":"On POSIX terminals, &lt;&lt;markup&gt;&gt; strings will change the display characteristics. Note that these are not HTML tags; they will be converted into terminal control codes, and do not get \"closed\". You can place as many space-separated markup codes between the double angle-brackets as you like.reset reset display to defaults black black text red red text green green text yellow yellow text blue blue text magenta magenta (purple) text cyan cyan (light blue) text white white text blackbg black background redbg red background greenbg green background yellowbg yellow background bluebg blue background magentabg magenta (purple) background cyanbg cyan (light blue) background whitebg white background bold bold in the current text and background colors dim dim in the current text and background colors ul underline in the current text and background colors blink blinking in the current text and background colors reverse reverse the current text and background colors For example, to set bold white text on a red background, add &lt;&lt;bold white redbg&gt;&gt; into your output or error string. Reset back to normal with &lt;&lt;reset&gt;&gt;."},{"id":"\/packages\/2.x\/Di.html#4-5","title":"4.5. Aura.Di","content":"The Aura.Di package provides a dependency injection container system with the following features: constructor and setter injection explicit and implicit auto-resolution of typehinted constructor parameter values configuration of setters across interfaces and traits inheritance of constructor parameter and setter method values lazy-loaded services, values, and instances instance factories Fully describing the nature and benefits of dependency injection, while desirable, is beyond the scope of this document. For more information about \"inversion of control\" and \"dependency injection\" please consult http:\/\/martinfowler.com\/articles\/injection.html by Martin Fowler.Finally, please note that this package is intended for use as a dependency injection system, not as a service locator system. If you use it as a service locator, that's bad, and you should feel bad."},{"id":"\/packages\/2.x\/Di.html#4-5-1-1","title":"4.5.1.1. Installation","content":"This library requires PHP 5.3 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/di.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/Di.html#4-5-1-2","title":"4.5.1.2. Quality","content":" To run the unit tests at the command line, issue composer install and then phpunit at the package root. This requires Composer to be available as composer, and PHPUnit to be available as phpunit.This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/Di.html#4-5-1-3","title":"4.5.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with other Aura users, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/Di.html#4-5-2-1","title":"4.5.2.1. Instantiation","content":"We instantiate a Container like so:&lt;?php use Aura\\Di\\Container; use Aura\\Di\\Factory; $di = new Container(new Factory); ?&gt; We can then set shared services on the container. Additionally, we can add default constructor parameters and setter method values to be used on new class instances, along with other values as well."},{"id":"\/packages\/2.x\/Di.html#4-5-2-2","title":"4.5.2.2. Setting And Getting Services","content":"A \"service\" is an object stored in the Container under a unique name. Any time you get() the named service, you always get back the same object instance.&lt;?php \/\/ define the Example class class Example { \/\/ ... } \/\/ set the service $di-&gt;set('service_name', new Example); \/\/ get the service $service1 = $di-&gt;get('service_name'); $service2 = $di-&gt;get('service_name'); \/\/ the two service objects are the same var_dump($service1 === $service2); \/\/ true ?&gt; That usage is great if we want to create the Example instance at the same time we set the service. However, we generally want to create the service instance at the moment we get it, not at the moment we set it.The technique of delaying instantiation until get() time is called \"lazy loading.\" To lazy-load an instance, use the lazyNew() method on the Container and give it the class name to be created:&lt;?php \/\/ set the service as a lazy-loaded new instance $di-&gt;set('service_name', $di-&gt;lazyNew('Example')); ?&gt; Now the service is created only when we we get() it, and not before. This lets us set as many services as we want, but only incur the overhead of creating the instances we actually use."},{"id":"\/packages\/2.x\/Di.html#4-5-2-3","title":"4.5.2.3. Constructor Injection","content":"When we use the Container to instantiate a new object, we often need to inject (i.e., set) constructor parameter values in various ways."},{"id":"\/packages\/2.x\/Di.html#4-5-2-3-1","title":"4.5.2.3.1. Default Parameter Values","content":"We can define default values for constructor parameters using the $di-&gt;params array on the Container.Let's look at a class that takes some constructor parameters:&lt;?php class ExampleWithParams { protected $foo; protected $bar; public function __construct($foo, $bar) { $this-&gt;foo = $foo; $this-&gt;bar = $bar; } } ?&gt; If we were to try to set a service using $di-&gt;lazyNew('ExampleWithParams'), the instantiation would fail. The $foo param is required, and the Container does not know what to use for that value.To remedy this, we tell the Container what values to use for each ExampleWithParams constructor parameter by name using the $di-&gt;params array:&lt;?php $di-&gt;params['ExampleWithParams']['foo'] = 'foo_value'; $di-&gt;params['ExampleWithParams']['bar'] = 'bar_value'; ?&gt; Now when a service is defined with $di-&gt;lazyNew('ExampleWithParams'), the instantiation will work correctly. Each time we create an ExampleWithParams instance through the Container, it will apply the $di-&gt;params['ExampleWithParams'] values."},{"id":"\/packages\/2.x\/Di.html#4-5-2-3-2","title":"4.5.2.3.2. Instance-Specific Parameter Values","content":"If we want to override the default $di-&gt;params values for a specific new instance, we can pass a $params array as the second argument to lazyNew() to merge with the default values. For example:&lt;?php $di-&gt;set('service_name', $di-&gt;lazyNew( 'ExampleWithParams', array( 'bar' =&gt; 'alternative_bar_value', ) )); ?&gt; This will leave the $foo parameter default in place, and override the $bar parameter value, for just that instance of the ExampleWithParams."},{"id":"\/packages\/2.x\/Di.html#4-5-2-3-3","title":"4.5.2.3.3. Lazy-Loaded Services As Parameter Values","content":"Sometimes a class will need another service as one of its parameters. By way of example, the following class needs a database connection:&lt;?php class ExampleNeedsService { protected $db; public function __construct($db) { $this-&gt;db = $db; } } ?&gt; To inject a shared service as a parameter value, use $di-&gt;lazyGet() so that the service object is not created until the ExampleNeedsService object is created:&lt;?php $di-&gt;params['ExampleNeedsService']['db'] = $di-&gt;lazyGet('db_service'); ?&gt; This keeps the service from being created until the very moment it is needed. If we never instantiate anything that needs the service, the service itself will never be instantiated."},{"id":"\/packages\/2.x\/Di.html#4-5-2-3-4-1","title":"4.5.2.3.4.1. A Note About Auto-Resolution","content":"Auto-resolution turns out to be difficult to debug in many situations. We regret to say that we did not appreciate how difficult until after the feature was released as stable in a major version. As such, we cannot remove it until the next major version.To mitigate these difficulties, we recommend you always disable auto-resolution when developing shared packages. Further, we suggest you consider disabling auto-resolution when developing or debugging an application built on shared packages.Auto-resolution is enabled by default. You can disable auto-resolution by calling $di-&gt;setAutoResolve(false)."},{"id":"\/packages\/2.x\/Di.html#4-5-2-3-4-2","title":"4.5.2.3.4.2. How Auto-Resolution Works","content":"If there is no $di-&gt;params value for a parameter, the Container will fill in the constructor default value.If the parameter is typehinted as an array but there is no $di-&gt;params value and also no default value, the Container will fill in an empty array().If the parameter is typehinted to a class but there is no $di-&gt;params value for that parameter and also no default value, the Container will fill in a lazyNew() call to the typehinted class.For example, look at the following class; it has a parameter with a default value, a parameter typehinted as an array with no default, and a parameter typehinted to a class with no default:&lt;?php class ExampleForAutoResolution { public function __construct(array $baz, Example $dib, $foo = 'bar') { \/\/ ... } } ?&gt; For each relevant $di-&gt;params['ExampleForAutoResolution'] element that is missing, the Container will auto-resolve the missing elements to these values:&lt;?php $di-&gt;params['ExampleForAutoResolution']['baz'] = array(); $di-&gt;params['ExampleForAutoResolution']['dib'] = $di-&gt;lazyNew('Example'); $di-&gt;params['ExampleForAutoResolution']['foo'] = 'bar'; ?&gt; We can set any combination of these explicitly, and those that are not explicitly set will be filled in automatically for us.(Note that we cannot auto-resolve an array typehint; such typehints are always resolved to an empty array() when no default value is present.)"},{"id":"\/packages\/2.x\/Di.html#4-5-2-3-4-3","title":"4.5.2.3.4.3. Explicitly Directing Auto-Resolution Typehints","content":"We can direct the auto-resolution of class-typehinted constructor parameters by using the $di-&gt;types array. This allows us to avoid having to specify $di-&gt;params for every typehinted constructor parameter in every class. (Note that we can still specify explicit params on a specific class to override the auto-resolution.)We can specify auto-resolution to a new instance of a class of our choosing ...&lt;?php \/\/ auto-resolve all 'ExampleInterface' typehints to a new 'Example' instance $di-&gt;types['ExampleInterface'] = $di-&gt;lazyNew('Example'); \/\/ auto-resolve all 'ExampleParent' typehints to a different concrete class $di-&gt;types['ExampleParent'] = $di-&gt;lazyNew('ExampleChild'); ?&gt; ... or to a shared service (aka singleton) of our own choosing:&lt;?php \/\/ auto-resolve all 'Db' and 'DbInterface' typehints to a shared service $di-&gt;types['Db'] = $di-&gt;lazyGet('db_service'); $di-&gt;types['DbInterface'] = $di-&gt;lazyGet('db_service'); ?&gt; "},{"id":"\/packages\/2.x\/Di.html#4-5-2-4","title":"4.5.2.4. Setter Injection","content":"This package supports setter injection in addition to constructor injection. (These can be combined as needed.)"},{"id":"\/packages\/2.x\/Di.html#4-5-2-4-1","title":"4.5.2.4.1. Setter Method Values","content":"After the Container constructs a new instance of an object, we can specify that certain methods should be called with certain values immediately after instantiation by using the $di-&gt;setter array. Say we have class like the following:&lt;?php class ExampleWithSetter { protected $foo; public function setFoo($foo) { $this-&gt;foo = $foo; } } ?&gt; We can specify that, by default, the setFoo() method should be called with a specific value after construction like so:&lt;?php $di-&gt;setter['ExampleWithSetter']['setFoo'] = 'foo_value'; ?&gt; The value can be any valid value: a literal, a call to lazyNew() or lazyGet(), and so on.Note, however, that auto-resolution does not apply to setter methods. This is because the Container does not know which methods are setters and which are \"normal use\" methods.Note also that this works only with explicitly-defined setter methods. Setter methods that exist only via magic __call() will not be honored."},{"id":"\/packages\/2.x\/Di.html#4-5-2-4-2","title":"4.5.2.4.2. Setters In Traits and Interfaces","content":"If a class uses a setter method via a trait, or implements an interface with a setter method, we can specify the default value for that setter method in relation to the trait or interface. That value will then be applied by default in every class that uses that trait or implements that interface.For example, let's say we have this trait, interface, and class:&lt;?php trait ExampleFooTrait { public function setFoo($foo) { $this-&gt;foo = $foo; } } interface ExampleBarInterface { public function setBar($bar); } class ExampleWithTraitAndInterface implements ExampleBarInterface { use ExampleFooTrait; protected $foo; protected $bar; public function setBar($bar) { $this-&gt;bar = $bar; } } ?&gt; We then define the default setter method values on the trait and interface:&lt;?php $di-&gt;setter['ExampleFooTrait']['setFoo'] = 'foo_value'; $di-&gt;setter['ExampleBarInterface']['setBar'] = 'bar_value'; ?&gt; When we call $di-&gt;lazyNew('ExampleWithTraitAndInterface'), those setter methods will be called by the Container with those values.Note that if we have class-specific $di-&gt;setter values, those will take precedence over the trait and interface setter values."},{"id":"\/packages\/2.x\/Di.html#4-5-2-4-3","title":"4.5.2.4.3. Instance-Specific Setter Values","content":"As with constructor injection, we can note instance-specific setter values to use in place of the defaults. We do so via the third argument to $di-&gt;lazyNew(). For example:&lt;?php $di-&gt;set('service_name', $di-&gt;lazyNew( 'ExampleWithSetters', array(), \/\/ no $params overrides array( 'setFoo' =&gt; 'alternative_foo_value', ) )); ?&gt; "},{"id":"\/packages\/2.x\/Di.html#4-5-2-5","title":"4.5.2.5. Lazy Values","content":"Sometimes we know that a parameter needs to be specified, but we don't know what it will be until later. Perhaps it is the result of looking up an API key from an environment variable. In these and other cases, we can tell a constructor parameter or setter method to use a \"lazy value\" and then specify that value elsewhere.For example, we can configure the Example constructor parameters to use lazy values like so:&lt;?php $di-&gt;params['Example']['foo'] = $di-&gt;lazyValue('fooval'); $di-&gt;params['Example']['bar'] = $di-&gt;lazyValue('barval'); ?&gt; We can then specify at some later time the values of fooval and barval using the $di-&gt;values array:&lt;?php $di-&gt;values['fooval'] = 'lazy value for foo'; $di-&gt;values['barval'] = 'lazy value for bar'; ?&gt; "},{"id":"\/packages\/2.x\/Di.html#4-5-2-6","title":"4.5.2.6. Lazy Include and Require","content":"Occasionally we will need to include a file that returns a value, such as data file that returns a PHP array:&lt;?php \/\/ \/path\/to\/data.php return array( 'foo' =&gt; 'bar', 'baz' =&gt; 'dib', 'zim' =&gt; 'gir' ); ?&gt; We could set a constructor parameter or setter method value to include \"\/path\/to\/data.php\", but that would cause the file to be read filesystem at that moment, instead of at instantiation time. To lazy-load a file as a value, call $di-&gt;lazyInclude() or $di-&gt;lazyRequire() (depending on your preference for warning levels).&lt;?php $di-&gt;params['ExampleNeedsInclude']['data'] = $di-&gt;lazyInclude('\/path\/to\/data.php'); $di-&gt;params['ExampleNeedsRequire']['data'] = $di-&gt;lazyRequire('\/path\/to\/data.php'); ?&gt; "},{"id":"\/packages\/2.x\/Di.html#4-5-2-7","title":"4.5.2.7. Generic Lazy Calls","content":"It may be that we have a complex bit of logic we need to execute for a value. If none of the existing $di-&gt;lazy*() methods meet our needs, we can wrap an anonymous function or other callable in a lazy() call, and the callable's return will be used as the value.&lt;?php $di-&gt;params['Example']['foo'] = $di-&gt;lazy(function () { \/\/ complex calculations, and then: return $result; }); ?&gt; Beware of relying on this too much; if we do, it probably means we need to separate our configuration concerns better than we are currently doing."},{"id":"\/packages\/2.x\/Di.html#4-5-2-8","title":"4.5.2.8. Instance Factory Objects","content":"Occasionally, a class will need to receive not just an instance, but a factory that is capable of creating a new instance over and over. For example, say we have a class like the following:&lt;?php class ExampleNeedsFactory { protected $struct_factory; public function __construct($struct_factory) { $this-&gt;struct_factory = $struct_factory; } public function getStruct(array $data) { $struct = $this-&gt;struct_factory-&gt;__invoke($data); return $struct; } } class ExampleStruct { public function __construct(array $data) { foreach ($data as $key =&gt; $val) { $this-&gt;$key = $val; } } } ?&gt; We can inject an InstanceFactory that creates only ExampleStruct objects using $di-&gt;newFactory().&lt;?php $di-&gt;params['ExampleNeedsFactory']['struct_factory'] = $di-&gt;newFactory('ExampleStruct'); ?&gt; Note that the arguments passed to the factory __invoke() method will be passed to the underlying instance constructor sequentially, not by name. This means the __invoke() method works more like the native new keyword, and not like $di-&gt;lazyNew(). These arguments override any $di-&gt;params values that have been set for the class being factoried; without the overrides, all existing $di-&gt;params values for that class will be honored. (Values from $di-&gt;setter for the class will also be honored, but cannot be overriddden.)Do not feel limited by the InstanceFactory implementation. We can create and inject factory objects of our own if we like. The InstanceFactory returned by the $di-&gt;newFactory() method is an occasional convenience, nothing more."},{"id":"\/packages\/2.x\/Di.html#4-5-2-9","title":"4.5.2.9. Inheritance Of Parent Values","content":"Whether by constructor parameters or setter methods, each class \"inherits\" the values of its parents by default. This means we can set a value on a parent class, and the child class will use it (that is, unless we set an overriding value on the child class).For example, let's say we have this parent class and this child class:&lt;?php class ExampleParent { protected $foo; protected $bar; public function __construct($foo) { $this-&gt;foo = $foo; } public function setBar($bar) { $this-&gt;bar = $bar; } } class ExampleChild extends ExampleParent { protected $baz; public function setBaz($baz) { $this-&gt;baz = $baz; } } ?&gt; We can specify the default values for every class that extends ExampleParent through the $di-&gt;params and $di-&gt;setter values for the ExampleParent.&lt;?php $di-&gt;params['ExampleParent']['foo'] = 'parent_foo'; $di-&gt;setter['ExampleParent']['setBar'] = 'parent_bar'; ?&gt; When we call $di-&gt;lazyNew('ExampleChild'), the child class will have inherited the defaults from the parent.We can always override the inherited values by specifying them for the child class directly:&lt;?php $di-&gt;params['ExampleChild']['foo'] = 'child_foo'; $di-&gt;setter['ExampleChild']['setBaz'] = 'child_baz'; ?&gt; Note that classes extended from the child class will then inherit those new values. In this way, constructor parameter and setter method values are propagated down the inheritance hierarchy."},{"id":"\/packages\/2.x\/Di.html#4-5-2-10","title":"4.5.2.10. Container Builder and Config Classes","content":"The ContainerBuilder helps to build Container objects from Config classes and pre-existing service objects. It works using a two-stage configuration system.The two stages are \"define\" and \"modify\". In the \"define\" stage, the Config object defines constructor parameter values, setter method values, services, and so on. The ContainerBuilder then locks the Container so that these definitions cannot be changed, and begins the \"modify\" stage. In the \"modify\" stage, we may get() services from the Container and modify them programmatically if needed.To build a Container using the ContainerBuilder, we do something like the following:&lt;?php use Aura\\Di\\ContainerBuilder; \/\/ pre-existing service objects as ['service_name' =&gt; $object_instance] $services = array(); \/\/ config classes to call define() and modify() on $config_classes = array( 'Aura\\Cli\\_Config\\Common', 'Aura\\Router\\_Config\\Common', 'Aura\\Web\\_Config\\Common', ); \/\/ should auto-resolve be enabled or disabled? \/\/ ENABLE_AUTO_RESOLVE is the default; \/\/ use DISABLE_AUTO_RESOLVE to disable it. $auto_resolve = ContainerBuilder::ENABLE_AUTO_RESOLVE; \/\/ use the builder to create a container $container_builder = new ContainerBuilder; $di = $container_builder-&gt;newInstance( $services, $config_classes, $auto_resolve ); ?&gt; A configuration class looks like the following:&lt;?php namespace Vendor\\Package\\_Config; use Aura\\Di\\Config; use Aura\\Di\\Container; class Common extends Config { public function define(Container $di) { $di-&gt;set('log_service', $di-&gt;lazyNew('Logger')); $di-&gt;params['Logger']['dir'] = '\/path\/to\/logs'; } public function modify(Container $di) { $log = $di-&gt;get('log_service'); $log-&gt;debug('Finished config.'); } } ?&gt; Here are some example Config classes from other Aura packages: Aura.Cli Aura.Html Aura.Router Aura.View "},{"id":"\/packages\/2.x\/Di.html#4-5-2-11","title":"4.5.2.11. Conclusion","content":"If we construct our dependencies properly with params, setters, services, and factories, we will only need to get one object directly from the Container in our bootstrap file. All object creation will then occur within Container itself or the various factory objects. We will never need to use the Container itself in any of our application objects."},{"id":"\/packages\/2.x\/Dispatcher.html#4-6","title":"4.6. Aura.Dispatcher","content":"Provides tools to map arbitrary names to dispatchable objects, then to dispatch to those objects using named parameters. This is useful for invoking controller and command objects based on path-info parameters or command line arguments, for dispatching to closure-based controllers, and for building dispatchable objects from factories."},{"id":"\/packages\/2.x\/Dispatcher.html#4-6-1-1","title":"4.6.1.1. Installation","content":"This library requires PHP 5.4 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/dispatcher.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/Dispatcher.html#4-6-1-2","title":"4.6.1.2. Quality","content":" To run the unit tests at the command line, issue phpunit at the package root. (This requires PHPUnit to be available as phpunit.)This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/Dispatcher.html#4-6-1-3","title":"4.6.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/Dispatcher.html#4-6-2-1","title":"4.6.2.1. Overview","content":"First, an external routing mechanism such as Aura.Router or a micro-framework router creates an array of parameters. (Alternatively, the parameters may be an object that implements ArrayAccess).The parameters are then passed to the Dispatcher. It examines them and picks an object to invoke with those parameters, optionally with a method determined by the parameters.The Dispatcher then examines the returned result from that first invocation. If the result is itself a dispatchable object, the Dispatcher will recursively dispatch the result until something other than a dispatchable object is returned.When a non-dispatchable result is returned, the Dispatcher stops recursion and returns the non-dispatchable result."},{"id":"\/packages\/2.x\/Dispatcher.html#4-6-2-2","title":"4.6.2.2. Closures and Invokable Objects","content":"First, we tell the Dispatcher to examine the controller parameter to find the name of the object to dispatch to:&lt;?php use Aura\\Dispatcher\\Dispatcher; $dispatcher = new Dispatcher; $dispatcher-&gt;setObjectParam('controller'); ?&gt; Next, we set a closure object into the Dispatcher using setObject():&lt;?php $dispatcher-&gt;setObject('blog', function ($id) { return \"Read blog entry $id\"; }); ?&gt; We can now dispatch to that closure by using the name as the value for the controller parameter:&lt;?php $params = [ 'controller' =&gt; 'blog', 'id' =&gt; 88, ]; $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; The same goes for invokable objects. First, define a class with an __invoke() method:&lt;?php class InvokableBlog { public function __invoke($id) { return \"Read blog entry $id\"; } } ?&gt; Next, set an instance of the object into the Dispatcher:&lt;?php $dispatcher-&gt;setObject('blog', new InvokableBlog); ?&gt; Finally, dispatch to the invokable object (the parameters and logic are the same as above):&lt;?php $params = [ 'controller' =&gt; 'blog', 'id' =&gt; 88, ]; $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; "},{"id":"\/packages\/2.x\/Dispatcher.html#4-6-2-3","title":"4.6.2.3. Object Method","content":"We can tell the Dispatcher to examine the params for a method to call on the object. This method will take precedence over the __invoke() method on an object, if such a method exists.First, tell the Dispatcher to examine the value of the action param to find the name of the method it should invoke.&lt;?php $dispatcher-&gt;setMethodParam('action'); ?&gt; Next, define the object we will dispatch to; note that the method is read() instead of __invoke().&lt;?php class Blog { public function read($id) { return \"Read blog entry $id\"; } } ?&gt; Then, we set the object into the Dispatcher ...&lt;?php $dispatcher-&gt;setObject('blog', new Blog); ?&gt; ... and finally, we invoke the Dispatcher; we have added an action parameter with the name of the method to invoke:&lt;?php $params = [ 'controller' =&gt; 'blog', 'action' =&gt; 'read', 'id' =&gt; 88, ]; $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; "},{"id":"\/packages\/2.x\/Dispatcher.html#4-6-2-4","title":"4.6.2.4. Embedding Objects in Parameters","content":"If you like, you can place dispatchable objects directly in the parameters. (This is often how micro-framework routers work.) For example, let's put a closure into the controller parameter; when we invoke the Dispatcher, it will invoke that closure.&lt;?php $params = [ 'controller' =&gt; function ($id) { return \"Read blog entry $id\"; }, 'id' =&gt; 88, ]; $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; The same is true for invokable objects ...&lt;?php $params = [ 'controller' =&gt; new InvokableBlog, 'id' =&gt; 88, ]; $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; ... and for object-methods:&lt;?php $params = [ 'controller' =&gt; new Blog, 'action' =&gt; 'read', 'id' =&gt; 88, ]; $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; "},{"id":"\/packages\/2.x\/Dispatcher.html#4-6-2-5","title":"4.6.2.5. Recursion and Lazy Loading","content":"The Dispatcher is recursive. After dispatching to the first object, if that object returns a dispatchable object, the Dispatcher will re-dispatch to that object. It will continue doing this until the returned result is not a dispatchable object.Let's turn the above example of an invokable object in the Dispatcher into a lazy-loaded instantiation. All we have to do is wrap the instantiation in another dispatchable object (in this example, a closure). The benefit of this is that we can fill the Dispatcher with as many objects as we like, and they won't get instantiated until the Dispatcher calls on them.&lt;?php $dispatcher-&gt;setObject('blog', function () { return new Blog; }); ?&gt; Then we invoke the dispatcher with the same params as before.&lt;?php $params = [ 'controller' =&gt; 'blog', 'action' =&gt; 'read', 'id' =&gt; 88, ]; $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; What happens is this: The Dispatcher finds the 'blog' dispatchable object, sees that it is a closure, and invokes it with the params. The Dispatcher examines the result, sees the result is a dispatchable object, and invokes it with the params. The Dispatcher examines that result, sees that it is not a callable object, and returns the result. "},{"id":"\/packages\/2.x\/Dispatcher.html#4-6-3","title":"4.6.3. Sending The Array Of Params Directly","content":"Sometimes you will want to send the entire array of parameters directly to the object method or closure, as opposed to matching parameter keys with function argument names. To do so, name a key in the parameters array for the argument name that will receive them, and then set the parameters array into itself using that name. If may be easier to do this by reference, or by copy, depending on your needs.&lt;?php \/\/ a dispatchable closure that takes an array of params directly, \/\/ not the individual params by keys matching argument names $dispatcher-&gt;setObject('blog', function ($params) { return \"Read blog entry {$params['id']}\" }); \/\/ the initial params $params = [ 'controller' =&gt; 'blog', 'action' =&gt; 'read', 'id' =&gt; 88, ]; \/\/ set a params reference into itself; this corresponds with the \/\/ 'params' closure argument $params['params'] =&amp; $params; \/\/ dispatch $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; "},{"id":"\/packages\/2.x\/Dispatcher.html#4-6-4","title":"4.6.4. Refactoring To Architecture Changes","content":"The Dispatcher is built with the idea that some developers may begin with a micro-framework architecture, and evolve over time toward a full-stack architecture.At first, the developer uses closures embedded in the params:&lt;?php $dispatcher-&gt;setObjectParam('controller'); $params = [ 'controller' =&gt; function ($id) { return \"Read blog entry $id\"; }, 'id' =&gt; 88, ]; $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; After adding several controllers, the developer is likely to want to keep the routing configurations separate from the controller actions. At this point the developer may start putting the controller actions in the Dispatcher:&lt;?php $dispatcher-&gt;setObject('blog', function ($id) { return \"Read blog entry $id!\"; }); $params = [ 'controller' =&gt; 'blog', 'id' =&gt; 88, ]; $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; As the number and complexity of controllers continues to grow, the developer may wish to put the controllers into their own classes, lazy-loading along the way:&lt;?php class Blog { public function __invoke($id) { return \"Read blog entry $id\"; } } $dispatcher-&gt;setObject('blog', function () { return new Blog; }); $params = [ 'controller' =&gt; 'blog', 'id' =&gt; 88, ]; $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; Finally, the developer may collect several actions into a single controller, keeping related functionality in the same class. At this point the developer should call setMethodParam() to tell the Dispatcher where to find the method to invoke on the dispatchable object.&lt;?php class Blog { public function browse() { \/\/ ... } public function read($id) { return \"Read blog entry $id\"; } public function edit($id) { \/\/ ... } public function add() { \/\/ ... } public function delete($id) { \/\/ ... } } $dispatcher-&gt;setMethodParam('action'); $dispatcher-&gt;setObject('blog', function () { return new Blog; }); $params = [ 'controller' =&gt; 'blog', 'action' =&gt; 'read', 'id' =&gt; 88, ]; $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; "},{"id":"\/packages\/2.x\/Dispatcher.html#4-6-5","title":"4.6.5. Construction-Based Configuration","content":"You can set all dispatchable objects, along with the object parameter name and the method parameter name, at construction time. This makes it easier to configure the Dispatcher object in a single call.&lt;?php $object_param = 'controller'; $method_param = 'action'; $objects = [ 'blog' =&gt; function () { return new BlogController; }, 'wiki' =&gt; function () { return new WikiController; }, 'forum' =&gt; function () { return new ForumController; }, ]; $dispatcher = new Dispatcher($objects, $object_param, $method_param); ?&gt; "},{"id":"\/packages\/2.x\/Dispatcher.html#4-6-6","title":"4.6.6. Intercessory Dispatch Methods","content":"Sometimes your classes will have an intercessory method that picks an action to run, either on itself or on another object. This package provides an InvokeMethodTrait to invoke a method on an object using named parameters. (The InvokeMethodTrait honors protected and private scopes.)&lt;?php use Aura\\Dispatcher\\InvokeMethodTrait; class Blog { use InvokeMethodTrait; public function __invoke(array $params) { $action = isset($params['action']) ? $params['action'] : 'index'; $method = 'action' . ucfirst($action); return $this-&gt;invokeMethod($this, $method, $params); } protected function actionRead($id = null) { return \"Read blog entry $id\"; } } ?&gt; You can then dispatch to the object as normal, and it will determine its own logical flow.&lt;?php $dispatcher-&gt;setObject('blog', function () { return new Blog; }); $params = [ 'controller' =&gt; 'blog', 'action' =&gt; 'read', 'id' =&gt; 88, ]; $result = $dispatcher($params); \/\/ or call __invoke() directly echo $result; \/\/ \"Read blog entry 88\" ?&gt; "},{"id":"\/packages\/2.x\/Filter\/getting-started.html#4-7-1-1","title":"4.7.1.1. Terminology","content":"Unfortunately, there are not many common terms shared between filtering\/validating\/etc. libraries. To clear up misconception, this library uses the following definitions: \"filter\": validate and\/or sanitize one or more fields \"validate\": determine if a field value conforms to a particular format, but do not modify the field value \"sanitize\": modify, transform, or otherwise force a field value to conform to a particular format This library also makes a distinction between a \"value\" filter and a \"subject\" filter: A \"value\" filter validates and sanitizes an individual value A \"subject\" filter validates and sanitzes the collection of elements in an array, or the collection of properties in an object. (The \"subject\" is the array or object.) "},{"id":"\/packages\/2.x\/Filter\/getting-started.html#4-7-1-2","title":"4.7.1.2. Filter Container","content":"The easiest way to interact with the filter system is via the FilterFactory. Instantiate it first; you can then get filter objects from it:use Aura\\Filter\\FilterFactory; $filter_factory = new FilterFactory(); $filter = $filter_factory-&gt;newValueFilter(); $filter = $filter_factory-&gt;newSubjectFilter(); "},{"id":"\/packages\/2.x\/Filter\/value-filter.html#4-7-2","title":"4.7.2. Filtering Individual Values","content":"You can filter an individual value by using a ValueFilter."},{"id":"\/packages\/2.x\/Filter\/value-filter.html#4-7-2-1","title":"4.7.2.1. Using A Value Filter","content":"First, create a ValueFilter object from the FilterFactory:$filter = $filter_factory-&gt;newValueFilter(); Then, to apply the filter, call its validate() and sanitize() methods. Supply the variable to be filtered, along with a rule name and any arguments for the rule. (These methods return true to indicate success, or false to indicate failure.)\/\/ the username must be alphanumeric, \/\/ but not *only* numeric, \/\/ between 6 and 10 characters long, \/\/ and cast it to a string $ok = $filter-&gt;validate($username, 'alnum') &amp;&amp; ! $filter-&gt;validate($username, 'int') &amp;&amp; $filter-&gt;validate($username, 'strlenBetween', 6, 10) &amp;&amp; $filter-&gt;sanitize($username, 'string'); if (! $ok) { echo \"The username is not valid.\"; } \/\/ the password must be at least 6 characters long, and must match a \/\/ confirmation field $ok = $filter-&gt;validate($password, 'strlenMin', 6) &amp;&amp; $filter-&gt;validate($password, 'equalToValue', $password_confirm); if (! $ok) { echo \"The password is not valid.\"; } Note that while validate() will not change the value being filtered, sanitize() will modify the value (thus sanitizing it)."},{"id":"\/packages\/2.x\/Filter\/value-filter.html#4-7-2-2","title":"4.7.2.2. Using A Static Value Filter","content":"In general, the Aura project avoids using statics, and recommends against them in all but the most limited cases. However, some developers are fine with the tradeoffs of using globally-available static methods. For these developers, this package provides an abstract implementation that acts as a static proxy to a ValueFilter instance.To use a static value filter, first extend the AbstractStaticFilter with your own class name; this helps to deconflict between different static filters:use Aura\\Filter\\AbstractStaticFilter; class MyStaticFilter extends AbstractStaticFilter { } Then pass a new ValueFilter into your static proxy class:MyStaticFilter::setInstance($filter_factory-&gt;newValueFilter());  N.b.: You can set the instance only once; further calls will throw an exception. Now you can use the static proxy as a global:use MyStaticFilter as Filter; class CreateUserCommand { protected $username; protected $password; public function __construct($username, $password, $password_confirm) { $ok = Filter::validate($username, 'alnum') &amp;&amp; ! Filter::validate($username, 'int') &amp;&amp; Filter::validate($username, 'strlenBetween', 6, 10) &amp;&amp; Filter::sanitize($username, 'string'); if (! $ok) { throw new Exception(\"The username is not valid.\"); } $ok = Filter::validate($password, 'strlenMin', 6) &amp;&amp; Filter::validate($password, 'equalToValue', $password_confirm); if (! $ok) { throw new Exception(\"The password is not valid.\"); } $this-&gt;username = $username; $this-&gt;password = $password; } } "},{"id":"\/packages\/2.x\/Filter\/subject-filter.html#4-7-3","title":"4.7.3. Filtering Arrays and Objects","content":"You can filter an entire object or array (herein called a \"subject\") by specifying rules for each object property or array element (herein called \"fields\")."},{"id":"\/packages\/2.x\/Filter\/subject-filter.html#4-7-3-1","title":"4.7.3.1. Creating A Subject Filter","content":"First, create a SubjectFilter via the FilterFactory:$filter_factory = new FilterFactory(); $filter = $filter_factory-&gt;newSubjectFilter(); Next, add rule specifications to validate and\/or sanitize each subject field:\/\/ the username must be alphanumeric \/\/ but not *only* numeric, \/\/ at least 6 characters long, \/\/ and cast it to a string $filter-&gt;validate('username')-&gt;is('alnum'); $filter-&gt;validate('username')-&gt;isNot('int'); $filter-&gt;validate('username')-&gt;is('strlenMin', 6); $filter-&gt;sanitize('username')-&gt;to('string'); \/\/ the password must be at least 6 characters long, and must match a \/\/ confirmation field $filter-&gt;validate('password')-&gt;is('strlenMin', 6); $filter-&gt;validate('password_confirm')-&gt;is('equalToField', 'password'); We can call one of the following methods after validate(): is(...) to specify that the value must match the rule isNot(...) to specify that the value must not match the rule isBlank() to specify that the value must be blank (note that using other rules with isBlank() may not make sense) isBlankOr(...) to specify that the value may be blank, or that it must match the rule isBlankOrNot(...) to specify that the value may be blank, or that it must not match the rule isNotBlank() to specifiy that the value must not be blank (note that this makes sense only if you don't care about other validations) We can call one of the following methods after sanitize(): to(...) to specify the value should be changed according to the rule toBlankOr(...) to specify that a blank field should be changed to null, and that non-blank fields should be changed according to the rule useBlankValue(...) to specify what value blank fields should be changed to (default null) For more about blanks, see the section on Blank Fields."},{"id":"\/packages\/2.x\/Filter\/subject-filter.html#4-7-3-2","title":"4.7.3.2. Applying The Subject Filter","content":"We can then apply the filter specifications to the subject. A true result means all the rules passed, while false means one or more failed.\/\/ the data to be filtered; could also be an object $subject = array( 'username' =&gt; 'bolivar', 'password' =&gt; 'p@55w0rd', 'password_confirm' =&gt; 'p@sword', \/\/ not the same! ); \/\/ filter the object and see if there were failures $success = $filter-&gt;apply($subject); if (! $success) { \/\/ get the failures $failures = $filter-&gt;getFailures(); var_dump($failures-&gt;getMessages()); } "},{"id":"\/packages\/2.x\/Filter\/subject-filter.html#4-7-3-3","title":"4.7.3.3. Filter Failures","content":"When we get the failures via getFailures(), we can examine in detail which fields failed, and what the failure messages were. The getFailures() method returns a FailureCollection (essentially an ArrayObject keyed on the field names). Each field in the FailureCollection has an array of Failure objects, each with these methods: Failure::getField() -- the field that failed Failure::getMessage() -- the failure message Failure::getArgs() -- arguments passed to the rule specification These can be combined in various ways to generate output regarding the filter failures."},{"id":"\/packages\/2.x\/Filter\/subject-filter.html#4-7-3-4","title":"4.7.3.4. Failure Modes","content":"Normally, the filter will stop filtering any field that fails one of its rules, but will continue applying rules to the rest of the fields. Also, the filter specification will provide a default message when a rule fails.We can modify that behavior by specifying a failure mode, with an optional custom message: $filter-&gt;...-&gt;asSoftRule('custom message') will cause the filter to keep applying rules to the field, even when a field rule fails. $filter-&gt;...-&gt;asHardRule('custom message') is the default behavior. If the rule fails, the filter will not apply any more rules to that field, but it will keep filtering other fields. $filter-&gt;...-&gt;asStopRule('custom message') will cause the filter to stop applying rules to all fields and return immediately if the rule fails. That is, the filter will not apply any more rules to any more fields. In each case, the custom message will be used instead of the default one for the specified rule. If we want to just set a custom message without changing the failure mode, we can use $filter-&gt;...-&gt;setMessage('custom message')."},{"id":"\/packages\/2.x\/Filter\/subject-filter.html#4-7-3-5","title":"4.7.3.5. Field-Specific Failure Messages","content":"If a field fails multiple rules, there will be multiple failure messages (one for each failed rule). To specify a single failure message for a field, regardless of which rule(s) it fails, call $filter-&gt;useFieldMessage():$filter-&gt;validate('field')-&gt;isNot('blank')-&gt;asSoftRule(); $filter-&gt;validate('field')-&gt;is('alnum')-&gt;asSoftRule(); $filter-&gt;validate('field')-&gt;is('strlenMin', 6)-&gt;asSoftRule(); $filter-&gt;validate('field')-&gt;is('strlenMax', 12)-&gt;asSoftRule(); $filter-&gt;useFieldMessage('field', 'Please use 6-12 alphanumeric characters.'); "},{"id":"\/packages\/2.x\/Filter\/subject-filter.html#4-7-3-6","title":"4.7.3.6. Blank Fields","content":"This library incorporates the concept of \"blank\" fields, as distinct from isset() and empty(), to allow for input elements that are missing or have not been filled in. A field is blank if it is: not set in the subject being filtered, set to null, an empty string (''), or a string composed of only whitespace characters. Integers, floats, booleans, resources, arrays, and objects are never \"blank\" even if they evaluate to zero or are empty:$not_blank = array( 0, \/\/ integer 0.00, \/\/ float false, \/\/ boolean false array(), \/\/ empty array new StdClass, \/\/ an object ); Generally, a blank field will fail to validate. To allow a validate rule to pass even if the field is blank, call isBlankOr() or isBlankOrNot() on its rule specification:\/\/ either an alphanumeric value *or* a blank value will validate $filter-&gt;validate('field')-&gt;isBlankOr('alnum'); Likewise, a blank field may fail to sanitize properly. To allow for a blank field with a sanitize rule, call toBlankOr() on its rule specification:\/\/ both an alphanumeric field *and* a blank field will pass $filter-&gt;sanitize('field')-&gt;toBlankOr('alnum'); This will cause blank values to be sanitized to null, and non-blank values to be sanitized using the alnum rule.Finally, if we want blank values to be sanitized to something other than null, call useBlankValue() to specify the value to use when blank:\/\/ both an alphanumeric field *and* a blank field will pass $filter-&gt;sanitize('field')-&gt;toBlankOr('alnum')-&gt;useBlankValue(''); That will cause blank values to be sanitized to an empty string. Additionally, please note that useBlankValue() implies toBlankOr(), so the following has the same effect as the above:\/\/ both an alphanumeric field *and* a blank field will pass $filter-&gt;sanitize('field')-&gt;to('alnum')-&gt;useBlankValue(''); "},{"id":"\/packages\/2.x\/Filter\/subject-filter.html#4-7-3-7","title":"4.7.3.7. Extending And Initializing A Subject Filter","content":"Sometimes it may be useful to extend the Filter class for a specific purpose, one that can initialize itself. This can be useful when filtering a specific kind of object or dataset.To do so, override the the init() method on the extended Filter class; the above examples remain instructive, but use $this instead of $filter since you are working from inside the filter object:namespace Vendor\\Package; use Aura\\Filter\\SubjectFilter; class EntityFilter extends SubjectFilter { protected function init() { $this-&gt;validate('field')-&gt;isNot('blank')-&gt;asSoftRule(); $this-&gt;validate('field')-&gt;is('alnum')-&gt;asSoftRule(); $this-&gt;validate('field')-&gt;is('strlenMin', 6)-&gt;asSoftRule(); $this-&gt;validate('field')-&gt;is('strlenMax', 12)-&gt;asSoftRule(); $this-&gt;useFieldMessage('field', 'Please use 6-12 alphanumeric characters.'); } } You can then create a new instance of your extended filter class through the FilterFactory:$entity_filter = $filter_factory-&gt;newSubjectFilter('Vendor\\Package\\EntityFilter'); $success = $entity_filter-&gt;apply($entity); "},{"id":"\/packages\/2.x\/Filter\/subject-filter.html#4-7-3-8","title":"4.7.3.8. Asserting or Invoking the Filter","content":"Whereas calling $filter-&gt;apply($subject) returns a boolean, calling $filter-&gt;assert($subject) returns null on success, and throws an exception on failure. (Invoking the filter as a callable a la $filter($subject) works the same as assert().)use Aura\\Filter\\Exception\\FilterFailed; \/\/ the data to be filtered; could also be an object $subject = array( 'username' =&gt; 'bolivar', 'password' =&gt; 'p@55w0rd', 'password_confirm' =&gt; 'p@55word', \/\/ not the same! ); \/\/ filter the object and see if there were failures try { $filter($subject); } catch (FilterFailed $e) \/\/ ... } The FilterFailed exception has these methods in addition to the normal Exception methods: getFilterClass() -- returns the class of the filter being used, in case you were using a custom filter class getSubject() -- returns the subject being filtered getFailures() -- returns the FailureCollection "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-1","title":"4.7.4.1. alnum","content":"Validates the value as alphanumeric only.$filter-&gt;validate('field')-&gt;is('alnum'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-2","title":"4.7.4.2. alpha","content":"Validates the value as alphabetic only.$filter-&gt;validate('field')-&gt;is('alpha'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-3","title":"4.7.4.3. between","content":"Validates the value as being within or equal to a minimum and maximum value.$filter-&gt;validate('field')-&gt;is('between', $min, $max); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-4","title":"4.7.4.4. blank","content":"Validates the value as being blank.$filter-&gt;validate('field1')-&gt;isBlank(); $filter-&gt;validate('field2')-&gt;isBlankOr('strlen', 3); $filter-&gt;validate('field3')-&gt;isBlankOrNot('strlen', 3); To validate the value as not being blank.$filter-&gt;validate('field')-&gt;isNotBlank(); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-5","title":"4.7.4.5. bool","content":"Validates the value as being a boolean, or a pseudo-boolean. Pseudo-true values include the strings '1', 'y', 'yes', and 'true'; pseudo-false values include the strings '0', 'n', 'no', and 'false'.$filter-&gt;validate('field')-&gt;is('bool'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-6","title":"4.7.4.6. callback","content":"Validates the value using a callable\/callback. The callable should take two arguments, $subject and $field, to indicate the subject and the field within that subject. It should return true to pass, or false to fail.$filter-&gt;validate('field')-&gt;is('callback', function ($subject, $field) { if ($subject-&gt;$field === 'foo') { return true; } return false; });  N.b.: Always use object notation ($subject-&gt;$field) and not array notation ($subject[$field]) in the closure, as the Filter converts arrays to objects on the fly. "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-7","title":"4.7.4.7. creditCard","content":"Validates the value as being a credit card number.$filter-&gt;validate('field')-&gt;is('creditCard'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-8","title":"4.7.4.8. dateTime","content":"Validates the value as representing a date and\/or time.$filter-&gt;validate('field')-&gt;is('dateTime'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-9","title":"4.7.4.9. email","content":"Validates the value as being a properly-formed email address per the various relevant RFCs. If the intl extension is loaded, it will also allow for international domain names.$filter-&gt;validate('field')-&gt;is('email'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-10","title":"4.7.4.10. equalToField","content":"Validates the value as loosely equal (==) to the value of another field in the subject.$filter-&gt;validate('field')-&gt;is('equalToField', 'other_field_name'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-11","title":"4.7.4.11. equalToValue","content":"Validates the value as loosely equal (`==') to a specified value.$filter-&gt;validate('field')-&gt;is('equalToValue', $other_value); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-12","title":"4.7.4.12. float","content":"Validates the value as representing a float.$filter-&gt;validate('field')-&gt;is('float'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-13","title":"4.7.4.13. inKeys","content":"Validates that the value is loosely equal (==) to a key in a given array.$filter-&gt;validate('field')-&gt;is('inKeys', $array); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-14","title":"4.7.4.14. int","content":"Validates the value as representing an integer.$filter-&gt;validate('field')-&gt;is('int'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-15","title":"4.7.4.15. inValues","content":"Validates that the value is strictly equal (===) to a value in a given array.$filter-&gt;validate('field')-&gt;is('inValues', $array); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-16","title":"4.7.4.16. ip","content":"Validates the value as an IPv4 or IPv6 address, allowing reserved and private addresses.$filter-&gt;validate('field')-&gt;is('ip'); To modify restrictions on the filter, pass the appropriate FILTER_FLAG_* constants (seen here) as a second parameter.\/\/ only allow IPv4 addresses in the non-private range. $filter-&gt;validate('field')-&gt;is('ip', FILTER_FLAG_IPV4 | FILTER_FLAG_NO_PRIV_RANGE); \/\/ only allow IPv6 addresses in non-reserved range. $filter-&gt;validate('field')-&gt;is('ip', FILTER_FLAG_IPV6 | FILTER_FLAG_NO_RES_RANGE); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-17","title":"4.7.4.17. isbn","content":"Validates the value is a correct ISBN (International Standard Book Number).$filter-&gt;validate('field')-&gt;is('isbn'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-18","title":"4.7.4.18. locale","content":"Validates the given value against a list of locale strings (internal to the rule class).$filter-&gt;validate('field')-&gt;is('locale'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-19","title":"4.7.4.19. lowercase","content":"Validates the value as all lowercase.$filter-&gt;validate('field')-&gt;is('lowercase'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-20","title":"4.7.4.20. lowercaseFirst","content":"Validates the value begins with a lowercase character.$filter-&gt;validate('field')-&gt;is('lowercaseFirst'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-21","title":"4.7.4.21. max","content":"Validates the value as being less than or equal to a maximum.$filter-&gt;validate('field')-&gt;is('max', $max); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-22","title":"4.7.4.22. min","content":"Validates the value as being greater than or equal to a minimum.$filter-&gt;validate('field')-&gt;is('min', $min); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-23","title":"4.7.4.23. regex","content":"Validates the value using preg_match().$filter-&gt;validate('field')-&gt;is('regex', $expr); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-24","title":"4.7.4.24. strictEqualToField","content":"Validates the value as strictly equal (===) to the value of another field in the subject.$filter-&gt;validate('field')-&gt;is('strictEqualToField', 'other_field_name'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-25","title":"4.7.4.25. strictEqualToValue","content":"Validates the value as strictly equal (===) to a specified value.$filter-&gt;validate('field')-&gt;is('strictEqualToValue', $other_value); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-26","title":"4.7.4.26. string","content":"Validates the value can be represented by a string.$filter-&gt;validate('field')-&gt;is('string'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-27","title":"4.7.4.27. strlen","content":"Validates the value has a specified length.$filter-&gt;validate('field')-&gt;is('strlen', $len); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-28","title":"4.7.4.28. strlenBetween","content":"Validates the value as being within or equal to a minimum and maximum length.$filter-&gt;validate('field')-&gt;is('strlenBetween', $min, $max); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-29","title":"4.7.4.29. strlenMax","content":"Validates the value length as being no longer than a maximum.$filter-&gt;validate('field')-&gt;is('strlenMax', $max); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-30","title":"4.7.4.30. strlenMin","content":"Validates the value length as being no shorter than a minimum.$filter-&gt;validate('field')-&gt;is('strlenMin', $min); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-31","title":"4.7.4.31. titlecase","content":"Validates the value as title case$filter-&gt;validate('field')-&gt;is('titlecase'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-32","title":"4.7.4.32. trim","content":"Validates the value is trim()med. Optionally specify characters to trim.$filter-&gt;validate('field')-&gt;is('trim', $chars); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-33","title":"4.7.4.33. upload","content":"Validates the value represents a PHP upload information array, and that the file is an uploaded file.$filter-&gt;validate('field')-&gt;is('upload'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-34","title":"4.7.4.34. uppercase","content":"Validates the value as all uppercase.$filter-&gt;validate('field')-&gt;is('uppercase'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-35","title":"4.7.4.35. uppercaseFirst","content":"Validates the value begins with an uppercase character.$filter-&gt;validate('field')-&gt;is('uppercaseFirst'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-36","title":"4.7.4.36. url","content":"Validates the value is a well-formed URL.$filter-&gt;validate('field')-&gt;is('url'); "},{"id":"\/packages\/2.x\/Filter\/validate.html#4-7-4-37","title":"4.7.4.37. word","content":"Validates the value as being composed only of word characters.$filter-&gt;validate('field')-&gt;is('word'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-1","title":"4.7.5.1. alnum","content":"Sanitizes to leave only alphanumeric characters.$filter-&gt;sanitize('field')-&gt;to('alnum'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-2","title":"4.7.5.2. alpha","content":"Sanitizes to leave only alphabetic characters.$filter-&gt;sanitize('field')-&gt;to('alpha'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-3","title":"4.7.5.3. between","content":"Sanitizes so that values lower than the range are forced up to the minimum, and values higher than the range are forced down to the maximum.$filter-&gt;sanitize('field')-&gt;to('between', $min, $max); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-4","title":"4.7.5.4. bool","content":"Sanitizes to a strict PHP boolean value. Pseudo-true values include the strings '1', 'y', 'yes', and 'true'; pseudo-false values include the strings '0', 'n', 'no', and 'false'.\/\/ sanitize to `true` and `false` $filter-&gt;sanitize('field')-&gt;to('bool'); You can sanitize to alternative true and false values in place of PHP true and false.\/\/ sanitize to alternative true and false values $filter-&gt;sanitize('field')-&gt;to('bool', $value_if_true, $value_if_false); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-5","title":"4.7.5.5. callback","content":"Sanitizes the value using a callable\/callback. The callback should take two arguments, $subject and $field, to indicate the subject and the field within that subject. It should return true to pass, or false to fail.$filter-&gt;sanitize('field')-&gt;to('callback', function ($subject, $field) { \/\/ always force the field to 'foo' $subject-&gt;$field = 'foo'; return true; });  N.b.: Always use object notation ($subject-&gt;$field) and not array notation ($subject[$field]) in the callable, as the Filter converts arrays to objects on the fly. "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-6","title":"4.7.5.6. dateTime","content":"Sanitizes the value to a specified date\/time format, default 'Y-m-d H:i:s'.$filter-&gt;sanitize('field')-&gt;to('dateTime', $format); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-7","title":"4.7.5.7. field","content":"Sanitizes to the value of another field in the subject.$filter-&gt;sanitize('field')-&gt;to('field', 'other_field_name'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-8","title":"4.7.5.8. float","content":"Sanitizes the value to transform it into a float; for weird strings, this may not be what you expect.$filter-&gt;sanitize('field')-&gt;to('float'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-9","title":"4.7.5.9. int","content":"Sanitizes the value to transform it into an integer; for weird strings, this may not be what you expect.$filter-&gt;sanitize('field')-&gt;to('int'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-10","title":"4.7.5.10. isbn","content":"Sanitizes the value to an ISBN (International Standard Book Number).$filter-&gt;sanitize('field')-&gt;to('isbn'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-11","title":"4.7.5.11. lowercase","content":"Sanitizes the value to all lowercase characters.$filter-&gt;sanitize('field')-&gt;to('lowercase'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-12","title":"4.7.5.12. lowercaseFirst","content":"Sanitizes the value to begin with a lowercase character.$filter-&gt;sanitize('field')-&gt;to('lowercaseFirst'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-13","title":"4.7.5.13. max","content":"Sanitizes so that values higher than the maximum are forced down to the maximum.$filter-&gt;sanitize('field')-&gt;to('max', $max); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-14","title":"4.7.5.14. min","content":"Sanitizes so that values lower than the minimum are forced up to the minimum.$filter-&gt;sanitize('field')-&gt;to('min', $min); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-15","title":"4.7.5.15. now","content":"Sanitizes the value to force it to the current datetime, default format 'Y-m-d H:i:s'.$filter-&gt;sanitize('field')-&gt;to('now', $format); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-16","title":"4.7.5.16. remove","content":"Removes the field from the subject with unset().$filter-&gt;sanitize('field')-&gt;to('remove'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-17","title":"4.7.5.17. regex","content":"Sanitizes the value using preg_replace().$filter-&gt;sanitize('field')-&gt;to('regex', $expr, $replace); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-18","title":"4.7.5.18. string","content":"Sanitizes the value by casting to a string and optionally using str_replace() to find and replace within the string.$filter-&gt;sanitize('field')-&gt;to('string', $find, $replace); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-19","title":"4.7.5.19. strlen","content":"Sanitizes the value to cut off longer values at the right, and str_pad() shorter ones.$filter-&gt;sanitize('field')-&gt;to('strlen', $len[, $pad_string[, $pad_type]]); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-20","title":"4.7.5.20. strlenBetween","content":"Sanitizes the value to truncate values longer than the maximum, and str_pad() shorter ones.$filter-&gt;sanitize('field')-&gt;to('strlenBetween', $min, $max[, $pad_string[, $pad_type]]); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-21","title":"4.7.5.21. strlenMax","content":"Sanitizes the value to truncate values longer than the maximum.$filter-&gt;sanitize('field')-&gt;to('strlenMax', $max); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-22","title":"4.7.5.22. strlenMin","content":"Sanitizes the value to str_pad() values shorter than the minimum.$filter-&gt;sanitize('field')-&gt;to('strlenMin', $min[, $pad_string[, $pad_type]]); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-23","title":"4.7.5.23. titlecase","content":"Sanitizes the value to titlecase (eg. \"Title Case\").$filter-&gt;sanitize('field')-&gt;to('titlecase'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-24","title":"4.7.5.24. trim","content":"Sanitizes the value to trim() it. Optionally specify characters to trim.$filter-&gt;sanitize('field')-&gt;to('trim', $chars); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-25","title":"4.7.5.25. uppercase","content":"Sanitizes the value to all uppercase characters.$filter-&gt;sanitize('field')-&gt;to('uppercase'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-26","title":"4.7.5.26. uppercaseFirst","content":"Sanitizes the value to begin with an uppercase character.$filter-&gt;sanitize('field')-&gt;to('uppercaseFirst'); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-27","title":"4.7.5.27. value","content":"Sanitizes to the specified value.$filter-&gt;sanitize('field')-&gt;to('value', $other_value); "},{"id":"\/packages\/2.x\/Filter\/sanitize.html#4-7-5-28","title":"4.7.5.28. word","content":"Sanitizes the value to remove non-word characters.$filter-&gt;sanitize('field')-&gt;to('word'); "},{"id":"\/packages\/2.x\/Filter\/custom.html#4-7-6","title":"4.7.6. Creating and Using Custom Rules","content":"There are three steps to creating and using new rules: Write a rule class, either to validate or sanitize a subject field Set a factory for the class in the appropriate rule locator Use the new rule in a filter specification "},{"id":"\/packages\/2.x\/Filter\/custom.html#4-7-6-1","title":"4.7.6.1. Writing a Rule Class","content":"Writing a rule class is straightforward. Define a class with an __invoke($subject, $field) method, along with any additional needed arguments. The method should return a boolean: true on success, or false on failure."},{"id":"\/packages\/2.x\/Filter\/custom.html#4-7-6-1-1","title":"4.7.6.1.1. A Validate Class","content":"Here is an example of a hexdecimal validator:namespace Vendor\\Package\\Filter\\Rule\\Validate; class ValidateHex { public function __invoke($subject, $field, $max = null) { \/\/ must be scalar $value = $subject-&gt;$field; if (! is_scalar($value)) { return false; } \/\/ must be hex $hex = ctype_xdigit($value); if (! $hex) { return false; } \/\/ must be no longer than $max chars if ($max &amp;&amp; strlen($value) &gt; $max) { return false; } \/\/ done! return true; } } "},{"id":"\/packages\/2.x\/Filter\/custom.html#4-7-6-1-2","title":"4.7.6.1.2. A Sanitize Class","content":"Here is an example of a hexadecimal sanitizer. Note how we modify the $subject-&gt;$field value directly at the end of the method.namespace Vendor\\Package\\Filter\\Rule\\Sanitize; class SanitizeHex { public function __invoke($subject, $field, $max = null) { $value = $subject-&gt;$field; \/\/ must be scalar if (! is_scalar($value)) { \/\/ sanitizing failed return false; } \/\/ strip out non-hex characters $value = preg_replace('\/[^0-9a-f]\/i', '', $value); if ($value === '') { \/\/ failed to sanitize to a hex value return false; } \/\/ now check length and chop if needed if ($max &amp;&amp; strlen($value) &gt; $max) { $value = substr($value, 0, $max); } \/\/ retain the sanitized value, and done! $subject-&gt;$field = $value; return true; } } "},{"id":"\/packages\/2.x\/Filter\/custom.html#4-7-6-2","title":"4.7.6.2. Set Locator Factories","content":"Now we set a factory for the rule into the appropriate locator from the FilterFactory. Pass additional $validate_factories and $sanitize_factories to the FilterFactory at construction time; Wrap the rule instantiation logic in a closure so that it is lazy-loaded only when the rule is called:use Aura\\Filter\\FilterFactory; $validate_factories = array( 'hex' =&gt; function () { return new Vendor\\Package\\Filter\\Rule\\Validate\\ValidateHex(); }, ); $sanitize_factories = array( 'hex' =&gt; function () { return new Vendor\\Package\\Filter\\Rule\\Sanitize\\SanitizeHex(); }, ); $filter_factory = new FilterFactory( $validate_factories, $sanitize_factories ); "},{"id":"\/packages\/2.x\/Filter\/custom.html#4-7-6-3","title":"4.7.6.3. Apply The New Rule","content":"Finally, we can use the rule in our filters:$filter = $filter_factory-&gt;newSubjectFilter(); \/\/ the 'color' field must be a hex value of no more than 6 digits $filter-&gt;validate('color')-&gt;is('hex', 6); \/\/ force the 'color' field to a hex value of no more than 6 digits $filter-&gt;sanitize('color')-&gt;to('hex', 6); "},{"id":"\/packages\/2.x\/Html.html#4-8","title":"4.8. Aura.Html","content":"Provides HTML escapers and helpers, including form input helpers, that can be used in any template, view, or presentation system."},{"id":"\/packages\/2.x\/Html.html#4-8-1-1","title":"4.8.1.1. Installation","content":"This library requires PHP 5.3 or later with mbstring and\/or iconv installed; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/html.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/Html.html#4-8-1-2","title":"4.8.1.2. Quality","content":" To run the unit tests at the command line, issue composer install and then phpunit at the package root. This requires Composer to be available as composer, and PHPUnit to be available as phpunit.This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/Html.html#4-8-1-3","title":"4.8.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/Html.html#4-8-2","title":"4.8.2. Getting Started","content":"The easiest way to instantiate a HelperLocator with all the available helpers is to use the HelperLocatorFactory:&lt;?php $factory = new \\Aura\\Html\\HelperLocatorFactory; $helper = $factory-&gt;newInstance(); ?&gt; "},{"id":"\/packages\/2.x\/Html.html#4-8-2-1","title":"4.8.2.1. Built-In Helpers","content":"Once you have a HelperLocator, you can then use the helpers by calling them as methods on the HelperLocator instance. See the tag helpers and form helpers pages for more information. N.b.: All built-in helpers escape values appropriately; see the various helper class internals for more information. "},{"id":"\/packages\/2.x\/Html.html#4-8-2-2","title":"4.8.2.2. Custom Helpers","content":"There are two steps to adding your own custom helpers: Write a helper class Set a factory for that class into the HelperLocator under a service name A helper class needs only to implement the __invoke() method. We suggest extending from AbstractHelper to get access to indenting, escaping, etc., but it's not required.The following example helper class applies ROT-13 to a string.&lt;?php namespace Vendor\\Package; use Aura\\Html\\Helper\\AbstractHelper; class Obfuscate extends AbstractHelper { public function __invoke($string) { return $this-&gt;escaper-&gt;html(str_rot13($input)); } } ?&gt; Now that we have a helper class, we set a factory for it into the HelperLocator under a service name. Therein, we create and return the helper class.&lt;?php $helper-&gt;set('obfuscate', function () { return new \\Vendor\\Package\\Obfuscate; }); ?&gt; The service name in the HelperLocator doubles as a method name. This means we can call the helper via $this-&gt;obfuscate():&lt;?= $helper-&gt;obfuscate('plain text') ?&gt; Note that we can use any service name for the helper, although it is generally useful to name the service for the helper class, and for a word that can be called as a method.Please examine the classes in Aura\\Html\\Helper for more complex and powerful examples."},{"id":"\/packages\/2.x\/Html.html#4-8-2-3","title":"4.8.2.3. Escaping","content":"One of the important but menial tasks with PHP-based template systems is that of escaping output properly. Escaping output is absolutely necessary from a security perspective. This package comes with an escape() helper that has four escaping methods: $this-&gt;escape()-&gt;html('foo') to escape HTML values $this-&gt;escape()-&gt;attr('foo') to escape unquoted HTML attributes $this-&gt;escape()-&gt;css('foo') to escape CSS values $this-&gt;escape()-&gt;js('foo') to escape JavaScript values Here is a contrived example of the various escape() helper methods:&lt;head&gt; &lt;style&gt; body { color: &lt;?= $this-&gt;escape()-&gt;css($theme-&gt;color) ?&gt;; font-size: &lt;?= $this-&gt;escape()-&gt;css($theme-&gt;font_size) ?&gt;; } &lt;\/style&gt; &lt;script language=\"javascript\"&gt; var foo = \"&lt;?= $this-&gt;escape()-&gt;js($js-&gt;foo); ?&gt;\"; &lt;\/script&gt; &lt;\/head&gt; &lt;body&gt; &lt;h1&gt;&lt;?= $this-&gt;escape()-&gt;html($blog-&gt;title) ?&gt;&lt;\/h1&gt; &lt;p class=\"byline\"&gt; by &lt;?= $this-&gt;escape()-&gt;html($blog-&gt;author) ?&gt; on &lt;?= $this-&gt;escape()-&gt;html($blog-&gt;date) ?&gt; &lt;\/p&gt; &lt;div id=\"&lt;?php $this-&gt;escape()-&gt;attr($blog-&gt;div_id) ?&gt;\"&gt; &lt;?= $blog-&gt;raw_html ?&gt; &lt;\/div&gt; &lt;\/body&gt; Unfortunately, escaper functionality is verbose, and can make the template code look cluttered. There are two ways to mitigate this.The first is to assign the escape() helper to a variable, and then invoke it as a callable. Here is a contrived example of the various escaping methods as callables:&lt;?php \/\/ assign the escaper helper properties to callable variables $h = $this-&gt;escape()-&gt;html; $a = $this-&gt;escape()-&gt;attr; $c = $this-&gt;escape()-&gt;css; $j = $this-&gt;escape()-&gt;js; ?&gt; &lt;head&gt; &lt;style&gt; body { color: &lt;?= $c($theme-&gt;color) ?&gt;; font-size: &lt;?= $c($theme-&gt;font_size) ?&gt;; } &lt;\/style&gt; &lt;script language=\"javascript\"&gt; var foo = \"&lt;?= $j($js-&gt;foo); ?&gt;\"; &lt;\/script&gt; &lt;\/head&gt; &lt;body&gt; &lt;h1&gt;&lt;?= $h($blog-&gt;title) ?&gt;&lt;\/h1&gt; &lt;p class=\"byline\"&gt; by &lt;?= $h($blog-&gt;author) ?&gt; on &lt;?= $h($blog-&gt;date) ?&gt; &lt;\/p&gt; &lt;div id=\"&lt;?php $a($blog-&gt;div_id) ?&gt;\"&gt; &lt;?= $blog-&gt;raw_html ?&gt; &lt;\/div&gt; &lt;\/body&gt; Alternatively, the Escaper class used by the escape() helper comes with four static methods to reduce verbosity and clutter: h(), a(), c(), j(), and. These escape values for HTML content values, unquoted HTML attribute values, CSS values, and JavaScript values, respectively. N.b.: In Aura, we generally avoid static methods. However, we feel the tradeoff of less-cluttered templates can be worth using static methods in this one case. To call the static Escaper methods in a PHP-based template, use the Escaper as a short alias name, then call the static methods on the alias. (If you did not instantiate a HelperLocatorFactory, you will need to prepare the static escaper methods by calling Escaper::setStatic(new Escaper).)Here is a contrived example of the various static methods:&lt;?php use Aura\\Html\\Escaper as e; ?&gt; &lt;head&gt; &lt;style&gt; body { color: &lt;?= e::c($theme-&gt;color) ?&gt;; font-size: &lt;?= e::c($theme-&gt;font_size) ?&gt;; } &lt;\/style&gt; &lt;script language=\"javascript\"&gt; var foo = \"&lt;?= e::j($js-&gt;foo); ?&gt;\"; &lt;\/script&gt; &lt;\/head&gt; &lt;body&gt; &lt;h1&gt;&lt;?= e::h($blog-&gt;title) ?&gt;&lt;\/h1&gt; &lt;p class=\"byline\"&gt; by &lt;?= e::h($blog-&gt;author) ?&gt; on &lt;?= e::h($blog-&gt;date) ?&gt; &lt;\/p&gt; &lt;div id=\"&lt;?php e::a($blog-&gt;div_id) ?&gt;\"&gt; &lt;?= $blog-&gt;raw_html ?&gt; &lt;\/div&gt; &lt;\/body&gt; "},{"id":"\/packages\/2.x\/Includer.html#4-9","title":"4.9. Aura.Includer","content":"Provides a facility to include multiple files from specified directories, in order, with variables extracted into a limited include scope."},{"id":"\/packages\/2.x\/Includer.html#4-9-1-1","title":"4.9.1.1. Installation","content":"This library requires PHP 5.3 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/includer.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/Includer.html#4-9-1-2","title":"4.9.1.2. Quality","content":" To run the unit tests at the command line, issue phpunit at the package root. (This requires PHPUnit to be available as phpunit.)This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/Includer.html#4-9-1-3","title":"4.9.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/Includer.html#4-9-2-1","title":"4.9.2.1. The Example Scenario","content":"Let's say you have a series of packages, modules, plugins, etc. To do its setup work, your framework or foundation needs to include certain files from each of thse modules, such as configuration or routing files.For our examples, the module directory structure will look like this:modules\/ foo\/ autoload.php config\/ default.php testing.php routes.php bar\/ autoload.php baz\/ autoload.php config\/ default.php An example autoload.php file might look like this:&lt;?php $loader-&gt;addNamespace('Module\\Foo', __DIR__); ?&gt; An example config file might look like this:&lt;?php $config-&gt;setValue('db_host', 'localhost'); ?&gt; An example routes.php file might look like this:&lt;?php $router-&gt;setPath('\/blog\/read\/{id}', function ($id) { \/\/ logic for the blog \"read\" action }); ?&gt; Because of the shared variables being used in each file, we need them to be available, but we also want each file to be kept separate from the global scope.When including the configuration files, we need both the default and an additional \"mode\" for overrides to the defaults.If a file is missing, we can skip it without ill effect."},{"id":"\/packages\/2.x\/Includer.html#4-9-2-2","title":"4.9.2.2. Accomplishing The Task","content":"The Includer makes this scenario, and others like it, relatively easy. First, we instantiate the Includer:&lt;?php use Aura\\Includer\\Includer; $includer = new Includer; ?&gt; Next, we set the various directories we need to look through for files to include:&lt;?php $includer-&gt;setDirs(array( '\/path\/to\/modules\/foo', '\/path\/to\/modules\/bar', '\/path\/to\/modules\/baz', )); ?&gt; Then we set the files to look for in each of the directories (we will include both the default config and an override testing config):&lt;?php $includer-&gt;setFiles(array( 'autoload.php', 'config\/default.php', 'config\/testing.php', 'routes.php', )); ?&gt; Because the files happen to need local variables, we create them first, then make them available to the include files:&lt;?php $loader = new Loader(...); $config = new Config(...); $router = new Router(...); $includer-&gt;setVars(array( 'loader' =&gt; $loader, 'config' =&gt; $config, 'router' =&gt; $router, )); ?&gt; Finally, after setting up the directory, files, and variables, we call the load() method:&lt;?php $includer-&gt;load(); ?&gt; This will create a separate scope for each include file, extract the variables into that limited scope, and then include the file within that limited scope. This means that no include file can affect the global state of the application, except through the injected variables."},{"id":"\/packages\/2.x\/Includer.html#4-9-2-3","title":"4.9.2.3. Include Order","content":"By default, the Includer will include files in \"directory order\", represented by the constant Includer::DIR_ORDER. This means that the Includer visits the first directory and attemps to load all the files noted in that directory, then proceeds to the next directory. Given our above example, the loading for Includer::DIR_ORDER would be:# first dir modules\/foo\/autoload.php modules\/foo\/config\/default.php modules\/foo\/config\/testing.php modules\/foo\/routes.php # second dir modules\/bar\/autoload.php # third dir modules\/baz\/autoload.php modules\/baz\/config\/default.php Alternatively, you can specify load(Includer::FILE_ORDER) to load files in \"file order\". This means that the loader attemps to load the first file from each directory, then the second file from each directory, and so on. Given our above example, the loading for Includer::FILE_ORDER would be:# first file modules\/foo\/autoload.php modules\/bar\/autoload.php modules\/baz\/autoload.php # second file modules\/foo\/config\/default.php modules\/baz\/config\/default.php # third file modules\/foo\/config\/testing.php # fourth file modules\/foo\/routes.php "},{"id":"\/packages\/2.x\/Includer.html#4-9-2-4","title":"4.9.2.4. Strict Processing","content":"By default, the Includer is relatively strict about what path combinations it will actually include. It will convert the directory + file path using realpath() to get the absolute path, and then check to see if that absolute path is in the same directory as specified in the Includer. (This is because it's possible to use ..\/ and symbolic links to point to file locations outside the specified directory.) Files that are not readable, or that are outside the specified directory, will not be included.This type of processing is sometimes too strict; if you use symbolic links, for example, the strict processing may exclude those files. To turn off strict process, and only check if the file is readable, call setStrict(false).&lt;?php \/\/ turn off strict processing $includer-&gt;setStrict(false); ?&gt; "},{"id":"\/packages\/2.x\/Includer.html#4-9-2-5","title":"4.9.2.5. Globbing","content":"Under the hood, the Includer uses glob() to find files. This means you can use wildcards in the filenames to include files.&lt;?php \/\/ load all '.php' files in each of the directories $includer-&gt;addFiles(array( 'config\/*.php', 'routes\/*.php' ); ?&gt; "},{"id":"\/packages\/2.x\/Includer.html#4-9-2-6","title":"4.9.2.6. Cache File","content":"If you have dozens or scores of files that need to be included, that amount of file system activity can be a performance drain. To mitigate this, it can be useful to cache the files that would have been included.The Includer has a read() method to get the contents of the files to be included and concatenate them, returning the concatenated contents for you to cache in a file of your choosing. You can then point the Includer to that cached file; if it exists, the Includer will use that file instead of including the various different directory and file path combinations.First, we get the text of the concatenated files using the read() method. By default, it will concatenate the files in Includer::DIR_ORDER, but you can specify read(Includer::FILE_ORDER) if you prefer.&lt;?php $text = $includer-&gt;read(); ?&gt; The read() method will get the contents of each file, trim it, strip any leading and trailing &lt;?php ?&gt; tags, replace the __FILE__ constant with the equivalent string file name, and replace the __DIR__ constant with the equivalent string directory name. (These replacements reflect the fact that the code is being copied from its original location to a new location, and the constants expect the value of thr original location.)Now that we have the contents of the files, we add an opening &lt;?php tag and the time we created it, and then save it as a cache file:&lt;?php $text = '&lt;?php \/** ' . date('Y-m-d H:i:s') . ' *\/' . PHP_EOL . PHP_EOL . $text; file_put_contents('\/path\/to\/cache_file.php', $text); ?&gt; Finally, we tell the Includer where the cache file is. If it is readable, the Includer will use it on load(); otherwise, it will include the various directory and file combinations.&lt;?php $includer-&gt;setCacheFile('\/path\/to\/cache_file.php'); $includer-&gt;load(); \/\/ uses the cache file if it exists ?&gt; "},{"id":"\/packages\/2.x\/Includer.html#4-9-2-7","title":"4.9.2.7. Debugging","content":"Sometimes it will be useful to see what files the Includer actually found. Use the getDebug() method to return an array of information about what the Includer found, in what order, and in what mode."},{"id":"\/packages\/2.x\/Router.html#4-10","title":"4.10. Aura.Router","content":"Provides a web router implementation: given a URL path and a copy of $_SERVER, it will extract path-info and $_SERVER values for a specific route.This package does not provide a dispatching mechanism. Your application is expected to take the information provided by the matching route and dispatch it on its own. For one possible dispatch system, please see Aura.Dispatcher."},{"id":"\/packages\/2.x\/Router.html#4-10-1-1","title":"4.10.1.1. Installation","content":"This library requires PHP 5.3 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/router.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/Router.html#4-10-1-2","title":"4.10.1.2. Quality","content":" To run the PHPUnit unit tests at the command line, issue composer install and then vendor\/bin\/phpunit at the package root. This requires Composer to be available as composer.This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/Router.html#4-10-1-3","title":"4.10.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/Router.html#4-10-2-1","title":"4.10.2.1. Instantiation","content":"Instantiate a Router like so:&lt;?php use Aura\\Router\\RouterFactory; $router_factory = new RouterFactory; $router = $router_factory-&gt;newInstance(); ?&gt; You will need to place the Router where you can get to it from your application; e.g., in a registry, a service locator, or a dependency injection container. One such system is the Aura.Di package."},{"id":"\/packages\/2.x\/Router.html#4-10-2-2","title":"4.10.2.2. Adding A Route","content":"To create a route, call the add() method on the Router. Named path-info params are placed inside braces in the path.&lt;?php \/\/ add a simple named route without params $router-&gt;add('home', '\/'); \/\/ add a simple unnamed route with params $router-&gt;add(null, '\/{controller}\/{action}\/{id}'); \/\/ add a named route with an extended specification $router-&gt;add('blog.read', '\/blog\/read\/{id}{format}') -&gt;addTokens(array( 'id' =&gt; '\\d+', 'format' =&gt; '(\\.[^\/]+)?', )) -&gt;addValues(array( 'action' =&gt; 'BlogReadAction', 'format' =&gt; '.html', )); ?&gt; You can create a route that matches only against a particular HTTP method as well. The following Router methods are identical to add() but require the related HTTP method: $router-&gt;addHead() $router-&gt;addGet() $router-&gt;addDelete() $router-&gt;addOptions() $router-&gt;addPatch() $router-&gt;addPost() $router-&gt;addPut() "},{"id":"\/packages\/2.x\/Router.html#4-10-2-3","title":"4.10.2.3. Matching A Route","content":"To match a URL path against your routes, call match() with a path string and the $_SERVER values.&lt;?php \/\/ get the incoming request URL path $path = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH); \/\/ get the route based on the path and server $route = $router-&gt;match($path, $_SERVER); ?&gt; The match() method does not parse the URL or use $_SERVER internally. This is because different systems may have different ways of representing that information; e.g., through a URL object or a context object. As long as you can pass the string path and a server array, you can use the Router in your application foundation or framework.The returned $route object will contain, among other things, a $params array with values for each of the parameters identified by the route path. For example, matching a route with the path \/{controller}\/{action}\/{id} will populate the $route-&gt;params array with controller, action, and id keys."},{"id":"\/packages\/2.x\/Router.html#4-10-2-4","title":"4.10.2.4. Handling Failure To Match","content":"When $router-&gt;match() returns empty, it means there was no matching route for the URL path and server variables. However, we can still discover something about the matching process; in particular, whether the failure is related to an HTTP method or an Accept header.&lt;?php \/\/ get the first of the best-available non-matched routes $failure = $router-&gt;getFailedRoute(); \/\/ inspect the failed route if ($failure-&gt;failedMethod()) { \/\/ the route failed on the allowed HTTP methods. \/\/ this is a \"405 Method Not Allowed\" error. } elseif ($failure-&gt;failedAccept()) { \/\/ the route failed on the available content-types. \/\/ this is a \"406 Not Acceptable\" error. } else { \/\/ there was some other unknown matching problem. } ?&gt; "},{"id":"\/packages\/2.x\/Router.html#4-10-2-5","title":"4.10.2.5. Dispatching A Route","content":"Now that you have route, you can dispatch it. The following is what a foundation or framework system might do with a route to invoke a page controller.&lt;?php if (! $route) { \/\/ no route object was returned echo \"No application route was found for that URL path.\"; exit(); } \/\/ does the route indicate an action? if (isset($route-&gt;params['action'])) { \/\/ take the action class directly from the route $action_class = $route-&gt;params['action']; } else { \/\/ use a default action class $action_class = 'IndexAction'; } \/\/ instantiate the action class $action = new $action_class(); \/\/ call the __invoke() method on the action \/\/ class using the route params echo $action-&gt;__invoke($route-&gt;params); ?&gt; Again, note that the Router will not dispatch for you; the above is provided as a naive example only to show how to use route values. For a more complex dispatching system, try Aura.Dispatcher."},{"id":"\/packages\/2.x\/Router.html#4-10-2-6","title":"4.10.2.6. Generating A Route Path","content":"To generate a URL path from a route so that you can create links, call generate() on the Router and provide the route name with optional data.&lt;?php \/\/ $path =&gt; \"\/blog\/read\/42.atom\" $path = $router-&gt;generate('read', array( 'id' =&gt; 42, 'format' =&gt; '.atom', )); $href = htmlspecialchars($path, ENT_QUOTES, 'UTF-8'); echo '&lt;a href=\"' . $href .'\"&gt;Atom feed for this blog entry&lt;\/a&gt;'; ?&gt; The Router does not do dynamic matching of routes; a route must have a name to be able to generate a path from it.The example shows that passing an array of data as the second parameter will cause that data to be interpolated into the route path. This data array is optional. If there are path params without matching data keys, those params will not be replaced, leaving the {param} token in the path. If there are data keys without matching params, those values will not be added to the path."},{"id":"\/packages\/2.x\/Router.html#4-10-3-1","title":"4.10.3.1. Extended Route Specification","content":"You can extend a route specification with the following methods: addTokens() -- Adds regular expression subpatterns that params must match. addTokens(array( 'id' =&gt; '\\d+', )) Note that setTokens() is also available, but this will replace any previous subpatterns entirely, instead of merging with the existing subpatterns. addServer() -- Adds regular expressions that server values must match. addServer(array( 'REQUEST_METHOD' =&gt; 'PUT|PATCH', )) Note that setServer() is also available, but this will replace any previous expressions entirely, instead of merging with the existing expressions. addAccept() -- Adds a list of content types that the route responds to. Note that this is not content negotiation per se, only a \"sanity check\" to make sure the route can eventually provide the content types specified by the request. addAccept(array( 'application\/json', 'application\/xml', 'text\/csv', )); Note that setAccept() is also available, but this will replace any previous content types entirely, instead of merging with the existing types. addValues() -- Adds default values for the params. addValues(array( 'year' =&gt; '1979', 'month' =&gt; '11', 'day' =&gt; '07' )) Note that setValues() is also available, but this will replace any previous default values entirely, instead of merging with the existing default value. setSecure() -- When true the $server['HTTPS'] value must be on, or the request must be on port 443; when false, neither of those must be in place. setWildcard() -- Sets the name of a wildcard param; this is where arbitrary slash-separated values appearing after the route path will be stored. setRoutable() -- When false the route will be used only for generating paths, not for matching (true by default). setIsMatchCallable() -- A custom callable with the signature function(array $server, \\ArrayObject $matches) that returns true on a match, or false if not. This allows developers to build any kind of matching logic for the route, and to change the $matches for param values from the path. setGenerateCallable() -- A custom callable with the signature function(\\ArrayObject $data). This allows developers to modify the data for path interpolation. Here is a full extended route specification named read:&lt;?php $router-&gt;add('blog.read', '\/blog\/read\/{id}{format}') -&gt;addTokens(array( 'id' =&gt; '\\d+', 'format' =&gt; '(\\.[^\/]+)?', 'REQUEST_METHOD' =&gt; 'GET|POST', )) -&gt;addValues(array( 'id' =&gt; 1, 'format' =&gt; '.html', )) -&gt;setSecure(false) -&gt;setRoutable(false) -&gt;setIsMatchCallable(function(array $server, \\ArrayObject $matches) { \/\/ disallow matching if referred from example.com if ($server['HTTP_REFERER'] == 'http:\/\/example.com') { return false; } \/\/ add the referer from $server to the match values $matches['referer'] = $server['HTTP_REFERER']; return true; }) -&gt;setGenerateCallable(function (\\ArrayObject $data) { $data['foo'] = 'bar'; }); ?&gt; "},{"id":"\/packages\/2.x\/Router.html#4-10-3-2","title":"4.10.3.2. Default Route Specifications","content":"You can set the default route specifications with the following Router methods; the values will apply to all routes added thereafter.&lt;?php \/\/ add to the default 'tokens' expressions; setTokens() is also available $router-&gt;addTokens(array( 'id' =&gt; '\\d+', )); \/\/ add to the default 'server' expressions; setServer() is also available $router-&gt;addServer(array( 'REQUEST_METHOD' =&gt; 'PUT|PATCH', )); \/\/ add to the default param values; setValues() is also available $router-&gt;addValues(array( 'format' =&gt; null, )); \/\/ set the default 'secure' value $router-&gt;setSecure(true); \/\/ set the default wildcard param name $router-&gt;setWildcard('other'); \/\/ set the default 'routable' flag $router-&gt;setRoutable(false); \/\/ set the default 'isMatch()' callable $router-&gt;setIsMatchCallable(function (...) { ... }); \/\/ set the default 'generate()' callable $router-&gt;setGenerateCallable(function (...) { ... }); ?&gt; "},{"id":"\/packages\/2.x\/Router.html#4-10-3-3","title":"4.10.3.3. Simple Routes","content":"You don't need to specify an extended route specification. With the following simple route ...&lt;?php $router-&gt;add('archive', '\/archive\/{year}\/{month}\/{day}'); ?&gt; ... the Router will use a default subpattern that matches everything except slashes for the path params. Thus, the above simple route is equivalent to the following extended route:&lt;?php $router-&gt;add('archive', '\/archive\/{year}\/{month}\/{day}') -&gt;setValues(array( 'action' =&gt; 'archive', )) -&gt;addTokens(array( 'year' =&gt; '[^\/]+', 'month' =&gt; '[^\/]+', 'day' =&gt; '[^\/]+', )); ?&gt; "},{"id":"\/packages\/2.x\/Router.html#4-10-3-4","title":"4.10.3.4. Automatic Params","content":"The Router will automatically populate values for the action route param if one is not set manually.&lt;?php \/\/ ['action' =&gt; 'foo.bar'] because it has not been set otherwise $router-&gt;add('foo.bar', '\/path\/to\/bar'); \/\/ ['action' =&gt; 'zim'] because we add it explicitly $router-&gt;add('foo.dib', '\/path\/to\/dib') -&gt;addValues(array('action' =&gt; 'zim')); \/\/ the 'action' param here will be whatever the path value for {action} is $router-&gt;add('\/path\/to\/{action}'); ?&gt; "},{"id":"\/packages\/2.x\/Router.html#4-10-3-5","title":"4.10.3.5. Optional Params","content":"Sometimes it is useful to have a route with optional named params. None, some, or all of the optional params may be present, and the route will still match.To specify optional params, use the notation {\/param1,param2,param3} in the path. For example:&lt;?php $router-&gt;add('archive', '\/archive{\/year,month,day}') -&gt;addTokens(array( 'year' =&gt; '\\d{4}', 'month' =&gt; '\\d{2}', 'day' =&gt; '\\d{2}' )); ?&gt;  N.b.: The leading slash separator is inside the params token, not outside. With that, the following routes will all match the 'archive' route, and will set the appropriate values:\/archive \/archive\/1979 \/archive\/1979\/11 \/archive\/1979\/11\/07 Optional params are sequentially optional. This means that, in the above example, you cannot have a \"day\" without a \"month\", and you cannot have a \"month\" without a \"year\".Only one set of optional params per path is recognized by the Router.Optional params belong at the end of a route path; placing them elsewhere may result in unexpected behavior.If you generate() a link with optional params, the params will be filled in if they are present in the data for the link. Remember, the optional params are sequentially optional, so the params will not be filled in after the first missing one:&lt;?php $router-&gt;add('archive', '\/archive{\/year,month,day}') -&gt;addTokens(array( 'year' =&gt; '\\d{4}', 'month' =&gt; '\\d{2}', 'day' =&gt; '\\d{2}' )); $link = $router-&gt;generate('archive', array( 'year' =&gt; '1979', 'month' =&gt; '11', )); \/\/ \"\/archive\/1979\/11\" ?&gt; Similarly, optional params can be used as a generic catchall route:&lt;?php $router-&gt;add('generic', '{\/controller,action,id}') -&gt;setValues(array( 'controller' =&gt; 'index', 'action' =&gt; 'browse', 'id' =&gt; null, ); ?&gt; That will match these paths, with these param values:\/ : 'controller' =&gt; 'index', 'action' =&gt; 'browse', 'id' =&gt; null \/foo : 'controller' =&gt; 'foo', 'action' =&gt; 'browse', 'id' =&gt; null \/foo\/bar : 'controller' =&gt; 'foo', 'action' =&gt; 'bar', 'id' =&gt; null \/foo\/bar\/42 : 'controller' =&gt; 'foo', 'action' =&gt; 'bar', 'id' =&gt; '42' "},{"id":"\/packages\/2.x\/Router.html#4-10-3-6","title":"4.10.3.6. Wildcard Params","content":"Sometimes it is useful to allow the trailing part of the path be anything at all. To allow arbitrary trailing params on a route, extend the route definition with setWildcard() to specify param name under which the arbitrary trailing param values will be stored.&lt;?php $router-&gt;add('wild_post', '\/post\/{id}') -&gt;setWildcard('other'); \/\/ this matches, with the following values $route = $router-&gt;match('\/post\/88\/foo\/bar\/baz', $_SERVER); \/\/ $route-&gt;params['id'] = 88; \/\/ $route-&gt;params['other'] = array('foo', 'bar', 'baz') \/\/ this also matches, with the following values; note the trailing slash $route = $router-&gt;match('\/post\/88\/', $_SERVER); \/\/ $route-&gt;params['id'] = 88; \/\/ $route-&gt;params['other'] = array(); \/\/ this also matches, with the following values; note the missing slash $route = $router-&gt;match('\/post\/88', $_SERVER); \/\/ $route-&gt;params['id'] = 88; \/\/ $route-&gt;params['other'] = array(); ?&gt; If you generate() a link with wildcard params, the wildcard key in the data will be used for the trailing arbitrary param values:&lt;?php $router-&gt;add('wild_post', '\/post\/{id}') -&gt;setWildcard('other'); $link = $router-&gt;generate('wild_post', array( 'id' =&gt; '88', 'other' =&gt; array( 'foo', 'bar', 'baz', ); )); \/\/ \"\/post\/88\/foo\/bar\/baz\" ?&gt; "},{"id":"\/packages\/2.x\/Router.html#4-10-3-7","title":"4.10.3.7. Attaching Route Groups","content":"You can add a series of routes all at once under a single \"mount point\" in your application. For example, if you want all your blog-related routes to be mounted at \/blog in your application, you can do this:&lt;?php $name_prefix = 'blog'; $path_prefix = '\/blog'; $router-&gt;attach($name_prefix, $path_prefix, function ($router) { $router-&gt;add('browse', '{format}') -&gt;addTokens(array( 'format' =&gt; '(\\.json|\\.atom|\\.html)?' )) -&gt;addValues(array( 'format' =&gt; '.html', )); $router-&gt;add('read', '\/{id}{format}') -&gt;addTokens(array( 'id' =&gt; '\\d+', 'format' =&gt; '(\\.json|\\.atom|\\.html)?' )) -&gt;addValues(array( 'format' =&gt; '.html', )); $router-&gt;add('edit', '\/{id}\/edit{format}') -&gt;addTokens(array( 'id' =&gt; '\\d+', 'format' =&gt; '(\\.json|\\.atom|\\.html)?' )) -&gt;addValues(array( 'format' =&gt; '.html', )); }); ?&gt; Each of the route names will be prefixed with 'blog.', and each of the route paths will be prefixed with \/blog, so the effective route names and paths become: blog.browse =&gt; \/blog{format} blog.read =&gt; \/blog\/{id}{format} blog.edit =&gt; \/blog\/{id}\/edit{format} You can set other route specification values as part of the attachment specification; these will be used as the defaults for each attached route, so you don't need to repeat common information. (Setting these values will not affect routes outside the attached group.)&lt;?php $name_prefix = 'blog'; $path_prefix = '\/blog'; $router-&gt;attach($name_prefix, $path_prefix, function ($router) { $router-&gt;setTokens(array( 'id' =&gt; '\\d+', 'format' =&gt; '(\\.json|\\.atom)?' )); $router-&gt;setValues(array( 'format' =&gt; '.html', )); $router-&gt;add('browse', ''); $router-&gt;add('read', '\/{id}{format}'); $router-&gt;add('edit', '\/{id}\/edit'); }); ?&gt; "},{"id":"\/packages\/2.x\/Router.html#4-10-3-8","title":"4.10.3.8. Attaching REST Resource Routes","content":"The router can attach a series of REST resource routes for you with the attachResource() method:&lt;?php $router-&gt;attachResource('blog', '\/blog'); ?&gt; That method call will result in the following routes being added:| Route Name | HTTP Method | Route Path | Purpose | ------------- | ------------- | --------------------- | ------- | blog.browse | GET | \/blog{format} | Browse multiple resources | blog.read | GET | \/blog\/{id}{format} | Read a single resource | blog.edit | GET | \/blog\/{id}\/edit | The form for editing a resource | blog.add | GET | \/blog\/add | The form for adding a resource | blog.delete | DELETE | \/blog\/{id} | Delete a single resource | blog.create | POST | \/blog | Create a new resource | blog.update | PATCH | \/blog\/{id} | Update part of an existing resource | blog.replace | PUT | \/blog\/{id} | Replace an entire existing resourceThe {id} token is whatever has already been defined in the router; if not already defined, it will be any series of numeric digits. Likewise, the {format} token is whatever has already been defined in the router; if not already defined, it is an optional dot-format file extension (including the dot itself).The action value is the same as the route name.If you want calls to attachResource() to create a different series of REST routes, use the setResourceCallable() method to set your own callable to create them.&lt;?php $router-&gt;setResourceCallable(function ($router) { $router-&gt;setTokens(array( 'id' =&gt; '([a-f0-9]+)' )); $router-&gt;addPost('create', '\/{id}'); $router-&gt;addGet('read', '\/{id}'); $router-&gt;addPatch('update', '\/{id}'); $router-&gt;addDelete('delete', '\/{id}'); }); ?&gt; That example will cause only four CRUD routes, using hexadecimal resource IDs, to be added for the resource when you call attachResource()."},{"id":"\/packages\/2.x\/Router.html#4-10-3-9","title":"4.10.3.9. Setting A Base Path","content":"The router assumes that all URL paths begin at the top document root, but sometimes you will need them to begin in a subdirectory. In that case, you can instantiate the RouterFactory with an explicit base path; this base path will be used as a prefix for all route matching and path generation.&lt;?php \/\/ create a factory with a base path $router_factory = new RouterFactory('\/path\/to\/subdir'); \/\/ define a route as normal $router = $router_factory-&gt;getInstance(); $router-&gt;addGet('blog.read', '\/blog\/{id}'); \/\/ if the incoming request is for \"\/path\/to\/subdir\/blog\/{id}\" \/\/ then the route will match. $path = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH); $route = $router-&gt;match($path, $_SERVER); \/\/ generating a path from the route will add the base path automatically $path = $router-&gt;generate('blog.read', '88'); echo $path; \/\/ \"\/path\/to\/subdir\/blog\/88\" ?&gt; "},{"id":"\/packages\/2.x\/Router.html#4-10-3-10","title":"4.10.3.10. Caching Route Information","content":"You may wish to cache the router for production deployments so that the router does not have to build the route objects from definitions on each page load. The methods getRoutes() and setRoutes() may be used for that purpose.The following is a naive example for file-based caching and restoring of routes:&lt;?php \/\/ the cache file location $cache = '\/path\/to\/routes.cache'; \/\/ does the cache exist? if (file_exists($cache)) { \/\/ restore from the cache $routes = unserialize(file_get_contents($cache)); $router-&gt;setRoutes($routes); } else { \/\/ build the routes using add() and attach() ... \/\/ ... ... ... \/\/ ... then save to the cache for the next page load $routes = $router-&gt;getRoutes(); file_put_contents($cache, serialize($routes)); } ?&gt; Note that if there are closures in the Route objects (e.g. for isMatch() or generate()), you will not be able to cache the routes; this is because closures cannot be serialized properly for caching. Consider using non-closure callables instead."},{"id":"\/packages\/2.x\/Router.html#4-10-3-11","title":"4.10.3.11. As a Micro-Framework","content":"Sometimes you may wish to use the Router as a micro-framework. This is possible by assigning a callable as a default param value, usually action, then calling that param to dispatch it.&lt;?php $router-&gt;add('read', '\/blog\/read\/{id}{format}') -&gt;addTokens(array( 'id' =&gt; '\\d+', 'format' =&gt; '(\\.[^\/]+)?', )) -&gt;addValues(array( 'action' =&gt; function ($params) { if ($params['format'] == '.json') { $id = (int) $params['id']; header('Content-Type: application\/json'); echo json_encode(['id' =&gt; $id]); } else { $id = (int) $params['id']; header('Content-Type: text\/plain'); echo \"Reading blog ID {$id}\"; } }, 'format' =&gt; '.html', )); ?&gt; Alternatively, and perhaps more easily, you may specify a third parameter to the add() method; this will be used as the action value in the params. The following is identical to the above:&lt;?php $router-&gt;add( 'read', '\/blog\/read\/{id}{format}', function ($params) { if ($params['format'] == '.json') { $id = (int) $params['id']; header('Content-Type: application\/json'); echo json_encode(['id' =&gt; $id]); } else { $id = (int) $params['id']; header('Content-Type: text\/plain'); echo \"Reading blog ID {$id}\"; } }) -&gt;addTokens(array( 'id' =&gt; '\\d+', 'format' =&gt; '(\\.[^\/]+)?', )) -&gt;addValues(array( 'format' =&gt; '.html', )); ?&gt; A naive micro-framework dispatcher might then work like this:&lt;?php \/\/ get the route params $params = $route-&gt;params; \/\/ extract the action callable from the params $action = $params['action']; unset($params['action']); \/\/ invoke the callable $action($params); ?&gt; With the above example action, the URL \/blog\/read\/1.json will send JSON ouput, but for \/blog\/read\/1 it will send plain text output."},{"id":"\/packages\/2.x\/Session.html#4-11","title":"4.11. Aura Session","content":"Provides session management functionality, including lazy session starting, session segments, next-request-only (\"flash\") values, and CSRF tools."},{"id":"\/packages\/2.x\/Session.html#4-11-1-1","title":"4.11.1.1. Installation","content":"This library requires PHP 5.3 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/session.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/Session.html#4-11-1-2","title":"4.11.1.2. Quality","content":" To run the unit tests at the command line, issue composer install and then vendor\/bin\/phpunit at the package root. This requires Composer to be available as composer.This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/Session.html#4-11-1-3","title":"4.11.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/Session.html#4-11-2-1","title":"4.11.2.1. Instantiation","content":"The easiest way to get started is to use the SessionFactory to create a Session manager object.&lt;?php $session_factory = new \\Aura\\Session\\SessionFactory; $session = $session_factory-&gt;newInstance($_COOKIE); ?&gt; We can then use the Session instance to create Segment objects to manage session values and flashes. (In general, we should not need to manipulate the Session manager directly -- we will work mostly with Segment objects.)"},{"id":"\/packages\/2.x\/Session.html#4-11-2-2","title":"4.11.2.2. Segments","content":"In normal PHP, we keep session values in the $_SESSION array. However, when different libraries and projects try to modify the same keys, the resulting conflicts can result in unexpected behavior. To resolve this, we use Segment objects. Each Segment addresses a named key within the $_SESSION array for deconfliction purposes.For example, if we get a Segment for Vendor\\Package\\ClassName, that Segment will contain a reference to $_SESSION['Vendor\\Package\\ClassName']. We can then set() and get() values on the Segment, and the values will reside in an array under that reference.&lt;?php \/\/ get a _Segment_ object $segment = $session-&gt;getSegment('Vendor\\Package\\ClassName'); \/\/ try to get a value from the segment; \/\/ if it does not exist, return an alternative value echo $segment-&gt;get('foo'); \/\/ null echo $segment-&gt;get('baz', 'not set'); \/\/ 'not set' \/\/ set some values on the segment $segment-&gt;set('foo', 'bar'); $segment-&gt;set('baz', 'dib'); \/\/ the $_SESSION array is now: \/\/ $_SESSION = array( \/\/ 'Vendor\\Package\\ClassName' =&gt; array( \/\/ 'foo' =&gt; 'bar', \/\/ 'baz' =&gt; 'dib', \/\/ ), \/\/ ); \/\/ try again to get a value from the segment echo $segment-&gt;get('foo'); \/\/ 'bar' \/\/ because the segment is a reference to $_SESSION, we can modify \/\/ the superglobal directly and the segment values will also change $_SESSION['Vendor\\Package\\ClassName']['zim'] = 'gir' echo $segment-&gt;get('zim'); \/\/ 'gir' ?&gt; The benefit of a session segment is that we can deconflict the keys in the $_SESSION superglobal by using class names (or some other unique name) for the segment names. With segments, different packages can use the $_SESSION superglobal without stepping on each other's toes.To clear all the values on a Segment, use the clear() method."},{"id":"\/packages\/2.x\/Session.html#4-11-2-3","title":"4.11.2.3. Flash Values","content":"Segment values persist until the session is cleared or destroyed. However, sometimes it is useful to set a value that propagates only through the next request, and is then discarded. These are called \"flash\" values."},{"id":"\/packages\/2.x\/Session.html#4-11-2-3-1","title":"4.11.2.3.1. Setting And Getting Flash Values","content":"To set a flash value on a Segment, use the setFlash() method.&lt;?php $segment = $session-&gt;getSegment('Vendor\\Package\\ClassName'); $segment-&gt;setFlash('message', 'Hello world!'); ?&gt; Then, in subsequent requests, we can read the flash value using getFlash():&lt;?php $segment = $session-&gt;getSegment('Vendor\\Package\\ClassName'); $message = $segment-&gt;getFlash('message'); \/\/ 'Hello world!' ?&gt;  N.b. As with get(), we can provide an alternative value if the flash key does not exist. For example, getFlash('foo', 'not set') will return 'not set' if there is no 'foo' key available. Using setFlash() makes the flash value available only in the next request, not the current one. To make the flash value available immediately as well as in the next request, use setFlashNow($key, $val).Using getFlash() returns only the values that are available now from having been set in the previous request. To read a value that will be available in the next request, use getFlashNext($key, $alt)."},{"id":"\/packages\/2.x\/Session.html#4-11-2-3-2","title":"4.11.2.3.2. Keeping and Clearing Flash Values","content":"Sometimes we will want to keep the flash values in the current request for the next request. We can do so on a per-segment basis by calling the Segment keepFlash() method, or we can keep all flashes for all segments by calling the Session keepFlash() method.Similarly, we can clear flash values on a per-segment basis or a session-wide bases. Use the clearFlash() method on the Segment to clear flashes just for that segment, or the same method on the Session to clear all flash values for all segments."},{"id":"\/packages\/2.x\/Session.html#4-11-2-4","title":"4.11.2.4. Lazy Session Starting","content":"Merely instantiating the Session manager and getting a Segment from it does not call session_start(). Instead, session_start() occurs only in certain circumstances: If we read from a Segment (e.g. with get()) the Session looks to see if a session cookie has already been set. If so, it will call session_start() to resume the previously-started session. If not, it knows there are no previously existing $_SESSION values, so it will not call session_start(). If we write to a Segment (e.g. with set()) the Session will always call session_start(). This will resume a previous session if it exists, or start a new one if it does not. This means we can create each Segment at will, and session_start() will not be invoked until we actually interact with a Segment in a particular way. This helps to conserve the resources involved in starting a session.Of course, we can force a session start or reactivation by calling the Session start() method, but that defeats the purpose of lazy-loaded sessions."},{"id":"\/packages\/2.x\/Session.html#4-11-2-5","title":"4.11.2.5. Saving, Clearing, and Destroying Sessions","content":" N.b.: These methods apply to all session data and flashes across all segments. To save the session data and end its use during the current request, call the commit() method on the Session manager:&lt;?php $session-&gt;commit(); ?&gt;  N.b.: Per http:\/\/php.net\/manual\/en\/session.examples.basic.php, \"Sessions normally shutdown automatically when PHP is finished executing a script, but can be manually shutdown using the session_write_close() function.\" The commit() method is the equivalent of session_write_close(). To clear all session data, but leave the session active during the current request, use the clear() method on the Session manager.&lt;?php $session-&gt;clear(); ?&gt; To clear all flash values on a segment, use the clearFlash() method:To clear the data and terminate the session for this and future requests, thereby destroying it completely, call the destroy() method:&lt;?php $session-&gt;destroy(); \/\/ equivalent of session_destroy() ?&gt; Calling destroy() will also delete the session cookie via setcookie(). If we have an alternative means by which we delete cookies, we should pass a callable as the second argument to the SessionFactory method newInstance(). The callable should take three parameters: the cookie name, path, and domain.&lt;?php \/\/ assume $response is a framework response object. \/\/ this will be used to delete the session cookie. $delete_cookie = function ($name, $path, $domain) use ($response) { $response-&gt;cookies-&gt;delete($name, $path, $domain); } $session = $session_factory-&gt;newInstance($_COOKIE, $delete_cookie); ?&gt; "},{"id":"\/packages\/2.x\/Session.html#4-11-3-1","title":"4.11.3.1. Session ID Regeneration","content":"Any time a user has a change in privilege (that is, gaining or losing access rights within a system) be sure to regenerate the session ID:&lt;?php $session-&gt;regenerateId(); ?&gt;  N.b.: The regenerateId() method also regenerates the CSRF token value. "},{"id":"\/packages\/2.x\/Session.html#4-11-3-2","title":"4.11.3.2. Cross-Site Request Forgery","content":"A \"cross-site request forgery\" is a security issue where the attacker, via malicious JavaScript or other means, issues a request in-the-blind from a client browser to a server where the user has already authenticated. The request looks valid to the server, but in fact is a forgery, since the user did not actually make the request (the malicious JavaScript did).http:\/\/en.wikipedia.org\/wiki\/Cross-site_request_forgery"},{"id":"\/packages\/2.x\/Session.html#4-11-3-2-1","title":"4.11.3.2.1. Defending Against CSRF","content":"To defend against CSRF attacks, server-side logic should: Place a token value unique to each authenticated user session in each form; and Check that all incoming POST\/PUT\/DELETE (i.e., \"unsafe\") requests contain that value.  N.b.: If our application uses GET requests to modify resources (which incidentally is an improper use of GET), we should also check for CSRF on GET requests from authenticated users. For this example, the form field name will be __csrf_value. In each form we want to protect against CSRF, we use the session CSRF token value for that field:&lt;?php \/** * @var Vendor\\Package\\User $user A user-authentication object. * @var Aura\\Session\\Session $session A session management object. *\/ ?&gt; &lt;form method=\"post\"&gt; &lt;?php if ($user-&gt;auth-&gt;isValid()) { $csrf_value = $session-&gt;getCsrfToken()-&gt;getValue(); echo '&lt;input type=\"hidden\" name=\"__csrf_value\" value=\"' . htmlspecialchars($csrf_value, ENT_QUOTES, 'UTF-8') . '\"&gt;&lt;\/input&gt;'; } ?&gt; &lt;!-- other form fields --&gt; &lt;\/form&gt; When processing the request, check to see if the incoming CSRF token is valid for the authenticated user:&lt;?php \/** * @var Vendor\\Package\\User $user A user-authentication object. * @var Aura\\Session\\Session $session A session management object. *\/ $unsafe = $_SERVER['REQUEST_METHOD'] == 'POST' || $_SERVER['REQUEST_METHOD'] == 'PUT' || $_SERVER['REQUEST_METHOD'] == 'DELETE'; if ($unsafe &amp;&amp; $user-&gt;auth-&gt;isValid()) { $csrf_value = $_POST['__csrf_value']; $csrf_token = $session-&gt;getCsrfToken(); if (! $csrf_token-&gt;isValid($csrf_value)) { echo \"This looks like a cross-site request forgery.\"; } else { echo \"This looks like a valid request.\"; } } else { echo \"CSRF attacks only affect unsafe requests by authenticated users.\"; } ?&gt; "},{"id":"\/packages\/2.x\/Session.html#4-11-3-2-2","title":"4.11.3.2.2. CSRF Value Generation","content":"For a CSRF token to be useful, its random value must be cryptographically secure. Using things like mt_rand() is insufficient. Aura.Session comes with a Randval class that implements a RandvalInterface. It uses the random_bytes() function preferentially, then openssl, or finally mcrypt to generate a random value. If you do not have one of these installed, you will need your own random-value implementation of the RandvalInterface. We suggest a wrapper around RandomLib."},{"id":"\/packages\/2.x\/Session.html#4-11-3-3","title":"4.11.3.3. Session Lifetime","content":"We can set the session lifetime to as long (or as short) as we like using the setCookieParams on Session object. The lifetime is in seconds. To set the session cookie lifetime to two weeks:&lt;?php $session-&gt;setCookieParams(array('lifetime' =&gt; '1209600')); ?&gt;  N.b: The setCookieParams method calls session_set_cookie_params internally. "},{"id":"\/packages\/2.x\/Sql.html#4-12","title":"4.12. Aura.Sql","content":"Provides an extension to the native PDO along with a profiler and connection locator. Because ExtendedPdo is an extension of the native PDO, code already using the native PDO or typehinted to the native PDO can use ExtendedPdo without any changes.Added functionality in Aura.Sql over the native PDO includes: Lazy connection. ExtendedPdo connects to the database only on method calls that require a connection. This means you can create an instance and not incur the cost of a connection if you never make a query. Decoration. ExtendedPdo can be used to decorate an existing PDO instance. This means that a PDO instance can be \"extended\" at runtime to provide the ExtendedPdo behaviors. (Note that lazy connection is not possible in this case, as the PDO instance being decorated has already connected.) Array quoting. The quote() method will accept an array as input, and return a string of comma-separated quoted values. New perform() method. The perform() method acts just like query(), but binds values to a prepared statement as part of the call. In addition, placeholders that represent array values will be replaced with comma- separated quoted values. This means you can bind an array of values to a placeholder used with an IN (...) condition when using perform(). New fetch*() methods. The new fetch*() methods provide for commonly-used fetch actions. For example, you can call fetchAll() directly on the instance instead of having to prepare a statement, bind values, execute, and then fetch from the prepared statement. All of the fetch*() methods take an array of values to bind to to the query statement, and use the new perform() method internally. New yield*() methods. The equivalent of various fetch*() methods, the yield*() methods return an iterator instead of a complete result set. Using the iterator to fetch one result at a time can help reduce memory usage with very large result sets. Exceptions by default. ExtendedPdo starts in the ERRMODE_EXCEPTION mode for error reporting instead of the ERRMODE_SILENT mode. Profiler. An optional query profiler is provided, along with an interface for other implementations. Connection locator. A optional lazy-loading service locator is provided for picking different database connections (default, read, and write). "},{"id":"\/packages\/2.x\/Sql.html#4-12-1-1","title":"4.12.1.1. Installation","content":"This library requires PHP 5.3 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/sql.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/Sql.html#4-12-1-2","title":"4.12.1.2. Quality","content":" To run the PHPUnit unit tests at the command line, issue composer install and then vendor\/bin\/phpunit at the package root. (This requires Composer to be available as composer.)This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/Sql.html#4-12-1-3","title":"4.12.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/Sql.html#4-12-2-1","title":"4.12.2.1. Instantiation","content":"You can instantiate ExtendedPdo so that it uses lazy connection, or you can use it to decorate an existing PDO instance."},{"id":"\/packages\/2.x\/Sql.html#4-12-2-1-1","title":"4.12.2.1.1. Lazy Connection Instance","content":"Instantiation is the same as with the native PDO class: pass a data source name, username, password, and driver options. There is one additional parameter that allows you to pass attributes to be set after the connection is made.use Aura\\Sql\\ExtendedPdo; $pdo = new ExtendedPdo( 'mysql:host=localhost;dbname=test', 'username', 'password', array(), \/\/ driver options as key-value pairs array() \/\/ attributes as key-value pairs );  N.b.: The sqlsrv extension will fail to connect when using error mode PDO::ERRMODE_EXCEPTION. To connect, you will need to explicitly pass array(PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_WARNING) (or PDO::ERRMODE_SILENT) when using sqlsrv. Whereas the native PDO connects on instantiation, ExtendedPdo does not connect immediately. Instead, it connects only when you call a method that actually needs the connection to the database; e.g., on query().If you want to force a connection, call the connect() method.\/\/ does not connect to the database $pdo = new ExtendedPdo( 'mysql:host=localhost;dbname=test', 'username', 'password' ); \/\/ automatically connects $pdo-&gt;exec('SELECT * FROM test'); \/\/ explicitly forces a connection $pdo-&gt;connect(); If you want to explicitly force a disconnect, call the disconnect() method.\/\/ explicitly forces disconnection $pdo-&gt;disconnect(); Doing so will close the connection by unsetting the internal PDO instance. However, calling an ExtendedPdo method that implicitly establishes a connection, such as query() or one of the fetch*() methods, will automatically re-connect to the database."},{"id":"\/packages\/2.x\/Sql.html#4-12-2-1-2","title":"4.12.2.1.2. Decorator Instance","content":"The ExtendedPdo class can be used to decorate an existing PDO connection as well. To do so, instantiate ExtendedPdo by passing an existing PDO connection:use Aura\\Sql\\ExtendedPdo; $pdo = new PDO(...); $extended_pdo = new ExtendedPdo($pdo); The decorated PDO instance now provides all the ExtendedPdo functionality (aside from lazy connection, which is not possible since the PDO instance by definition has already connected).Decoration of this kind can be useful when you have access to an existing PDO connection managed elsewhere in your application. N.b.: The disconnect() method will not work on decorated PDO connections, since ExtendedPdo did not create the connection itself. You will need to manage the decorated PDO instance yourself in that case. "},{"id":"\/packages\/2.x\/Sql.html#4-12-2-2","title":"4.12.2.2. Array Quoting","content":"The native PDO quote() method will not quote arrays. This makes it difficult to bind an array to something like an IN (...) condition in SQL. However, ExtendedPdo recognizes arrays and converts them into comma- separated quoted strings.\/\/ the array to be quoted $array = array('foo', 'bar', 'baz'); \/\/ the native PDO way: \/\/ \"Warning: PDO::quote() expects parameter 1 to be string, array given\" $pdo = new PDO(...); $cond = 'IN (' . $pdo-&gt;quote($array) . ')'; \/\/ the ExtendedPdo way: \/\/ \"IN ('foo', 'bar', 'baz')\" $pdo = new ExtendedPdo(...); $cond = 'IN (' . $pdo-&gt;quote($array) . ')'; "},{"id":"\/packages\/2.x\/Sql.html#4-12-2-3","title":"4.12.2.3. The perform() Method","content":"The new perform() method will prepare a query with bound values in a single step. Also, because the native PDO does not deal with bound array values, perform() modifies the query string to replace array-bound placeholders with the quoted array. Note that this is not the same thing as binding: the query string itself is modified before passing to the database for value binding.\/\/ the array to be quoted $array = array('foo', 'bar', 'baz'); \/\/ the statement to prepare $stm = 'SELECT * FROM test WHERE foo IN (:foo)' \/\/ the native PDO way does not work (PHP Notice: Array to string conversion) $pdo = new ExtendedPdo(...); $sth = $pdo-&gt;prepare($stm); $sth-&gt;bindValue('foo', $array); \/\/ the ExtendedPdo way allows a single call to prepare and execute the query. \/\/ it quotes the array and replaces the array placeholder directly in the \/\/ query string $pdo = new ExtendedPdo(...); $bind_values = array('foo' =&gt; $array); $sth = $pdo-&gt;perform($stm, $bind_values); echo $sth-&gt;queryString; \/\/ the query string has been modified by ExtendedPdo to become \/\/ \"SELECT * FROM test WHERE foo IN ('foo', 'bar', 'baz')\" Finally, note that array quoting works only via the perform() method, not on returned PDOStatement instances."},{"id":"\/packages\/2.x\/Sql.html#4-12-2-4","title":"4.12.2.4. New fetch*() Methods","content":"ExtendedPdo comes with fetch*() methods to help reduce boilerplate code. Instead of issuing prepare(), a series of bindValue() calls, execute(), and then fetch*() on a PDOStatement, you can bind values and fetch results in one call on ExtendedPdo directly. (The fetch*() methods use perform() internally, so quoting-and-replacement of array placeholders is supported.)$stm = 'SELECT * FROM test WHERE foo = :foo AND bar = :bar'; $bind = array('foo' =&gt; 'baz', 'bar' =&gt; 'dib'); \/\/ the native PDO way to \"fetch all\" where the result is a sequential array \/\/ of rows, and the row arrays are keyed on the column names $pdo = new PDO(...); $sth = $pdo-&gt;prepare($stm); $sth-&gt;execute($bind); $result = $sth-&gt;fetchAll(PDO::FETCH_ASSOC); \/\/ the ExtendedPdo way to do the same kind of \"fetch all\" $pdo = new ExtendedPdo(...); $result = $pdo-&gt;fetchAll($stm, $bind); \/\/ fetchAssoc() returns an associative array of all rows where the key is the \/\/ first column, and the row arrays are keyed on the column names $result = $pdo-&gt;fetchAssoc($stm, $bind); \/\/ fetchGroup() is like fetchAssoc() except that the values aren't wrapped in \/\/ arrays. Instead, single column values are returned as a single dimensional \/\/ array and multiple columns are returned as an array of arrays \/\/ Set style to PDO::FETCH_NAMED when values are an array \/\/ (i.e. there are more than two columns in the select) $result = $pdo-&gt;fetchGroup($stm, $bind, $style = PDO::FETCH_COLUMN) \/\/ fetchObject() returns the first row as an object of your choosing; the \/\/ columns are mapped to object properties. an optional 4th parameter array \/\/ provides constructor arguments when instantiating the object. $result = $pdo-&gt;fetchObject($stm, $bind, 'ClassName', array('ctor_arg_1')); \/\/ fetchObjects() returns an array of objects of your choosing; the \/\/ columns are mapped to object properties. an optional 4th parameter array \/\/ provides constructor arguments when instantiating the object. $result = $pdo-&gt;fetchObjects($stm, $bind, 'ClassName', array('ctor_arg_1')); \/\/ fetchOne() returns the first row as an associative array where the keys \/\/ are the column names $result = $pdo-&gt;fetchOne($stm, $bind); \/\/ fetchPairs() returns an associative array where each key is the first \/\/ column and each value is the second column $result = $pdo-&gt;fetchPairs($stm, $bind); \/\/ fetchValue() returns the value of the first row in the first column $result = $pdo-&gt;fetchValue($stm, $bind); \/\/ fetchAffected() returns the number of affected rows $stm = \"UPDATE test SET incr = incr + 1 WHERE foo = :foo AND bar = :bar\"; $row_count = $pdo-&gt;fetchAffected($stm, $bind); The methods fetchAll(), fetchAssoc(), fetchCol(), and fetchPairs() take an optional third parameter, a callable, to apply to each row of the results before returning.$result = $pdo-&gt;fetchAssoc($stm, $bind, function (&amp;$row) { \/\/ add a column to the row $row['my_new_col'] = 'Added this column from the callable.'; }); "},{"id":"\/packages\/2.x\/Sql.html#4-12-2-5","title":"4.12.2.5. New yield*() Methods","content":"ExtendedPdo comes with yield*() methods to help reduce memory usage. Whereas many fetch*() methods collect all the query result rows before returning them all at once, the equivalent yield*() methods return an iterator that generates one result row at a time. For example:$stm = 'SELECT * FROM test WHERE foo = :foo AND bar = :bar'; $bind = array('foo' =&gt; 'baz', 'bar' =&gt; 'dib'); \/\/ like fetchAll(), each row is an associative array foreach ($pdo-&gt;yieldAll($stm, $bind) as $row) { \/\/ ... } \/\/ like fetchAssoc(), each key is the first column, \/\/ and the row is an associative array foreach ($pdo-&gt;yieldAssoc($stm, $bind) as $key =&gt; $row) { \/\/ ... } \/\/ like fetchCol(), each result is a value from the first column foreach ($pdo-&gt;yieldCol($stm, $bind) as $val) { \/\/ ... } \/\/ like fetchObjects(), each result is an object; pass an optional \/\/ class name and optional array of constructor arguments. $class = 'ClassName'; $args = ['arg0', 'arg1', 'arg2']; foreach ($pdo-&gt;yieldObjects($stm, $bind, $class, $args) as $object) { \/\/ ... } \/\/ like fetchPairs(), each result is a key-value pair from the \/\/ first and second columns foreach ($pdo-&gt;yieldPairs($stm, $bind) as $key =&gt; $val) { \/\/ ... } "},{"id":"\/packages\/2.x\/Sql.html#4-12-3","title":"4.12.3. Profiler","content":"When debugging, it is often useful to see what queries have been executed, where they were issued from in the codebase, and how long they took to complete. ExtendedPdo comes with an optional profiler that you can use to discover that information.use Aura\\Sql\\ExtendedPdo; use Aura\\Sql\\Profiler; $pdo = new ExtendedPdo(...); $pdo-&gt;setProfiler(new Profiler); \/\/ ... \/\/ query(), fetch(), beginTransaction()\/commit()\/rollback() etc. \/\/ ... \/\/ now retrieve the profile information: $profiles = $pdo-&gt;getProfiler()-&gt;getProfiles(); Each profile entry will have these keys: duration: How long the query took to complete, in seconds. function: The method that was called on ExtendedPdo that created the profile entry. statement: The query string that was issued, if any. (Methods like connect() and rollBack() do not send query strings.) bind_values: Any values that were bound to the query. trace: An exception stack trace indicating where the query was issued from in the codebase. Note that an entry is made into the profile for each call to underlying ExtendedPDO methods. For example, in a simple query using a bind value, there will be two entries, one for the call to prepare and one for the call to perform.Setting the Profiler into the ExtendedPdo instance is optional. Once it is set, you can activate and deactivate it as you wish using the Profiler::setActive() method. When not active, query profiles will not be retained.$pdo = new ExtendedPdo(...); $pdo-&gt;setProfiler(new Profiler); \/\/ deactivate, issue a query, and reactivate; \/\/ the query will not show up in the profiles $pdo-&gt;getProfiler()-&gt;setActive(false); $pdo-&gt;fetchAll('SELECT * FROM foo'); $pdo-&gt;getProfiler()-&gt;setActive(true); "},{"id":"\/packages\/2.x\/Sql.html#4-12-4","title":"4.12.4. Connection Locator","content":"Frequently, high-traffic PHP applications use multiple database servers, generally one for writes, and one or more for reads. The ConnectionLocator allows you to define multiple ExtendedPdo objects for lazy-loaded read and write connections. It will create the connections only when they are when called. The creation logic is wrapped in a callable.First, create the ConnectionLocator:use Aura\\Sql\\ExtendedPdo; use Aura\\Sql\\ConnectionLocator; $connectionLocator = new ConnectionLocator; Now add a default connection; this will be used when a read or write connection is not defined. (This is also useful for setting up connection location in advance of actually having multiple database servers.)$connectionLocator-&gt;setDefault(function () { return new ExtendedPdo( 'mysql:host=default.db.localhost;dbname=database', 'username', 'password' ); }); Next, add as many named read and write connections as you like:\/\/ the write (master) server $connectionLocator-&gt;setWrite('master', function () { return new ExtendedPdo( 'mysql:host=master.db.localhost;dbname=database', 'username', 'password' ); }); \/\/ read (slave) #1 $connectionLocator-&gt;setRead('slave1', function () { return new ExtendedPdo( 'mysql:host=slave1.db.localhost;dbname=database', 'username', 'password' ); }); \/\/ read (slave) #2 $connectionLocator-&gt;setRead('slave2', function () { return new ExtendedPdo( 'mysql:host=slave2.db.localhost;dbname=database', 'username', 'password' ); }); \/\/ read (slave) #3 $connectionLocator-&gt;setRead('slave3', function () { return new ExtendedPdo( 'mysql:host=slave3.db.localhost;dbname=database', 'username', 'password' ); }); Finally, retrieve a connection from the locator when you need it. This will create the connection (if needed) and then return it. getDefault() will return the default connection. getRead() will return a named read connection; if no name is specified, it will return a random read connection. If no read connections are defined, it will return the default connection. getWrite() will return a named write connection; if no name is specified, it will return a random write connection. If no write connections are defined, it will return the default connection. $read = $connectionLocator-&gt;getRead(); $results = $read-&gt;fetchAll('SELECT * FROM table_name LIMIT 10'); "},{"id":"\/packages\/2.x\/Sql.html#4-12-4-1","title":"4.12.4.1. Construction-Time Configuration","content":"The ConnectionLocator can be configured with all its connections at construction time; this is useful with dependency injection mechanisms.use Aura\\Sql\\ConnectionLocator; use Aura\\Sql\\ExtendedPdo; \/\/ default connection $default = function () { return new ExtendedPdo( 'mysql:host=default.db.localhost;dbname=database', 'username', 'password' ); }; \/\/ read connections $read = array( 'slave1' =&gt; function () { return new ExtendedPdo( 'mysql:host=slave1.db.localhost;dbname=database', 'username', 'password' ); }, 'slave2' =&gt; function () { return new ExtendedPdo( 'mysql:host=slave2.db.localhost;dbname=database', 'username', 'password' ); }, 'slave3' =&gt; function () { return new ExtendedPdo( 'mysql:host=slave3.db.localhost;dbname=database', 'username', 'password' ); }, ); \/\/ write connection $write = array( 'master' =&gt; function () { return new ExtendedPdo( 'mysql:host=master.db.localhost;dbname=database', 'username', 'password' ); }, ); \/\/ configure locator at construction time $connectionLocator = new ConnectionLocator($default, $read, $write); "},{"id":"\/packages\/2.x\/Sql.html#4-12-4-2","title":"4.12.4.2. Profiler","content":"You can turn profiling on and off for all connections in the locator using the setProfiling() method. (If no profiler has been set on a connection, the locator will set a default profiler into it automatically.) To get all the profiled queries using the getProfiles() method.$connectionLocator-&gt;setProfiling(true); \/\/ perform queries, then: $profiles = $connectionLocator-&gt;getProfiles(); "},{"id":"\/packages\/2.x\/SqlQuery.html#4-13","title":"4.13. Aura.SqlQuery","content":"Provides query builders for MySQL, Postgres, SQLite, and Microsoft SQL Server. These builders are independent of any particular database connection library, although PDO in general is recommended."},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-1-1","title":"4.13.1.1. Installation","content":"This library requires PHP 5.3.9 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/sqlquery.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-1-2","title":"4.13.1.2. Quality","content":" To run the PHPUnit unit tests at the command line, issue composer install and then vendor\/bin\/phpunit at the package root. (This requires Composer to be available as composer.)This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-1-3","title":"4.13.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-2","title":"4.13.2. Getting Started","content":"First, instantiate a QueryFactory with a database type:&lt;?php use Aura\\SqlQuery\\QueryFactory; $query_factory = new QueryFactory('sqlite'); ?&gt; You can then use the factory to create query objects:&lt;?php $select = $query_factory-&gt;newSelect(); $insert = $query_factory-&gt;newInsert(); $update = $query_factory-&gt;newUpdate(); $delete = $query_factory-&gt;newDelete(); ?&gt; The query objects do not execute queries against a database. When you are done building the query, you will need to pass it to a database connection of your choice. In the examples below, we will use PDO for the database connection, but any database library that uses named placeholders and bound values should work just as well (e.g. the Aura.Sql ExtendedPdo class)."},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-3","title":"4.13.3. Identifier Quoting","content":"In most cases, the query objects will quote identifiers for you. For example, under the common Select object with double-quotes for identifiers:&lt;?php $select-&gt;cols(array('foo', 'bar AS barbar')) -&gt;from('table1') -&gt;from('table2') -&gt;where('table2.zim = 99'); echo $select-&gt;getStatement(); \/\/ SELECT \/\/ \"foo\", \/\/ \"bar\" AS \"barbar\" \/\/ FROM \/\/ \"table1\", \/\/ \"table2\" \/\/ WHERE \/\/ \"table2\".\"zim\" = 99 ?&gt; If you discover that a partially-qualified identifier has not been auto-quoted for you, change it to a fully-qualified identifer (e.g., from col_name to table_name.col_name)."},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-4","title":"4.13.4. Common Query Objects","content":"Although you must specify a database type when instantiating a QueryFactory, you can tell the factory to return \"common\" query objects instead of database- specific ones. This will make only the common query methods available, which helps with writing database-portable applications. To do so, pass the constant QueryFactory::COMMON as the second constructor parameter.&lt;?php use Aura\\SqlQuery\\QueryFactory; \/\/ return Common, not SQLite-specific, query objects $query_factory = new QueryFactory('sqlite', QueryFactory::COMMON); ?&gt;  N.b. You still need to pass a database type so that identifiers can be quoted appropriately. All query objects implement the \"Common\" methods."},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-4-1-1","title":"4.13.4.1.1. Building A Query","content":"Build a Select query using the following methods. They do not need to be called in any particular order, and may be called multiple times.&lt;?php $select = $query_factory-&gt;newSelect(); $select -&gt;distinct() \/\/ SELECT DISTINCT -&gt;cols(array( \/\/ select these columns 'id', \/\/ column name 'name AS namecol', \/\/ one way of aliasing 'col_name' =&gt; 'col_alias', \/\/ another way of aliasing 'COUNT(foo) AS foo_count' \/\/ embed calculations directly )) -&gt;from('foo AS f') \/\/ FROM these tables -&gt;fromSubSelect( \/\/ FROM sub-select AS my_sub 'SELECT ...', 'my_sub' ) -&gt;join( \/\/ JOIN ... 'LEFT', \/\/ left\/inner\/natural\/etc 'doom AS d', \/\/ this table name 'foo.id = d.foo_id' \/\/ ON these conditions ) -&gt;joinSubSelect( \/\/ JOIN to a sub-select 'INNER', \/\/ left\/inner\/natural\/etc 'SELECT ...', \/\/ the subselect to join on 'subjoin', \/\/ AS this name 'sub.id = foo.id' \/\/ ON these conditions ) -&gt;where('bar &gt; :bar') \/\/ AND WHERE these conditions -&gt;where('zim = ?', 'zim_val') \/\/ bind 'zim_val' to the ? placeholder -&gt;where('id IN (?, ?, ?)', 1, 2, 3) \/\/ WHERE id IN(1, 2, 3) -&gt;orWhere('baz &lt; :baz') \/\/ OR WHERE these conditions -&gt;groupBy(array('dib')) \/\/ GROUP BY these columns -&gt;having('foo = :foo') \/\/ AND HAVING these conditions -&gt;having('bar &gt; ?', 'bar_val') \/\/ bind 'bar_val' to the ? placeholder -&gt;orHaving('baz &lt; :baz') \/\/ OR HAVING these conditions -&gt;orderBy(array('baz')) \/\/ ORDER BY these columns -&gt;limit(10) \/\/ LIMIT 10 -&gt;offset(40) \/\/ OFFSET 40 -&gt;forUpdate() \/\/ FOR UPDATE -&gt;union() \/\/ UNION with a followup SELECT -&gt;unionAll() \/\/ UNION ALL with a followup SELECT -&gt;bindValue('foo', 'foo_val') \/\/ bind one value to a placeholder -&gt;bindValues(array( \/\/ bind these values to named placeholders 'bar' =&gt; 'bar_val', 'baz' =&gt; 'baz_val', )); ?&gt;  N.b.: The *where() and *having() methods take an arbitrary number of trailing arguments, each of which is a value to bind to a sequential question- mark placeholder in the condition clause. Similarly, the *join*() methods take an optional final argument, a sequential array of values to bind to sequential question-mark placeholders in the condition clause. "},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-4-1-2","title":"4.13.4.1.2. Resetting Query Elements","content":"The Select class comes with the following methods to \"reset\" various clauses a blank state. This can be useful when reusing the same query in different variations (e.g., to re-issue a query to get a COUNT(*) without a LIMIT, to find the total number of rows to be paginated over). resetCols() removes all columns resetTable() removes all FROM and JOIN clauses resetWhere(), resetGroupBy(), resetHaving(), and resetOrderBy() remove the respective clauses resetUnions() removes all UNION and UNION ALL clauses resetFlags() removes all database-engine-specific flags resetBindValues() removes all values bound to named placeholders "},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-4-1-3","title":"4.13.4.1.3. Issuing The Query","content":"Once you have built the query, pass it to the database connection of your choice as a string, and send the bound values along with it.&lt;?php \/\/ a PDO connection $pdo = new PDO(...); \/\/ prepare the statment $sth = $pdo-&gt;prepare($select-&gt;getStatement()); \/\/ bind the values and execute $sth-&gt;execute($select-&gt;getBindValues()); \/\/ get the results back as an associative array $result = $sth-&gt;fetch(PDO::FETCH_ASSOC); ?&gt; "},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-4-2-1","title":"4.13.4.2.1. Single-Row Insert","content":"Build an Insert query using the following methods. They do not need to be called in any particular order, and may be called multiple times.&lt;?php $insert = $query_factory-&gt;newInsert(); $insert -&gt;into('foo') \/\/ INTO this table -&gt;cols(array( \/\/ bind values as \"(col) VALUES (:col)\" 'bar', 'baz', )) -&gt;set('ts', 'NOW()') \/\/ raw value as \"(ts) VALUES (NOW())\" -&gt;bindValue('foo', 'foo_val') \/\/ bind one value to a placeholder -&gt;bindValues(array( \/\/ bind these values 'bar' =&gt; 'foo', 'baz' =&gt; 'zim', )); ?&gt; The cols() method allows you to pass an array of key-value pairs where the key is the column name and the value is a bind value (not a raw value):&lt;?php $insert = $query_factory-&gt;newInsert(); $insert-&gt;into('foo') \/\/ insert into this table -&gt;cols(array( \/\/ insert these columns and bind these values 'foo' =&gt; 'foo_value', 'bar' =&gt; 'bar_value', 'baz' =&gt; 'baz_value', )); ?&gt; Once you have built the query, pass it to the database connection of your choice as a string, and send the bound values along with it.&lt;?php \/\/ the PDO connection $pdo = new PDO(...); \/\/ prepare the statement $sth = $pdo-&gt;prepare($insert-&gt;getStatement()); \/\/ execute with bound values $sth-&gt;execute($insert-&gt;getBindValues()); \/\/ get the last insert ID $name = $insert-&gt;getLastInsertIdName('id'); $id = $pdo-&gt;lastInsertId($name); ?&gt; "},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-4-2-2","title":"4.13.4.2.2. Multiple-Row (Bulk) Insert","content":"If you want to do a multiple-row or bulk insert, call the addRow() method after finishing the first row, then build the next row you want to insert. The columns in the rows after the first will be inserted in the same order as the first row.&lt;?php $insert = $query_factory-&gt;newInsert(); \/\/ insert into this table $insert-&gt;into('foo'); \/\/ set up the first row $insert-&gt;cols(array( 'bar' =&gt; 'bar-0', 'baz' =&gt; 'baz-0' )); $insert-&gt;set('ts', 'NOW()'); \/\/ set up the second row. the columns here are in a different order \/\/ than in the first row, but it doesn't matter; the INSERT object \/\/ keeps track and builds them the same order as the first row. $insert-&gt;addRow(); $insert-&gt;set('ts', 'NOW()'); $insert-&gt;cols(array( 'bar' =&gt; 'bar-1', 'baz' =&gt; 'baz-1' )); \/\/ set up further rows ... $insert-&gt;addRow(); \/\/ ... \/\/ execute a bulk insert of all rows $pdo = new PDO(...); $sth = $pdo-&gt;prepare($insert-&gt;getStatement()); $sth-&gt;execute($insert-&gt;getBindValues()); ?&gt;  N.b.: If you add a row and do not specify a value for a column that was present in the first row, the Insert will throw an exception. If you pass an array of column key-value pairs to addRow(), they will be bound to the next row, thus allowing you to skip setting up the first row manually with col() and cols():&lt;?php \/\/ set up the first row $insert-&gt;addRow(array( 'bar' =&gt; 'bar-0', 'baz' =&gt; 'baz-0' )); $insert-&gt;set('ts', 'NOW()'); \/\/ set up the second row $insert-&gt;addRow(array( 'bar' =&gt; 'bar-1', 'baz' =&gt; 'baz-1' )); $insert-&gt;set('ts', 'NOW()'); \/\/ etc. ?&gt; If you only need to use bound values, and do not need to set raw values, and have the entire data set as an array already, you can use addRows() to add them all at once:&lt;?php $rows = array( array( 'bar' =&gt; 'bar-0', 'baz' =&gt; 'baz-0' ), array( 'bar' =&gt; 'bar-1', 'baz' =&gt; 'baz-1' ), ); $insert-&gt;addRows($rows); ?&gt;  N.b.: SQLite 3.7.10 and earlier do not support the \"standard\" multiple-row insert syntax. Thus, bulk inserts with Insert object will not work on those earlier versions of SQLite. We suggest wrapping multuple INSERT operations with a transaction as an alternative. "},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-4-3","title":"4.13.4.3. UPDATE","content":"Build an Update query using the following methods. They do not need to be called in any particular order, and may be called multiple times.&lt;?php $update = $query_factory-&gt;newUpdate(); $update -&gt;table('foo') \/\/ update this table -&gt;cols(array( \/\/ bind values as \"SET bar = :bar\" 'bar', 'baz', )) -&gt;set('ts', 'NOW()') \/\/ raw value as \"(ts) VALUES (NOW())\" -&gt;where('zim = :zim') \/\/ AND WHERE these conditions -&gt;where('gir = ?', 'doom') \/\/ bind this value to the condition -&gt;orWhere('gir = :gir') \/\/ OR WHERE these conditions -&gt;bindValue('bar', 'bar_val') \/\/ bind one value to a placeholder -&gt;bindValues(array( \/\/ bind these values to the query 'baz' =&gt; 99, 'zim' =&gt; 'dib', 'gir' =&gt; 'doom', )); ?&gt; The cols() method allows you to pass an array of key-value pairs where the key is the column name and the value is a bind value (not a raw value):&lt;?php $update = $query_factory-&gt;newUpdate(); $update-&gt;table('foo') \/\/ update this table -&gt;cols(array( \/\/ update these columns and bind these values 'foo' =&gt; 'foo_value', 'bar' =&gt; 'bar_value', 'baz' =&gt; 'baz_value', )); ?&gt; Once you have built the query, pass it to the database connection of your choice as a string, and send the bound values along with it.&lt;?php \/\/ the PDO connection $pdo = new PDO(...); \/\/ prepare the statement $sth = $pdo-&gt;prepare($update-&gt;getStatement()) \/\/ execute with bound values $sth-&gt;execute($update-&gt;getBindValues()); ?&gt; "},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-4-4","title":"4.13.4.4. DELETE","content":"Build a Delete query using the following methods. They do not need to be called in any particular order, and may be called multiple times.&lt;?php $delete = $query_factory-&gt;newDelete(); $delete -&gt;from('foo') \/\/ FROM this table -&gt;where('zim = :zim') \/\/ AND WHERE these conditions -&gt;where('gir = ?', 'doom') \/\/ bind this value to the condition -&gt;orWhere('gir = :gir') \/\/ OR WHERE these conditions -&gt;bindValue('bar', 'bar_val') \/\/ bind one value to a placeholder -&gt;bindValues(array( \/\/ bind these values to the query 'baz' =&gt; 99, 'zim' =&gt; 'dib', 'gir' =&gt; 'doom', )); ?&gt; Once you have built the query, pass it to the database connection of your choice as a string, and send the bound values along with it.&lt;?php \/\/ the PDO connection $pdo = new PDO(...); \/\/ prepare the statement $sth = $pdo-&gt;prepare($delete-&gt;getStatement()) \/\/ execute with bound values $sth-&gt;execute($delete-&gt;getBindValues()); ?&gt; "},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-5","title":"4.13.5. MySQL Query Objects ('mysql')","content":"These 'mysql' query objects have additional MySQL-specific methods: SELECT calcFoundRows() to add or remove SQL_CALC_FOUND_ROWS flag cache() to add or remove SQL_CACHE flag noCache() to add or remove SQL_NO_CACHE flag bigResult() to add or remove SQL_BIG_RESULT flag smallResult() to add or remove SQL_SMALL_RESULT flag bufferResult() to add or remove SQL_BUFFER_RESULT flag highPriority() to add or remove HIGH_PRIORITY flag straightJoin() to add or remove STRAIGHT_JOIN flag INSERT highPriority() to add or remove HIGH_PRIORITY flag lowPriority() to add or remove LOW_PRIORITY flag ignore() to add or remove IGNORE flag delayed() to add or remove DELAYED flag UPDATE lowPriority() to add or remove LOW_PRIORITY flag ignore() to add or remove IGNORE flag where() and orWhere() to add WHERE conditions flag orderBy() to add an ORDER BY clause flag limit() to set a LIMIT count DELETE lowPriority() to add or remove LOW_PRIORITY flag ignore() to add or remove IGNORE flag quick() to add or remove QUICK flag orderBy() to add an ORDER BY clause limit() to set a LIMIT count In addition, the Insert object has support for ON DUPLICATE KEY UPDATE: onDuplicateKeyUpdate($col, $raw_value) sets a raw value onDuplicateKeyUpateCol($col, $value) is a col() equivalent for the update onDuplicateKeyUpdateCols($cols) is a cols()equivalent for the update Placeholders for bound values in the ON DUPLICATE KEY UPDATE portions will be automatically suffixed with __on_duplicate key to deconflict them from the insert placeholders."},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-6","title":"4.13.6. PostgreSQL Query Objects ('pgsql')","content":"These 'pgsql' query objects have additional PostgreSQL-specific methods: INSERT returning() to add a RETURNING clause UPDATE returning() to add a RETURNING clause DELETE returning() to add a RETURNING clause "},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-6-1","title":"4.13.6.1. Last Insert ID Names in PostgreSQL","content":"PostgreSQL determines the default sequence name for the last inserted ID by concatenating the table name, the column name, and a seq suffix, using underscore separators (e.g. table_col_seq).However, when inserting into an extended or inherited table, the parent table is used for the sequence name, not the child (insertion) table. This package allows you to override the default last-insert-id name with the method setLastInsertIdNames() on both QueryFactory and the Insert object itself. Pass an array of inserttable.col keys mapped to parenttable_col_seq values, and the Insert object will use the mapped sequence names instead of the default names.&lt;?php $query_factory-&gt;setLastInsertIdNames(array( 'child.id' =&gt; 'parent_id_seq' )); $insert = $query_factory-&gt;newInsert(); $insert-&gt;into('child'); \/\/ ... $seq = $insert-&gt;getLastInsertIdName('id'); ?&gt; The $seq name is now parent_id_seq, not child_id_seq as it would have been by default."},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-7","title":"4.13.7. SQLite Query Objects ('sqlite')","content":"These 'sqlite' query objects have additional SQLite-specific methods: INSERT orAbort() to add or remove an OR ABORT flag orFail() to add or remove an OR FAIL flag orIgnore() to add or remove an OR IGNORE flag orReplace() to add or remove an OR REPLACE flag orRollback() to add or remove an OR ROLLBACK flag UPDATE orAbort() to add or remove an OR ABORT flag orFail() to add or remove an OR FAIL flag orIgnore() to add or remove an OR IGNORE flag orReplace() to add or remove an OR REPLACE flag orRollback() to add or remove an OR ROLLBACK flag orderBy() to add an ORDER BY clause limit() to set a LIMIT count offset() to set an OFFSET count DELETE orAbort() to add or remove an OR ABORT flag orFail() to add or remove an OR FAIL flag orIgnore() to add or remove an OR IGNORE flag orReplace() to add or remove an OR REPLACE flag orRollback() to add or remove an OR ROLLBACK flag orderBy() to add an ORDER BY clause limit() to set a LIMIT count offset() to set an OFFSET count "},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-8","title":"4.13.8. Microsoft SQL Query Objects ('sqlsrv')","content":"The 'sqlsrv' query objects have no additional methods specific to Microsoft SQL Server.In general, limit() and offset() with Microsoft SQL Server are best combined with orderBy(). The limit() and offset() methods on the Microsoft SQL Server query objects will generate sqlsrv-specific variations of LIMIT ... OFFSET: If only a LIMIT is present, it will be translated as a TOP clause. If both LIMIT and OFFSET are present, it will be translated as an OFFSET ... ROWS FETCH NEXT ... ROWS ONLY clause. In this case there must be an ORDER BY clause, as the limiting clause is a sub-clause of ORDER BY. "},{"id":"\/packages\/2.x\/SqlQuery.html#4-13-9","title":"4.13.9. Table Prefixes","content":"One frequently-requested feature for this package is support for \"automatic table prefixes\" on all queries. This feature sounds great in theory, but in practice is it (1) difficult to implement well, and (2) even when implemented it turns out to be not as great as it seems in theory. This assessment is the result of the hard trials of experience. For those of you who want modifiable table prefixes, we suggest using constants with your table names prefixed as desired; as the prefixes change, you can then change your constants."},{"id":"\/packages\/2.x\/SqlSchema.html#4-14","title":"4.14. Aura.SqlSchema","content":"Provides facilities to read table names and table columns from a database using a PDO connection."},{"id":"\/packages\/2.x\/SqlSchema.html#4-14-1-1","title":"4.14.1.1. Installation","content":"This library requires PHP 5.3 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/sqlschema.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/SqlSchema.html#4-14-1-2","title":"4.14.1.2. Quality","content":" To run the unit tests at the command line, issue phpunit at the package root. (This requires PHPUnit to be available as phpunit.)This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/SqlSchema.html#4-14-1-3","title":"4.14.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/SqlSchema.html#4-14-2-1","title":"4.14.2.1. Instantiation","content":"Instantiate a driver-specific schema object with a matching PDO instance:&lt;?php use Aura\\SqlSchema\\ColumnFactory; use Aura\\SqlSchema\\MysqlSchema; \/\/ for MySQL use Aura\\SqlSchema\\PgsqlSchema; \/\/ for PostgreSQL use Aura\\SqlSchema\\SqliteSchema; \/\/ for Sqlite use Aura\\SqlSchema\\SqlsrvSchema; \/\/ for Microsoft SQL Server use PDO; \/\/ a PDO connection $pdo = new PDO(...); \/\/ a column definition factory $column_factory = new ColumnFactory(); \/\/ the schema discovery object $schema = new MysqlSchema($pdo, $column_factory); ?&gt; "},{"id":"\/packages\/2.x\/SqlSchema.html#4-14-2-2","title":"4.14.2.2. Fetching Table Lists","content":"To get a list of tables in the database, issue fetchTableList():&lt;?php $tables = $schema-&gt;fetchTableList(); foreach ($tables as $table) { echo $table . PHP_EOL; } ?&gt; "},{"id":"\/packages\/2.x\/SqlSchema.html#4-14-2-3","title":"4.14.2.3. Fetching Column Information","content":"To get information about the columns in a table, issue fetchTableCols():&lt;?php $cols = $schema-&gt;fetchTableCols('table_name'); foreach ($cols as $name =&gt; $col) { echo \"Column $name is of type \" . $col-&gt;type . \" with a size of \" . $col-&gt;size . PHP_EOL; } ?&gt; Each column description is a Column object with the following properties: name: (string) The column name type: (string) The column data type. Data types are as reported by the database. size: (int) The column size. scale: (int) The number of decimal places for the column, if any. notnull: (bool) Is the column marked as NOT NULL? default: (mixed) The default value for the column. Note that sometimes this will be null if the underlying database is going to set a timestamp automatically. autoinc: (bool) Is the column auto-incremented? primary: (bool) Is the column part of the primary key? "},{"id":"\/packages\/2.x\/View.html#4-15","title":"4.15. Aura View","content":"This package provides an implementation of the TemplateView and TwoStepView patterns using PHP itself as the templating language. It supports both file-based and closure-based templates along with helpers and sections.It is preceded by systems such as Savant, Zend_View, and Solar_View."},{"id":"\/packages\/2.x\/View.html#4-15-1-1","title":"4.15.1.1. Installation","content":"This library requires PHP 5.4 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/view.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/View.html#4-15-1-2","title":"4.15.1.2. Quality","content":" To run the unit tests at the command line, issue composer install and then .\/vendor\/bin\/phpunit at the package root. This requires Composer to be available as composer.This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/View.html#4-15-1-3","title":"4.15.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/View.html#4-15-2-1","title":"4.15.2.1. Instantiation","content":"To instantiate a View object, use the ViewFactory:&lt;?php $view_factory = new \\Aura\\View\\ViewFactory; $view = $view_factory-&gt;newInstance(); ?&gt; "},{"id":"\/packages\/2.x\/View.html#4-15-2-2","title":"4.15.2.2. Escaping Output","content":"Security-minded observers will note that all the examples in this document use manually-escaped output. Because this package is not specific to any particular media type, it does not come with escaping functionality.When you generate output via templates, you must escape it appropriately for security purposes. This means that HTML templates should use HTML escaping, CSS templates should use CSS escaping, XML templates should use XML escaping, PDF templates should use PDF escaping, RTF templates should use RTF escaping, and so on.For a good set of HTML escapers, please consider Aura.Html."},{"id":"\/packages\/2.x\/View.html#4-15-2-3","title":"4.15.2.3. Registering View Templates","content":"Now that we have a View, we need to add named templates to its view template registry. These are typically PHP file paths, but templates can also be closures. For example:&lt;?php $view_registry = $view-&gt;getViewRegistry(); $view_registry-&gt;set('browse', '\/path\/to\/views\/browse.php'); ?&gt; The browse.php file may look something like this:&lt;?php foreach ($this-&gt;items as $item) { $id = htmlspecialchars($item['id'], ENT_QUOTES, 'UTF-8'); $name = htmlspecialchars($item['name'], ENT_QUOTES, 'UTF-8'); echo \"Item ID #{$id} is '{$name}'.\" . PHP_EOL; } ?&gt; Note that we use echo, and not return, in templates. N.b.: The template logic will be executed inside the View object scope, which means that $this in the template code will refer to the View object. The same is true for closure-based templates. "},{"id":"\/packages\/2.x\/View.html#4-15-2-4","title":"4.15.2.4. Setting Data","content":"We will almost always want to use dynamic data in our templates. To assign a data collection to the View, use the setData() method and either an array or an object. We can then use data elements as if they are properties on the View object.&lt;?php $view-&gt;setData(array( 'items' =&gt; array( array( 'id' =&gt; '1', 'name' =&gt; 'Foo', ), array( 'id' =&gt; '2', 'name' =&gt; 'Bar', ), array( 'id' =&gt; '3', 'name' =&gt; 'Baz', ), ) )); ?&gt;  N.b.: Recall that $this in the template logic refers to the View object, so that data assigned to the View can be accessed as properties on $this. The setData() method will overwrite all existing data in the View object. The addData() method, on the other hand, will merge with existing data in the View object."},{"id":"\/packages\/2.x\/View.html#4-15-2-5","title":"4.15.2.5. Invoking A One-Step View","content":"Now that we have registered a template and assigned some data to the View, we tell the View which template to use, and then invoke the View:&lt;?php $view-&gt;setView('browse'); $output = $view-&gt;__invoke(); \/\/ or just $view() ?&gt; The $output in this case will be something like this:Item #1 is 'Foo'. Item #2 is 'Bar'. Item #3 is 'Baz'. "},{"id":"\/packages\/2.x\/View.html#4-15-2-6","title":"4.15.2.6. Using Sub-Templates (aka \"Partials\")","content":"Sometimes we will want to split a template up into multiple pieces. We can render these \"partial\" template pieces using the render() method in our main template code.First, we place the sub-template in the view registry (or in the layout registry if it for use in layouts). Then we render() it from inside the main template code. Sub-templates can use any naming scheme we like. Some systems use the convention of prefixing partial templates with an underscore, and the following example will use that convention.Second, we can pass an array of variables to be extracted into the local scope of the partial template. (The $this variable will always be available regardless.)For example, let's split up our browse.php template file so that it uses a sub-template for displaying items.&lt;?php \/\/ add templates to the view registry $view_registry = $view-&gt;getViewRegistry(); \/\/ the \"main\" template $view_registry-&gt;set('browse', '\/path\/to\/views\/browse.php'); \/\/ the \"sub\" template $view_registry-&gt;set('_item', '\/path\/to\/views\/_item.php'); ?&gt; We extract the item-display code from browse.php into _item.php:&lt;?php $id = htmlspecialchars($item['id'], ENT_QUOTES, 'UTF-8'); $name = htmlspecialchars($item['name'], ENT_QUOTES, 'UTF-8') echo \"Item ID #{$id} is '{$name}'.\" . PHP_EOL; ?&gt; Then we modify browse.php to use the sub-template:&lt;?php foreach ($this-&gt;items as $item) { echo $this-&gt;render('_item', array( 'item' =&gt; $item, )); ?&gt; The output will be the same as earlier when we invoke the view. N.b.: Alternatively, we can use include or require to execute a PHP file directly in the current template scope. "},{"id":"\/packages\/2.x\/View.html#4-15-2-7","title":"4.15.2.7. Using Sections","content":"Sections are similar to sub-templates (aka \"partials\") except that they are captured inline for later use. In general, they are used by view templates to capture output for layout templates.For example, we can capture output in the view template to a named section ...&lt;?php \/\/ begin buffering output for a named section $this-&gt;beginSection('local-nav'); echo \"&lt;div&gt;\"; \/\/ ... echo the local navigation output ... echo \"&lt;\/div&gt;\"; \/\/ end buffering and capture the output $this-&gt;endSection(); ?&gt; ... and then use that output in a layout template:&lt;?php if ($this-&gt;hasSection('local-nav')) { echo $this-&gt;getSection('local-nav'); } else { echo \"&lt;div&gt;No local navigation.&lt;\/div&gt;\"; } ?&gt; In addition, the setSection() method can be used to set the section body directly, instead of capturing it:&lt;?php $this-&gt;setSection('local-nav', $this-&gt;render('_local-nav')); ?&gt; "},{"id":"\/packages\/2.x\/View.html#4-15-2-8","title":"4.15.2.8. Using Helpers","content":"The ViewFactory instantiates the View with an empty HelperRegistry to manage helpers. We can register closures or other invokable objects as helpers through the HelperRegistry. We can then call these helpers as if they are methods on the View.&lt;?php $helpers = $view-&gt;getHelpers(); $helpers-&gt;set('hello', function ($name) { return \"Hello {$name}!\"; }); $view_registry = $view-&gt;getViewRegistry(); $view_registry-&gt;set('index', function () { echo $this-&gt;hello('World'); }); $view-&gt;setView('index'); $output = $view(); ?&gt; This library does not come with any view helpers. You will need to add your own helpers to the registry as closures or invokable objects."},{"id":"\/packages\/2.x\/View.html#4-15-2-9","title":"4.15.2.9. Custom Helper Managers","content":"The View is not type-hinted to any particular class for its helper manager. This means you may inject an arbitrary object of your own at View construction time to manage helpers. To do so, pass a helper manager of your own to the ViewFactory.&lt;?php class OtherHelperManager { public function __call($helper_name, $args) { \/\/ logic to call $helper_name with \/\/ $args and return the result } } $helpers = new OtherHelperManager; $view = $view_factory-&gt;newInstance($helpers); ?&gt; For a comprehensive set of HTML helpers, including form and input helpers, please consider the Aura.Html package and its HelperLocator as an alternative to the HelperRegistry in this package. You can pass it to the ViewFactory like so:&lt;?php $helpers_factory = new Aura\\Html\\HelperLocatorFactory; $helpers = $helpers_factory-&gt;newInstance(); $view = $view_factory-&gt;newInstance($helpers); ?&gt; "},{"id":"\/packages\/2.x\/View.html#4-15-2-10","title":"4.15.2.10. Rendering a Two-Step View","content":"To wrap the main content in a layout as part of a two-step view, we register layout templates with the View and then call setLayout() to pick one of them for the second step. (If no layout is set, the second step will not be executed.)Let's say we have already set the browse template above into our view registry. We then set a layout template called default into the layout registry:&lt;?php $layout_registry = $view-&gt;getLayoutRegistry(); $layout_registry-&gt;set('default', '\/path\/to\/layouts\/default.php'); ?&gt; The default.php layout template might look like this:&lt;html&gt; &lt;head&gt; &lt;title&gt;My Site&lt;\/title&gt; &lt;\/head&gt; &lt;body&gt; &lt;?= $this-&gt;getContent(); ?&gt; &lt;\/body&gt; &lt;\/html&gt; We can then set the view and layout templates on the View object and then invoke it:&lt;?php $view-&gt;setView('browse'); $view-&gt;setLayout('default'); $output = $view-&gt;__invoke(); \/\/ or just $view() ?&gt; The output from the inner view template is automatically retained and becomes available via the getContent() method on the View object. The layout template then calls getContent() to place the inner view results in the outer layout template. N.b. We can also call setLayout() from inside the view template, allowing us to pick a layout as part of the view logic. The view template and the layout template both execute inside the same View object. This means: All data values are shared between the view and the layout. Any data assigned to the view, or modified by the view, is used as-is by the layout. All helpers are shared between the view and the layout. This sharing situation allows the view to modify data and helpers before the layout is executed. All section bodies are shared between the view and the layout. A section that is captured from the view template can therefore be used by the layout template. "},{"id":"\/packages\/2.x\/View.html#4-15-2-11","title":"4.15.2.11. Closures As Templates","content":"The view and layout registries accept closures as templates. For example, these are closure-based equivlents of the browse.php and _item.php template files above:&lt;?php $view_registry-&gt;set('browse', function () { foreach ($this-&gt;items as $item) { echo $this-&gt;render('_item', array( 'item' =&gt; $item, )); } ); $view_registry-&gt;set('_item', function (array $vars) { extract($vars, EXTR_SKIP); $id = htmlspecialchars($item['id'], ENT_QUOTES, 'UTF-8'); $name = htmlspecialchars($item['name'], ENT_QUOTES, 'UTF-8') echo \"Item ID #{$id} is '{$name}'.\" . PHP_EOL; ); ?&gt; When registering a closure-based template, continue to use echo instead of return when generating output. The closure is rebound to the View object, so $this in the closure will refer to the View just as it does in a file-based template.A bit of extra effort is required with closure-based sub-templates (aka \"partials\"). Whereas file-based templates automatically extract the passed array of variables into the local scope, a closure-based template must: Define a function parameter to receive the injected variables (the $vars param in the _item template); and, Extract the injected variables using extract(). Alternatively, the closure may use the injected variables parameter directly. Aside from that, closure-based templates work exactly like file-based templates."},{"id":"\/packages\/2.x\/View.html#4-15-2-12","title":"4.15.2.12. Registering Template Search Paths","content":"We can also tell the view and layout registries to search the filesystem for templates. First, we tell the registry what directories contain template files:&lt;?php $view_registry = $view-&gt;getViewRegistry(); $view_registry-&gt;setPaths(array( '\/path\/to\/foo', '\/path\/to\/bar', '\/path\/to\/baz' )); ?&gt; When we refer to named templates later, the registry will search from the first directory to the last. For finer control over the search paths, we can call prependPath() to add a directory to search earlier, or appendPath() to add a directory to search later. Regardless, the View will auto-append .php to the end of template names when searching through the directories."},{"id":"\/packages\/2.x\/View.html#4-15-2-13","title":"4.15.2.13. Changing The Template File Extension","content":"By default, each TemplateRegistry will auto-append .php to template file names. If the template files end with a different extension, change it usin the setTemplateFileExtension() method:&lt;?php $view_registry = $view-&gt;getViewRegistry(); $view_registry-&gt;setTemplateFileExtension('.phtml'); ?&gt; The TemplateRegistry instance used for the layouts is separate from the one for the views, so it may be necessary to change the template file extension on it as well:&lt;?php $layout_registry = $view-&gt;getLayoutRegistry(); $layout_registry-&gt;setTemplateFileExtension('.phtml'); ?&gt; "},{"id":"\/packages\/2.x\/View.html#4-15-2-14","title":"4.15.2.14. Advanced Configuration","content":"Alternatively you can pass $helpers, mapping information or paths for views and layouts as below.&lt;?php $view_factory = new \\Aura\\View\\ViewFactory; $view = $view_factory-&gt;newInstance( $helpers = null, [ 'browse' =&gt; '\/path\/to\/views\/browse.php' ], [ '\/path\/to\/views\/welcome', '\/path\/to\/views\/user', ], [ 'layout' =&gt; '\/path\/to\/layouts\/default.php' ], [ '\/path\/to\/layouts', ], ); ?&gt; If you are passing the mapping information or paths to views and layouts you don't need to call the getViewRegistry or getLayoutRegistry and set the mapping information.Eg :$view_registry = $view-&gt;getViewRegistry(); $view_registry-&gt;set('browse', '\/path\/to\/views\/browse.php'); $layout_registry = $view-&gt;getLayoutRegistry(); $layout_registry-&gt;set('default', '\/path\/to\/layouts\/default.php'); "},{"id":"\/packages\/2.x\/Web.html#4-16","title":"4.16. Aura.Web","content":"Provides web Request and Response objects for use by web controllers and actions. These are representations of the PHP web environment, not HTTP request and response objects proper."},{"id":"\/packages\/2.x\/Web.html#4-16-1-1","title":"4.16.1.1. Installation","content":"This library requires PHP 5.3 or later; we recommend using the latest available version of PHP as a matter of principle. It has no userland dependencies.It is installable and autoloadable via Composer as aura\/web.Alternatively, download a release or clone this repository, then require or include its autoload.php file."},{"id":"\/packages\/2.x\/Web.html#4-16-1-2","title":"4.16.1.2. Quality","content":" To run the unit tests at the command line, issue composer install and then phpunit at the package root. This requires Composer to be available as composer, and PHPUnit to be available as phpunit.This library attempts to comply with PSR-1, PSR-2, and PSR-4. If you notice compliance oversights, please send a patch via pull request."},{"id":"\/packages\/2.x\/Web.html#4-16-1-3","title":"4.16.1.3. Community","content":"To ask questions, provide feedback, or otherwise communicate with the Aura community, please join our Google Group, follow @auraphp on Twitter, or chat with us on #auraphp on Freenode."},{"id":"\/packages\/2.x\/Web.html#4-16-2-1","title":"4.16.2.1. Instantiation","content":"First, instantiate a WebFactory object, then use it to create Request and Response objects.&lt;?php use Aura\\Web\\WebFactory; $web_factory = new WebFactory($GLOBALS); $request = $web_factory-&gt;newRequest(); $response = $web_factory-&gt;newResponse(); ?&gt; Note that if jit-globals is turned on, merely passing $GLOBALS will not work properly. In this case, use compact() to pass the needed values. For example:&lt;?php use Aura\\Web\\WebFactory; $web_factory = new WebFactory(array( '_ENV' =&gt; $_ENV, '_GET' =&gt; $_GET, '_POST' =&gt; $_POST, '_COOKIE' =&gt; $_COOKIE, '_SERVER' =&gt; $_SERVER )); $request = $web_factory-&gt;newRequest(); $response = $web_factory-&gt;newResponse(); ?&gt; "},{"id":"\/packages\/2.x\/Web.html#4-16-2-2","title":"4.16.2.2. Request and Response Objects","content":"Because each object contains so much functionality, we have split up the documentation into a Request page and a Response page.By way of overview, the Request object has these sub-objects ... $request-&gt;cookies for $_COOKIES $request-&gt;env for $_ENV $request-&gt;files for $_FILES $request-&gt;post for $_POST $request-&gt;query for $_GET $request-&gt;server for $_SERVER $request-&gt;client for the client making the request $request-&gt;content for the raw body of the request $request-&gt;headers for the request headers $request-&gt;method for the request method $request-&gt;params for path-info parameters $request-&gt;url for the request URL ... and the Response object has these sub-objects: $response-&gt;status for the status code, status phrase, and HTTP version $response-&gt;headers for non-cookie headers $response-&gt;cookies for cookie headers $response-&gt;content for describing the response content, and for convenience methods related to content type, charset, disposition, and filename $response-&gt;cache for convenience methods related to cache headers $response-&gt;redirect for convenience methods related to Location and Status Once you have built a Response you can send it with any HTTP mechanism you prefer, including plain PHP.Be sure to read the Request and Response pages for more detailed information."}]