---
layout: site
active: packages
title: Custom Maps
---
<script>hljs.initHighlightingOnLoad();</script>

<nav class="navheader">
    <table>
        <tr>
            <th colspan="3" class="curr">1.5. Custom Maps</th>
        </tr>
        <tr>
            <td class="prev"><a href="/packages/Aura.Router/generating-paths.html">Generating Paths From Routes</a></td>
            <td class="parent">1. Aura.Router</th>
            <td class="next"><a href="/packages/Aura.Router/custom-matching.html">Custom Matching Rules</a></td>
        </tr>
    </table>
</nav>
<h1 id="1.5">1.5. Custom Maps</h1>
<h2 id="1.5.1">1.5.1. Extending the Map Class</h2>
<p>You might want to extend the <em>Map</em> class to provide convenience methods specific to your application. As with writing a custom matching rule, this is a bit involved but not difficult:</p>
<ol>
<li>
<p>Write your <em>Map</em> extended class.</p>
</li>
<li>
<p>Add your extended class factory to the <em>RouterContainer</em>.</p>
</li>
<li>
<p>Use the <em>RouterContainer</em> as normal, and it will return your custom <em>Map</em> class.</p>
</li>
</ol>
<p>For example, you may wish to have a <code>resource()</code> method that automatically attaches a series of routes all at once for a given route name and route path.  First, write your extension of the <em>Map</em> class:</p>
<pre><code class="language-php">&lt;?php
use Aura\Router\Map;

class MyResourceMap extends Map
{
    public function resource($namePrefix, $pathPrefix)
    {
        return $this-&gt;attach($namePrefix, $pathPrefix, function ($map) {
            $map-&gt;get('browse', '');
            $map-&gt;get('read', '/{id}');
            $map-&gt;patch('edit', '/{id}');
            $map-&gt;post('add', '');
            $map-&gt;delete('delete', '/{id}');
        });
    }
}
?&gt;
</code></pre>
<p>Then tell the <em>RouterContainer</em> how to create your extended class using a factory callable:</p>
<pre><code class="language-php">&lt;?php
use Aura\Router\Route;

$routerContainer-&gt;setMapFactory(function () {
    return new MyResourceMap(new Route());
});
?&gt;
</code></pre>
<p>Now you can get the <em>Map</em> from the <em>RouterContainer</em>, and it will be your custom extended class:</p>
<pre><code class="language-php">&lt;?php
$map = $routerContainer-&gt;getMap();
echo get_class($map); // "ResourceMap"
?&gt;
</code></pre>
<h2 id="1.5.2">1.5.2. Automated Route Caching and Building</h2>
<p>You may wish to build your route map from some external source. Alternatively,you mighg want to cache your route map for production deployments so that you do not have to add the routes from scratch on each page load.</p>
<p>To effect these or other automated map-building functionality, call the <code>RouterContainer::setMapBuilder()</code> method and pass a builder callable to set up the <em>Map</em> before the container returns it. The builder callable should take a <em>Map</em> instance as its only argument.</p>
<p>The following is a naive example for file-based caching and restoring of <em>Map</em> routes. It uses the <code>Map::setRoutes()</code> and <code>Map::getRoutes()</code> methods to work with the array of mapped route objects.</p>
<pre><code class="language-php">&lt;?php
$routerContainer-&gt;setMapBuilder(function ($map) {

    // the cache file location
    $cache = '/path/to/routes.cache';

    // does the cache exist?
    if (file_exists($cache)) {

        // restore from the cache
        $routes = unserialize(file_get_contents($cache));
        $map-&gt;setRoutes($routes);

    } else {

        // build the routes on the map ...
        $map-&gt;get(...);
        $map-&gt;post(...);

        // ... then save them to the cache for the next page load
        $routes = $map-&gt;getRoutes();
        file_put_contents($cache, serialize($routes));
    }
});
?&gt;
</code></pre>
<blockquote>
<p>N.b.: If there are closures in the <em>Route</em> objects (e.g. in the handlers), you will not be able to serialize the routes for caching. This is because closures cannot be serialized by PHP. Consider using non-closure callables instead.</p>
</blockquote>
<p>Now when you call <code>$routerContainer-&gt;getMap()</code>, the container will automatically call the map-builder logic and apply it to the <code>$map</code> before returning it.</p>

<nav class="navfooter">
    <table>
        <tr>
            <td class="prev"><a href="/packages/Aura.Router/generating-paths.html">Prev</a></td>
            <td class="parent"><a href="/packages/Aura.Router/">Up</a></td>
            <td class="next"><a href="/packages/Aura.Router/custom-matching.html">Next</a></td>
        </tr>
        <tr>
            <td class="prev">1.4. Generating Paths From Routes</td>
            <td class="parent">1. Aura.Router</td>
            <td class="next">1.6. Custom Matching Rules</td>
        </tr>
    </table>
</nav>
